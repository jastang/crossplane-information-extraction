[{"content":"The base Crossplane installation consists of two pods, the crossplane pod and the crossplane-rbac-manager pod. Both pods install in the crossplane-system namespace by default.\nCrossplane pod Init container Before starting the core Crossplane container an init container runs. The init container installs the core Crossplane Custom Resource Definitions (CRDs), configures Crossplane webhooks and installs any supplied Providers or Configurations.\nTip The Kubernetes documentation contains more information about init containers. The settings the init container sets include installing Provider or Configuration packages with Crossplane, customizing the namespace Crossplane installs in and defining webhook configurations.\nThe core CRDs installed by the init container include:\nCompositeResourceDefinitions, Compositions, Configurations and Providers Locks to manage package dependencies DeploymentRuntimeConfigs to apply settings to installed Providers and Functions StoreConfigs for connecting external secret stores like HashiCorp Vault Note The Install Crossplane section has more information about customizing the Crossplane install. The status Init on the Crossplane pod is the init container running.\n1kubectl get pods -n crossplane-system 2NAME READY STATUS RESTARTS AGE 3crossplane-9f6d5cd7b-r9j8w 0/1 Init:0/1 0 6s The init container completes and starts the Crossplane core container automatically.\n1kubectl get pods -n crossplane-system 2NAME READY STATUS RESTARTS AGE 3crossplane-9f6d5cd7b-r9j8w 1/1 Running 0 15s Core container The main Crossplane container, called the core container, enforces the desired state of Crossplane resources, manages leader elections and process webhooks.\nNote The Crossplane pod only reconciles core Crossplane components, including Claims and composite resources. Providers are responsible for reconciling their managed resources. Reconcile loop The core container operates on a reconcile loop, constantly checking the status of deployed resources and correcting any \u0026ldquo;drift.\u0026rdquo; After checking a resource Crossplane waits some time and checks again.\nCrossplane monitors resources through a Kubernetes watch or through periodic polling. Some resources may be both watched and polled.\nCrossplane requests that the API server notifies Crossplane of any changes on objects. This notification tool is a watch.\nWatched objects include Providers, managed resources and CompositeResourceDefinitions.\nFor objects that Kubernetes can\u0026rsquo;t provide a watch for, Crossplane periodically poll the resource to find it\u0026rsquo;s state. The default polling rate is one minute. Change the polling rate with the --poll-interval pod argument.\nReducing the poll-interval value causes Crossplane to poll resources more frequently. This increases the load of the Crossplane pod and results in more frequent provider API calls.\nIncreasing the poll-interval causes Crossplane to poll resources less frequently. This increases the maximum time until Crossplane discovers changes in the cloud provider that require updating.\nManaged resources use polling.\nNote Managed resources watch for Kubernetes events like deletion or changes to their spec. Managed resources rely on polling to detect changes in the external system. Crossplane double-checks all resources to confirm they\u0026rsquo;re in the desired state. Crossplane does this every one hour by default. Use the --sync-interval Crossplane pod argument to change this interval.\nThe --max-reconcile-rate rate defines the rate, in times per second, Crossplane reconciles resources.\nReducing the --max-reconcile-rate, or making it smaller, reduces CPU resources Crossplane uses, but increases the amount of time until changed resources are fully synced.\nIncreasing the --max-reconcile-rate, or making it larger, increases the CPU resources Crossplane uses but allows Crossplane to reconcile all resources faster.\nImportant Most Providers use their own --max-reconcile-rate. This determines the same settings for Providers and their managed resources. Applying the --max-reconcile-rate to Crossplane only controls the rate for core Crossplane resources. Enable real time Compositions With real time compositions enabled Crossplane watches every composed resource with a Kubernetes watch. Crossplane receives events from the Kubernetes API server when a composed resource changes. For example, when a provider sets the Ready condition to true.\nImportant Real time compositions are an alpha feature. Alpha features aren\u0026rsquo;t enabled by default. With real time compositions enabled, Crossplane doesn\u0026rsquo;t use the --poll-interval settings.\nEnable real time compositions support by changing the Crossplane pod setting and enabling\n--enable-realtime-compositions argument.\n1$ kubectl edit deployment crossplane --namespace crossplane-system 2apiVersion: apps/v1 3kind: Deployment 4spec: 5# Removed for brevity 6 template: 7 spec: 8 containers: 9 - args: 10 - core 11 - start 12 - --enable-realtime-compositions Tip The Crossplane install guide describes enabling feature flags like \u0026ndash;enable-realtime-compositions with Helm. Reconcile retry rate The --max-reconcile-rate setting configures the number of times per second Crossplane or a provider attempts to correct a resource. The default value is 10 times per second.\nAll core Crossplane components share the reconcile rate. Each Provider implements their own max reconcile rate setting.\nNumber of reconcilers The second value --max-reconcile-rate defines is the number of resources that Crossplane can reconcile at once. If there are more resources than the configured --max-reconcile-rate the remaining resources must wait until Crossplane reconciles a an existing resource.\nRead the Change Pod Settings section for instructions on applying these settings.\nRBAC manager pod The Crossplane RBAC manager pod automates required Kubernetes RBAC permissions for Crossplane and Crossplane Providers.\nNote Crossplane installs and enables the RBAC manager by default. Disabling the RBAC manager requires manual Kubernetes permissions definitions for proper Crossplane operations.\nThe RBAC manager design document provides more comprehensive details on the Crossplane RBAC requirements.\nDisable the RBAC manager Disable the RBAC manager after installation by deleting the crossplane-rbac-manager deployment from the crossplane-system namespace.\nDisable the RBAC manager before installation by editing the Helm values.yaml file, setting rbacManager.deploy to false.\nNote Instructions for changing Crossplane pod settings during installation are in the Crossplane Install section. RBAC init container The RBAC manager requires the CompositeResourceDefinition and ProviderRevision resources to be available before starting.\nThe RBAC manager init container waits for these resources before starting the main RBAC manager container.\nRBAC manager container The RBAC manager container preforms the following tasks:\ncreating and binding RBAC roles to Provider ServiceAccounts, allowing them to control their managed resources allowing the crossplane ServiceAccount to create managed resources creating ClusterRoles to access Crossplane resources in all namespaces creating Roles to access Crossplane resources in specific namespaces Use the ClusterRoles to grant access to all Crossplane resources in the cluster.\nUse the Roles to only grant access to Crossplane Claims.\nCrossplane ClusterRoles The RBAC manager creates four Kubernetes ClusterRoles. These Roles grant permissions over cluster wide Crossplane resources.\ncrossplane-admin The crossplane-admin ClusterRole has the following permissions:\nfull access to all Crossplane types full access to all secrets and namespaces (even those unrelated to Crossplane) read-only access to all cluster RBAC roles, CustomResourceDefinitions and events ability to bind RBAC roles to other entities. View the full RBAC policy with\n1kubectl describe clusterrole crossplane:admin crossplane-edit The crossplane-edit ClusterRole has the following permissions:\nfull access to all Crossplane types full access to all secrets (even those unrelated to Crossplane) read-only access to all namespaces and events (even those unrelated to Crossplane). View the full RBAC policy with\n1kubectl describe clusterrole crossplane:edit crossplane-view The crossplane-view ClusterRole has the following permissions:\nread-only access to all Crossplane types read-only access to all namespaces and events (even those unrelated to Crossplane). View the full RBAC policy with\n1kubectl describe clusterrole crossplane:view crossplane-browse The crossplane-browse ClusterRole has the following permissions:\nread-only access to all Crossplane types read-only access to all namespaces and events (even those unrelated to Crossplane). View the full RBAC policy with\n1kubectl describe clusterrole crossplane:browse Crossplane Roles By default the RBAC manager creates three Roles in every namespace. These Roles grant access to Claims in a specific namespace. The RBAC manager dynamically updates the Roles to access the specific API endpoints in a Claim.\nNote The specific details of the namespace Roles are beyond this guide. For more information read the Composite Resource ClusterRole Mechanics section of the RBAC Manager design document. You can disable these namespace specific roles by configuring the RBAC manager with --manage=Basic.\nNote Instructions for changing Crossplane pod settings during installation are in the Crossplane Install section. Leader election By default only a single Crossplane pod runs in a cluster. If more than one Crossplane pod runs both pods try to manage Crossplane resources. To prevent conflicts Crossplane uses a leader election to have a single pod in control at a time. Other Crossplane pods standby until the leader fails.\nNote It\u0026rsquo;s possible to run more than one Crossplane or RBAC manager pods for redundancy.\nKubernetes restarts any failed Crossplane or RBAC manager pods. Redundant pods aren\u0026rsquo;t required in most deployments.\nBoth the Crossplane pod and the RBAC manager pods support leader elections.\nEnable leader elections with the --leader-election pod argument.\nWarning Running multiple Crossplane pods without leader election is unsupported.\nChange pod settings Change Crossplane pod settings either before installing Crossplane by editing the Helm values.yml file or after installation by editing the Deployment.\nThe full list of configuration options and feature flags are available in the Crossplane Install section.\nNote Instructions for changing Crossplane pod settings during installation are in the Crossplane Install section. Edit the deployment Note These settings apply to both the crossplane and rbac-manager pods and Deployments. To change the settings of an installed Crossplane pod, edit the crossplane deployment in the crossplane-system namespace with the command\nkubectl edit deployment crossplane --namespace crossplane-system\nWarning Updating the Crossplane deployment restarts the Crossplane pod. Add Crossplane pod arguments to the spec.template.spec.containers[].args section of the deployment.\nFor example, to change the sync-interval add --sync-interval=30m.\n1kubectl edit deployment crossplane --namespace crossplane-system 2apiVersion: apps/v1 3kind: Deployment 4spec: 5# Removed for brevity 6 template: 7 spec: 8 containers: 9 - args: 10 - core 11 - start 12 - --sync-interval=30m Use environmental variables The core Crossplane pod checks for configured environmental variables at startup to change default settings.\nThe full list of configurable environmental variables are available in the Crossplane Install section.\n","title":"Crossplane Pods","url":"/v1.14/concepts/pods/"},{"content":"Crossplane connects your Kubernetes cluster to external, non-Kubernetes resources, and allows platform teams to build custom Kubernetes APIs to consume those resources.\nCrossplane creates Kubernetes Custom Resource Definitions (CRDs) to represent the external resources as native Kubernetes objects. As native Kubernetes objects, you can use standard commands like kubectl create and kubectl describe. The full Kubernetes API is available for every Crossplane resource.\nCrossplane also acts as a Kubernetes Controller to watch the state of the external resources and provide state enforcement. If something modifies or deletes a resource outside of Kubernetes, Crossplane reverses the change or recreates the deleted resource.\nWith Crossplane installed in a Kubernetes cluster, users only communicate with Kubernetes. Crossplane manages the communication to external resources like AWS, Azure or Google Cloud.\nCrossplane also allows the creation of custom Kubernetes APIs. Platform teams can combine external resources and simplify or customize the APIs presented to the platform consumers.\nCrossplane components overview This table provides a summary of Crossplane components and their roles.\nComponent Abbreviation Scope Summary Provider cluster Creates new Kubernetes Custom Resource Definitions for an external service. ProviderConfig PC cluster Applies settings for a Provider. Managed Resource MR cluster A Provider resource created and managed by Crossplane inside the Kubernetes cluster. Composition cluster A template for creating multiple managed resources at once. Composite Resources XR cluster Uses a Composition template to create multiple managed resources as a single Kubernetes object. CompositeResourceDefinitions XRD cluster Defines the API schema for Composite Resources and Claims Claims XC namespace Like a Composite Resource, but namespace scoped. The Crossplane Pod When installed in a Kubernetes cluster Crossplane creates an initial set of Custom Resource Definitions (CRDs) of the core Crossplane components.\nView the initial Crossplane CRDs After installing Crossplane use kubectl get crds to view the Crossplane installed CRDs.\n1kubectl get crds 2NAME 3compositeresourcedefinitions.apiextensions.crossplane.io 4compositionrevisions.apiextensions.crossplane.io 5compositions.apiextensions.crossplane.io 6configurationrevisions.pkg.crossplane.io 7configurations.pkg.crossplane.io 8controllerconfigs.pkg.crossplane.io 9locks.pkg.crossplane.io 10providerrevisions.pkg.crossplane.io 11providers.pkg.crossplane.io 12storeconfigs.secrets.crossplane.io The following sections describe the functions of some of these CRDs.\nProviders A Crossplane Provider creates a second set of CRDs that define how Crossplane connects to a non-Kubernetes service. Each external service relies on its own Provider. For example, AWS, Azure and GCP are different providers for each cloud service.\nTip Most Providers are for cloud services but Crossplane can use a Provider to connect to any service with an API. For example, an AWS Provider defines Kubernetes CRDs for AWS resources like EC2 compute instances or S3 storage buckets.\nThe Provider defines the Kubernetes API definition for the external resource. For example, the Upbound Provider AWS defines a bucket resource for creating and managing AWS S3 storage buckets.\nIn the bucket CRD is a spec.forProvider.region value that defines which AWS region to deploy the bucket in.\nThe Upbound Marketplace contains a large collection of Crossplane Providers.\nMore providers are available in the Crossplane Contrib repository.\nProviders are cluster scoped and available to all cluster namespaces.\nView all installed Providers with the command kubectl get providers.\nProvider configurations Providers have ProviderConfigs. ProviderConfigs configure settings related to the Provider like authentication or global defaults for the Provider.\nThe API endpoints for ProviderConfigs are unique to each Provider.\nProviderConfigs are cluster scoped and available to all cluster namespaces.\nView all installed ProviderConfigs with the command kubectl get providerconfig.\nManaged resources A Provider\u0026rsquo;s CRDs map to individual resources inside the provider. When Crossplane creates and monitors a resource it\u0026rsquo;s a Managed Resource.\nUsing a Provider\u0026rsquo;s CRD creates a unique Managed Resource. For example, using the Provider AWS\u0026rsquo;s bucket CRD, Crossplane creates a bucket Managed Resource inside the Kubernetes cluster that\u0026rsquo;s connected to an AWS S3 storage bucket.\nThe Crossplane controller provides state enforcement for Managed Resources. Crossplane enforces the settings and existence of Managed Resources. This \u0026ldquo;Controller Pattern\u0026rdquo; is like how the Kubernetes kube-controller-manager enforces state for pods.\nManaged Resources are cluster scoped and available to all cluster namespaces.\nUse kubectl get managed to view all managed resources. Warning The kubectl get managed creates a lot of Kubernetes API queries. Both the kubectl client and kube-apiserver throttle the API queries.\nDepending on the size of the API server and number of managed resources, this command may take minutes to return or may timeout.\nFor more information, read Kubernetes issue #111880 and Crossplane issue #3459.\nCompositions A Composition is a template for a collection of managed resource. Compositions allow platform teams to define a set of managed resources as a single object.\nFor example, a compute managed resource may require the creation of a storage resource and a virtual network as well. A single Composition can define all three resources in a single Composition object.\nUsing Compositions simplifies the deployment of infrastructure made up of multiple managed resources. Compositions also enforce standards and settings across deployments.\nPlatform teams can define fixed or default settings for each managed resource inside a Composition or define fields and settings that users may change.\nUsing the previous example, the platform team may set a compute resource size and virtual network settings. But the platform team allows users to define the storage resource size.\nCreating a Composition Crossplane doesn\u0026rsquo;t create any managed resources. The Composition is only a template for a collection of managed resources and their settings. A Composite Resource creates the specific resources.\nNote The Composite Resources section discusses Composite Resources. Compositions are cluster scoped and available to all cluster namespaces.\nUse kubectl get compositions to view all compositions.\nComposite Resources A Composite Resource (XR) is a set of provisioned managed resources. A Composite Resource uses the template defined by a Composition and applies any user defined settings.\nMultiple unique Composite Resource objects can use the same Composition. For example, a Composition template can create a compute, storage and networking set of managed resources. Crossplane uses the same Composition template every time a user requests this set of resources.\nIf a Composition allows a user to define resource settings, users apply them in a Composite Resource.\nTip Compositions are templates for a set of managed resources.\nComposite Resources fill out the template and create managed resources.\nDeleting a Composite Resource deletes all the managed resources it created.\nComposite Resources are cluster scoped and available to all cluster namespaces.\nUse kubectl get composite to view all Composite Resources.\nComposite Resource Definitions Composite Resource Definitions (XRDs) create custom Kubernetes APIs used by Claims and Composite Resources.\nNote The Claims section discusses Claims. Platform teams define the custom APIs.\nThese APIs can define specific values like storage space in gigabytes, generic settings like small or large, deployment options like cloud or onprem. Crossplane doesn\u0026rsquo;t limit the API definitions.\nThe Composite Resource Definition\u0026rsquo;s kind is from Crossplane.\n1apiVersion: apiextensions.crossplane.io/v1 2kind: CompositeResourceDefinition The spec of a Composite Resource Definition creates the apiVersion, kind and spec of a Composite Resource.\nTip The Composite Resource Definition defines the parameters for a Composite Resource. A Composite Resource Definition has four main spec parameters:\nA group to define the apiVersion in a Composite Resource . The versions.name that defines the version used in a Composite Resource. A names.kind to define the Composite Resource kind. A versions.schema section to define the Composite Resource spec. 1# Composite Resource Definition (XRD) 2spec: 3 group: test.example.org 4 names: 5 kind: myComputeResource 6 versions: 7 - name: v1alpha1 8 schema: 9 # Removed for brevity A Composite Resource based on this Composite Resource Definition looks like this:\n1# Composite Resource (XR) 2apiVersion: test.example.org/v1alpha1 3kind: myComputeResource 4metadata: 5 name: myResource 6spec: 7 storage: \u0026#34;large\u0026#34; A Composite Resource Definition schema defines the Composite Resource spec parameters.\nThese parameters are the new, custom APIs, that developers can use.\nFor example, creating a compute managed resource requires knowledge of a cloud provider\u0026rsquo;s compute class names like AWS\u0026rsquo;s m6in.large or GCP\u0026rsquo;s e2-standard-2.\nA Composite Resource Definition can limit the choices to small or large. A Composite Resource uses those options and the Composition maps them to specific cloud provider settings.\nThe following Composite Resource Definition defines a storage parameter. The storage is a string and the OpenAPI oneOf requires the options to be either small or large.\n1# Composite Resource Definition (XRD) 2spec: 3 group: test.example.org 4 names: 5 kind: myComputeResource 6 versions: 7 - name: v1alpha1 8 served: true 9 referenceable: true 10 schema: 11 openAPIV3Schema: 12 type: object 13 properties: 14 spec: 15 type: object 16 properties: 17 storage: 18 type: string 19 oneOf: 20 - pattern: \u0026#39;^small$\u0026#39; 21 - pattern: \u0026#39;^large$\u0026#39; 22 required: 23 - storage A Composite Resource Definition can define a wide variety of settings and options.\nCreating a Composite Resource Definition enables the creation of Composite Resources but can also create a Claim.\nComposite Resource Definitions with a spec.claimNames allow developers to create Claims.\nFor example, the claimNames.kind allows the creation of Claims of kind: computeClaim.\n1# Composite Resource Definition (XRD) 2spec: 3 group: test.example.org 4 names: 5 kind: myComputeResource 6 claimNames: 7 kind: computeClaim 8 # Removed for brevity Claims Claims are the primary way developers interact with Crossplane.\nClaims access the custom APIs defined by the platform team in a Composite Resource Definition.\nClaims look like Composite Resources, but they\u0026rsquo;re namespace scoped, while Composite Resources are cluster scoped.\nNote Why does namespace scope matter?\nHaving namespace scoped Claims allows multiple teams, using unique namespaces, to create the same types of resources, independent of each other. The compute resources of team A are unique to the compute resources of team B.\nDirectly creating Composite Resources requires cluster-wide permissions, shared with all teams.\nClaims create the same set of resources, but on a namespace level.\nThe previous Composite Resource Definition allows the creation of Claims of the kind\ncomputeClaim.\nClaims use the same apiVersion defined in Composite Resource Definition and also used by Composite Resources.\n1# Composite Resource Definition (XRD) 2spec: 3 group: test.example.org 4 names: 5 kind: myComputeResource 6 claimNames: 7 kind: computeClaim 8 # Removed for brevity In an example Claim the apiVersion matches the group in the Composite Resource Definition.\nThe Claim kind matches the Composite Resource Definition claimNames.kind.\n1# Claim 2apiVersion: test.example.org/v1alpha1 3kind: computeClaim 4metadata: 5 name: myClaim 6 namespace: devGroup 7spec: 8 size: \u0026#34;large\u0026#34; A Claim can install in a namespace.\nThe Composite Resource Definition defines the spec options the same way it does for a Composite Resource spec.\nTip Composite Resources and Claims are similar.\nOnly Claims can be in a namespace.\nAlso the Composite Resource\u0026rsquo;s kind may be different than the Claim\u0026rsquo;s kind.\nThe Composite Resource Definition defines the kind values. 1# Composite Resource (XR) 2apiVersion: test.example.org/v1alpha1 3kind: myComputeResource 4metadata: 5 name: myResource 6spec: 7 storage: \u0026#34;large\u0026#34; Claims are namespace scoped.\nView all available Claims with the command kubectl get claim.\nNext steps Build your own Crossplane platform using one of the quickstart guides.\nAzure Quickstart AWS Quickstart GCP Quickstart ","title":"Crossplane Introduction","url":"/v1.14/getting-started/introduction/"},{"content":"Providers enable Crossplane to provision infrastructure on an external service. Providers create new Kubernetes APIs and map them to external APIs.\nProviders are responsible for all aspects of connecting to non-Kubernetes resources. This includes authentication, making external API calls and providing Kubernetes Controller logic for any external resources.\nExamples of providers include:\nProvider AWS Provider Azure Provider GCP Provider Kubernetes Tip Find more providers in the Upbound Marketplace. Providers define every external resource they can create in Kubernetes as a Kubernetes API endpoint.\nThese endpoints are Managed Resources.\nInstall a Provider Installing a provider creates new Kubernetes resources representing the Provider\u0026rsquo;s APIs. Installing a provider also creates a Provider pod that\u0026rsquo;s responsible for reconciling the Provider\u0026rsquo;s APIs into the Kubernetes cluster. Providers constantly watch the state of the desired managed resources and create any external resources that are missing.\nInstall a Provider with a Crossplane Provider object setting the spec.package value to the location of the provider package.\nFor example, to install the AWS Community Provider,\n1apiVersion: pkg.crossplane.io/v1 2kind: Provider 3metadata: 4 name: provider-aws 5spec: 6 package: xpkg.upbound.io/crossplane-contrib/provider-aws:v0.39.0 By default, the Provider pod installs in the same namespace as Crossplane (crossplane-system).\nNote Providers are part of the pkg.crossplane.io group.\nThe meta.pkg.crossplane.io group is for creating Provider packages.\nInstructions on building Providers are outside of the scope of this document.\nRead the Crossplane contributing Provider Development Guide for more information.\nFor information on the specification of Provider packages read the Crossplane Provider Package specification.\n1apiVersion: meta.pkg.crossplane.io/v1 2kind: Provider 3metadata: 4 name: provider-aws 5spec: 6# Removed for brevity Install with Helm Crossplane supports installing Providers during an initial Crossplane installation with the Crossplane Helm chart.\nUse the --set provider.packages argument with helm install.\nFor example, to install the AWS Community Provider,\n1helm install crossplane \\ 2crossplane-stable/crossplane \\ 3--namespace crossplane-system \\ 4--create-namespace \\ 5--set provider.packages=\u0026#39;{xpkg.upbound.io/crossplane-contrib/provider-aws:v0.39.0}\u0026#39; Install offline Crossplane installs packages from a local package cache. By default the Crossplane package cache is an emptyDir volume.\nConfigure Crossplane to use a PersistentVolumeClaim to use a storage location containing the Provider image. Read more about configuring the Crossplane Pod settings in the Crossplane install documentation.\nProvide the name of the Provider\u0026rsquo;s .xpkg file and set packagePullPolicy: Never.\nFor example, to install a locally stored version of Provider AWS set the package to the local filename and set the Provider\u0026rsquo;s packagePullPolicy: Never.\n1apiVersion: pkg.crossplane.io/v1 2kind: Provider 3metadata: 4 name: offline-provider-aws 5spec: 6 package: provider-aws 7 packagePullPolicy: Never Installation options Providers support multiple configuration options to change installation related settings.\nProvider pull policy Use a packagePullPolicy to define when Crossplane should download the Provider package to the local Crossplane package cache.\nThe packagePullPolicy options are:\nIfNotPresent - (default) Only download the package if it isn\u0026rsquo;t in the cache. Always - Check for new packages every minute and download any matching package that isn\u0026rsquo;t in the cache. Never - Never download the package. Packages are only installed from the local package cache. Tip The Crossplane packagePullPolicy works like the Kubernetes container image image pull policy.\nCrossplane supports the use of tags and package digest hashes like Kubernetes images.\nFor example, to Always download a given Provider package use the packagePullPolicy: Always configuration.\n1apiVersion: pkg.crossplane.io/v1 2kind: Provider 3metadata: 4 name: provider-aws 5spec: 6 packagePullPolicy: Always 7# Removed for brevity Revision activation policy The Active package revision is the package controller actively reconciling resources.\nBy default Crossplane sets the most recently installed package revision as Active.\nControl the Provider upgrade behavior with a revisionActivationPolicy.\nThe revisionActivationPolicy options are:\nAutomatic - (default) Automatically activate the last installed Provider. Manual - Don\u0026rsquo;t automatically activate a Provider. For example, to change the upgrade behavior to require manual upgrades, set revisionActivationPolicy: Manual.\n1apiVersion: pkg.crossplane.io/v1 2kind: Provider 3metadata: 4 name: provider-aws 5spec: 6 revisionActivationPolicy: Manual 7# Removed for brevity Package revision history limit When Crossplane installs a different version of the same Provider package Crossplane creates a new revision.\nBy default Crossplane maintains one Inactive revision.\nNote Read the Provider upgrade section for more information on the use of package revisions. Change the number of revisions Crossplane maintains with a Provider Package revisionHistoryLimit.\nThe revisionHistoryLimit field is an integer.\nThe default value is 1.\nDisable storing revisions by setting revisionHistoryLimit to 0.\nFor example, to change the default setting and store 10 revisions use revisionHistoryLimit: 10.\n1apiVersion: pkg.crossplane.io/v1 2kind: Provider 3metadata: 4 name: provider-aws 5spec: 6 revisionHistoryLimit: 10 7# Removed for brevity Install a provider from a private registry Like Kubernetes uses imagePullSecrets to install images from private registries, Crossplane uses packagePullSecrets to install Provider packages from a private registry.\nUse packagePullSecrets to provide a Kubernetes secret to use for authentication when downloading a Provider package.\nImportant The Kubernetes secret must be in the same namespace as Crossplane. The packagePullSecrets is a list of secrets.\nFor example, to use the secret named example-secret configure a packagePullSecrets.\n1apiVersion: pkg.crossplane.io/v1 2kind: Provider 3metadata: 4 name: provider-aws 5spec: 6 packagePullSecrets: 7 - name: example-secret 8# Removed for brevity Note Configured packagePullSecrets aren\u0026rsquo;t passed to any Provider package dependencies. Ignore dependencies By default Crossplane installs any dependencies listed in a Provider package.\nCrossplane can ignore a Provider package\u0026rsquo;s dependencies with skipDependencyResolution.\nFor example, to disable dependency resolution configure skipDependencyResolution: true.\n1apiVersion: pkg.crossplane.io/v1 2kind: Provider 3metadata: 4 name: provider-aws 5spec: 6 skipDependencyResolution: true 7# Removed for brevity Ignore Crossplane version requirements A Provider package may require a specific or minimum Crossplane version before installing. By default, Crossplane doesn\u0026rsquo;t install a Provider if the Crossplane version doesn\u0026rsquo;t meet the required version.\nCrossplane can ignore the required version with ignoreCrossplaneConstraints.\nFor example, to install a Provider package into an unsupported Crossplane version, configure ignoreCrossplaneConstraints: true.\n1apiVersion: pkg.crossplane.io/v1 2kind: Provider 3metadata: 4 name: provider-aws 5spec: 6 ignoreCrossplaneConstraints: true 7# Removed for brevity Manage dependencies Providers packages may include dependencies on other packages including Configurations or other Providers.\nIf Crossplane can\u0026rsquo;t meet the dependencies of a Provider package the Provider reports HEALTHY as False.\nFor example, this installation of the Upbound AWS reference platform is HEALTHY: False.\n1kubectl get providers 2NAME INSTALLED HEALTHY PACKAGE AGE 3provider-aws-s3 True False xpkg.upbound.io/upbound/provider-aws-s3:v0.41.0 12s To see more information on why the Provider isn\u0026rsquo;t HEALTHY use kubectl describe providerrevisions.\n1kubectl describe providerrevisions 2Name: provider-aws-s3-92206523fff4 3API Version: pkg.crossplane.io/v1 4Kind: ProviderRevision 5Spec: 6 Desired State: Active 7 Image: xpkg.upbound.io/upbound/provider-aws-s3:v0.41.0 8 Revision: 1 9Status: 10 Conditions: 11 Last Transition Time: 2023-10-10T21:06:39Z 12 Reason: UnhealthyPackageRevision 13 Status: False 14 Type: Healthy 15 Controller Ref: 16 Name: 17Events: 18 Type Reason Age From Message 19 ---- ------ ---- ---- ------- 20 Warning LintPackage 41s (x3 over 47s) packages/providerrevision.pkg.crossplane.io incompatible Crossplane version: package is not compatible with Crossplane version (v1.10.0) The Events show a Warning with a message that the current version of Crossplane doesn\u0026rsquo;t meet the Configuration package requirements.\nUpgrade a Provider To upgrade an existing Provider edit the installed Provider Package by either applying a new Provider manifest or with kubectl edit providers.\nUpdate the version number in the Provider\u0026rsquo;s spec.package and apply the change. Crossplane installs the new image and creates a new ProviderRevision.\nThe ProviderRevision allows Crossplane to store deprecated Provider CRDs without removing them until you decide.\nView the ProviderRevisions with kubectl get providerrevisions\n1kubectl get providerrevisions 2NAME HEALTHY REVISION IMAGE STATE DEP-FOUND DEP-INSTALLED AGE 3provider-aws-s3-dbc7f981d81f True 1 xpkg.upbound.io/upbound/provider-aws-s3:v0.37.0 Active 1 1 10d 4provider-nop-552a394a8acc True 2 xpkg.upbound.io/crossplane-contrib/provider-nop:v0.3.0 Active 11d 5provider-nop-7e62d2a1a709 True 1 xpkg.upbound.io/crossplane-contrib/provider-nop:v0.2.0 Inactive 13d 6upbound-provider-family-aws-710d8cfe9f53 True 1 xpkg.upbound.io/upbound/provider-family-aws:v0.40.0 Active 10d By default Crossplane keeps a single Inactive Provider.\nRead the revision history limit section to change the default value.\nOnly a single revision of a Provider is Active at a time.\nRemove a Provider Remove a Provider by deleting the Provider object with kubectl delete provider.\nWarning Removing a Provider without first removing the Provider\u0026rsquo;s managed resources may abandon the resources. The external resources aren\u0026rsquo;t deleted.\nIf you remove the Provider first, you must manually delete external resources through your cloud provider. Managed resources must be manually deleted by removing their finalizers.\nFor more information on deleting abandoned resources read the Crossplane troubleshooting guide.\nVerify a Provider Providers install their own APIs representing the managed resources they support. Providers may also create Deployments, Service Accounts or RBAC configuration.\nView the status of a Provider with\nkubectl get providers\nDuring the install a Provider report INSTALLED as True and HEALTHY as Unknown.\n1kubectl get providers 2NAME INSTALLED HEALTHY PACKAGE AGE 3crossplane-contrib-provider-aws True Unknown xpkg.upbound.io/crossplane-contrib/provider-aws:v0.39.0 63s After the Provider install completes and it\u0026rsquo;s ready for use the HEALTHY status reports True.\n1kubectl get providers 2NAME INSTALLED HEALTHY PACKAGE AGE 3crossplane-contrib-provider-aws True True xpkg.upbound.io/crossplane-contrib/provider-aws:v0.39.0 88s Important Some Providers install hundreds of Kubernetes Custom Resource Definitions (CRDs). This can create significant strain on undersized API Servers, impacting Provider install times.\nThe Crossplane community has more details on scaling CRDs.\nProvider conditions Crossplane uses a standard set of Conditions for Providers.\nView the conditions of a provider under their Status with kubectl describe provider.\n1kubectl describe provider 2Name: my-provider 3API Version: pkg.crossplane.io/v1 4Kind: Provider 5# Removed for brevity 6Status: 7 Conditions: 8 Reason: HealthyPackageRevision 9 Status: True 10 Type: Healthy 11 Reason: ActivePackageRevision 12 Status: True 13 Type: Installed 14# Removed for brevity Types Provider Conditions support two Types:\nType: Installed - the Provider package installed but isn\u0026rsquo;t ready for use. Type: Healthy - The Provider package is ready to use. Reasons Each Reason relates to a specific Type and Status. Crossplane uses the following Reasons for Provider Conditions.\nInactivePackageRevision Reason: InactivePackageRevision indicates the Provider Package is using an inactive Provider Package Revision.\n1Type: Installed 2Status: False 3Reason: InactivePackageRevision ActivePackageRevision The Provider Package is the current Package Revision, but Crossplane hasn\u0026rsquo;t finished installing the Package Revision yet.\nTip Providers stuck in this state are because of a problem with Package Revisions.\nUse kubectl describe providerrevisions for more details.\n1Type: Installed 2Status: True 3Reason: ActivePackageRevision HealthyPackageRevision The Provider is fully installed and ready to use.\nTip Reason: HealthyPackageRevision is the normal state of a working Provider. 1Type: Healthy 2Status: True 3Reason: HealthyPackageRevision UnhealthyPackageRevision There was an error installing the Provider Package Revision, preventing Crossplane from installing the Provider Package.\nTip Use kubectl describe providerrevisions for more details on why the Package Revision failed. 1Type: Healthy 2Status: False 3Reason: UnhealthyPackageRevision UnknownPackageRevisionHealth The status of the Provider Package Revision is Unknown. The Provider Package Revision may be installing or has an issue.\nTip Use kubectl describe providerrevisions for more details on why the Package Revision failed. 1Type: Healthy 2Status: Unknown 3Reason: UnknownPackageRevisionHealth Configure a Provider Providers have two different types of configurations:\nController configurations that change the settings of the Provider pod running inside the Kubernetes cluster. For example, setting a toleration on the Provider pod.\nProvider configurations that change settings used when communicating with an external provider. For example, cloud provider authentication.\nImportant Apply ControllerConfig objects to Providers.\nApply ProviderConfig objects to managed resources.\nController configuration Important The ControllerConfig type was deprecated in v1.11 and will be removed in a future release.\nDeploymentRuntimeConfig is the replacement for Controller configuration and is available in v1.14+.\nApplying a Crossplane ControllerConfig to a Provider changes the settings of the Provider\u0026rsquo;s pod. The Crossplane ControllerConfig schema defines the supported set of ControllerConfig settings.\nThe most common use case for ControllerConfigs are providing args to a Provider\u0026rsquo;s pod enabling optional services. For example, enabling external secret stores for a Provider.\nEach Provider determines their supported set of args.\nRuntime configuration Important DeploymentRuntimeConfigs is a beta feature.\nIt\u0026rsquo;s on by default, and you can disable it by passing --enable-deployment-runtime-configs=false to the Crossplane deployment.\nRuntime configuration is a generalized mechanism for configuring the runtime for Crossplane packages with a runtime, namely Providers and Functions. It replaces the deprecated ControllerConfig type and is available in v1.14+.\nWith its default configuration, Crossplane uses Kubernetes Deployments to deploy runtime for packages, more specifically, a controller for a Provider or a gRPC server for a Function. It\u0026rsquo;s possible to configure the runtime manifest by applying a DeploymentRuntimeConfig and referencing it in the Provider or Function object.\nNote Different from ControllerConfig, DeploymentRuntimeConfig embed the whole Kubernetes Deployment spec, which allows for more flexibility in configuring the runtime. Refer to the design document for more details. As an example, to enable the external secret stores alpha feature for a Provider by adding the --enable-external-secret-stores argument to the controller, one can apply the following:\n1apiVersion: pkg.crossplane.io/v1 2kind: Provider 3metadata: 4 name: provider-gcp-iam 5spec: 6 package: xpkg.upbound.io/upbound/provider-gcp-iam:v0.37.0 7 runtimeConfigRef: 8 name: enable-ess 9--- 10apiVersion: pkg.crossplane.io/v1beta1 11kind: DeploymentRuntimeConfig 12metadata: 13 name: enable-ess 14spec: 15 deploymentTemplate: 16 spec: 17 selector: {} 18 template: 19 spec: 20 containers: 21 - name: package-runtime 22 args: 23 - --enable-external-secret-stores Please note that the packages manager uses package-runtime as the name of the runtime container. When you use a different container name, the package manager introduces it as a sidecar container instead of modifying the package runtime container.\nThe package manager is opinionated about some fields to ensure\nthe runtime is working and overlay them on top of the values in the runtime configuration. For example, it defaults the replica count to 1 if not set and overrides the label selectors to make sure the Deployment and Service match. It also injects any necessary environment variables, ports as well as volumes and volume mounts.\nThe Provider or Functions\u0026rsquo;s spec.runtimeConfigRef.name field defaults to value default, which means Crossplane uses the default runtime configuration if not specified. Crossplane ensures there is always a default runtime\nconfiguration in the cluster, but won\u0026rsquo;t change it if it already exists. This\nallows users to customize the default runtime configuration to their needs.\nTip Since DeploymentRuntimeConfig uses the same schema as Kubernetes Deployment\nspec, you may need to pass empty values to bypass the schema validation. For example, if you just want to change the replicas field, you would need to pass the following:\n1apiVersion: pkg.crossplane.io/v1beta1 2kind: DeploymentRuntimeConfig 3metadata: 4 name: multi-replicas 5spec: 6 deploymentTemplate: 7 spec: 8 replicas: 2 9 selector: {} 10 template: {} Configuring runtime deployment spec Using the Deployment spec provided in the DeploymentRuntimeConfig as a base, the package manager builds the Deployment spec for the package runtime with the following rules:\nInjects the package runtime container as the first container in the containers array, with name package-runtime. If not provided, defaults with the following: spec.replicas as 1. Image pull policy as IfNotPresent. Pod Security Context as: 1runAsNonRoot: true 2runAsUser: 2000 3runAsGroup: 2000 Security Context for the runtime container as: 1allowPrivilegeEscalation: false 2privileged: false 3runAsGroup: 2000 4runAsNonRoot: true 5runAsUser: 2000 Applies the following: Sets metadata.namespace as Crossplane namespace. Sets metadata.ownerReferences such that the deployment owned by the package revision. Sets spec.selectors using generated labels. Sets spec.serviceAccount with the created Service Account. Adds pull secrets provided in the Package spec as image pull secrets, spec.packagePullSecrets. Sets the Image Pull Policy with the value provided in the Package spec, spec.packagePullPolicy. Adds necessary Ports to the runtime container. Adds necessary Environments to the runtime container. Mounts TLS secrets by adding necessary Volumes, Volume Mounts and Environments to the runtime container. Configuring metadata of runtime resources DeploymentRuntimeConfig also enables configuring the following metadata of Runtime resources, namely Deployment, ServiceAccount and Service:\nname labels annotations The following example shows how to configure the name of the ServiceAccount and the labels of the Deployment:\n1apiVersion: pkg.crossplane.io/v1beta1 2kind: DeploymentRuntimeConfig 3metadata: 4 name: my-runtime-config 5spec: 6 deploymentTemplate: 7 metadata: 8 labels: 9 my-label: my-value 10 serviceAccountTemplate: 11 metadata: 12 name: my-service-account Provider configuration The ProviderConfig determines settings the Provider uses communicating to the external provider. Each Provider determines available settings of their ProviderConfig.\nProvider authentication is usually configured with a ProviderConfig. For example, to use basic key-pair authentication with Provider AWS a ProviderConfig spec defines the credentials and that the Provider pod should look in the Kubernetes Secrets objects and use the key named aws-creds.\n1apiVersion: aws.crossplane.io/v1beta1 2kind: ProviderConfig 3metadata: 4 name: aws-provider 5spec: 6 credentials: 7 source: Secret 8 secretRef: 9 namespace: crossplane-system 10 name: aws-creds 11 key: creds Important Authentication configuration may be different across Providers.\nRead the documentation on a specific Provider for instructions on configuring authentication for that Provider.\nProviderConfig objects apply to individual Managed Resources. A single Provider can authenticate with multiple users or accounts through ProviderConfigs.\nEach account\u0026rsquo;s credentials tie to a unique ProviderConfig. When creating a managed resource, attach the desired ProviderConfig.\nFor example, two AWS ProviderConfigs, named user-keys and admin-keys use different Kubernetes secrets.\n1apiVersion: aws.crossplane.io/v1beta1 2kind: ProviderConfig 3metadata: 4 name: user-keys 5spec: 6 credentials: 7 source: Secret 8 secretRef: 9 namespace: crossplane-system 10 name: my-key 11 key: secret-key 1apiVersion: aws.crossplane.io/v1beta1 2kind: ProviderConfig 3metadata: 4 name: admin-keys 5spec: 6 credentials: 7 source: Secret 8 secretRef: 9 namespace: crossplane-system 10 name: admin-key 11 key: admin-secret-key Apply the ProviderConfig when creating a managed resource.\nThis creates an AWS Bucket resource using the user-keys ProviderConfig.\n1apiVersion: s3.aws.upbound.io/v1beta1 2kind: Bucket 3metadata: 4 name: user-bucket 5spec: 6 forProvider: 7 region: us-east-2 8 providerConfigRef: 9 name: user-keys This creates a second Bucket resource using the admin-keys ProviderConfig.\n1apiVersion: s3.aws.upbound.io/v1beta1 2kind: Bucket 3metadata: 4 name: user-bucket 5spec: 6 forProvider: 7 region: us-east-2 8 providerConfigRef: 9 name: admin-keys ","title":"Providers","url":"/v1.14/concepts/providers/"},{"content":"AWS wrote a guide covering disaster recovery with Crossplane. The guide covers using Crossplane to provision resources and Velero for Kubernetes backup and recovery.\nRead the guide on AWS.\n","title":"Disaster Recovery with Crossplane","url":"/knowledge-base/guides/disaster-recovery/"},{"content":"A managed resource (MR) represents an external service in a Provider. When users create a new managed resource, the Provider reacts by creating an external resource inside the Provider\u0026rsquo;s environment. Every external service managed by Crossplane maps to a managed resource.\nNote Crossplane calls the object inside Kubernetes a managed resource and the external object inside the Provider an external resource. Examples of managed resources include:\nAmazon AWS EC2 Instance Google Cloud GKE Cluster Microsoft Azure PostgreSQL Database Tip You can create individual managed resources, but Crossplane recommends using Compositions and Claims to create managed resources. Managed resource fields The Provider defines the group, kind and version of a managed resource. The Provider also define the available settings of a managed resource.\nGroup, kind and version Each managed resource is a unique API endpoint with their own group, kind and version.\nFor example the Upbound AWS Provider defines the Instance kind from the group ec2.aws.upbound.io\n1apiVersion: ec2.aws.upbound.io/v1beta1 2kind: Instance deletionPolicy A managed resource\u0026rsquo;s deletionPolicy tells the Provider what to do after deleting the managed resource. If the deletionPolicy is delete the Provider deletes the external resource as well. If the deletionPolicy is orphan the Provider deletes the managed resource but doesn\u0026rsquo;t delete the external resource.\nOptions deletionPolicy: Delete - Default - Delete the external resource when deleting the managed resource. deletionPolicy: Orphan - Leave the external resource when deleting the managed resource. Interaction with management policies The management policy takes precedence over the deletionPolicy when:\nThe related management policy alpha feature is enabled. The resource configures a management policy other than the default value. See the table below for more details.\nmanagementPolicies deletionPolicy result \u0026ldquo;*\u0026rdquo; (default) Delete (default) Delete \u0026ldquo;*\u0026rdquo; (default) Orphan Orphan contains \u0026ldquo;Delete\u0026rdquo; Delete (default) Delete contains \u0026ldquo;Delete\u0026rdquo; Orphan Delete doesn\u0026rsquo;t contain \u0026ldquo;Delete\u0026rdquo; Delete (default) Orphan doesn\u0026rsquo;t contain \u0026ldquo;Delete\u0026rdquo; Orphan Orphan forProvider The spec.forProvider of a managed resource maps to the parameters of the external resource.\nFor example, when creating an AWS EC2 instance, the Provider supports defining the AWS region and the VM size, called the instanceType.\nNote The Provider defines the settings and their valid values. Providers also define required and optional values in the forProvider definition.\nRefer to the documentation of your specific Provider for details.\n1apiVersion: ec2.aws.upbound.io/v1beta1 2kind: Instance 3# Removed for brevity 4spec: 5 forProvider: 6 region: us-west-1 7 instanceType: t2.micro Important Crossplane considers the forProvider field of a managed resource the \u0026ldquo;source of truth\u0026rdquo; for external resources. Crossplane overrides any changes made to an external resource outside of Crossplane. If a user makes a change inside a Provider\u0026rsquo;s web console, Crossplane reverts that change back to what\u0026rsquo;s configured in the forProvider setting. Referencing other resources Some fields in a managed resource may depend on values from other managed resources. For example a VM may need the name of a virtual network to use.\nManaged resources can reference other managed resources by external name, name reference or selector.\nMatching by external name When matching a resource by name Crossplane looks for the name of the external resource in the Provider.\nFor example, a AWS VPC object named my-test-vpc has the external name vpc-01353cfe93950a8ff.\n1kubectl get vpc 2NAME READY SYNCED EXTERNAL-NAME AGE 3my-test-vpc True True vpc-01353cfe93950a8ff 49m To match the VPC by name, use the external name. For example, creating a Subnet managed resource attached to this VPC.\n1apiVersion: ec2.aws.upbound.io/v1beta1 2kind: Subnet 3spec: 4 forProvider: 5 # Removed for brevity 6 vpcId: vpc-01353cfe93950a8ff Matching by name reference To match a resource based on the name of the managed resource and not the external resource name inside the Provider, use a nameRef.\nFor example, a AWS VPC object named my-test-vpc has the external name vpc-01353cfe93950a8ff.\n1kubectl get vpc 2NAME READY SYNCED EXTERNAL-NAME AGE 3my-test-vpc True True vpc-01353cfe93950a8ff 49m To match the VPC by name reference, use the managed resource name. For example, creating a Subnet managed resource attached to this VPC.\n1apiVersion: ec2.aws.upbound.io/v1beta1 2kind: Subnet 3spec: 4 forProvider: 5 # Removed for brevity 6 vpcIdRef: 7 name: my-test-vpc Matching by selector Matching by selector is the most flexible matching method.\nNote The Compositions section covers the matchControllerRef selector. Use matchLabels to match the labels applied to a resource. For example, this Subnet resource only matches VPC resources with the label my-label: label-value.\n1apiVersion: ec2.aws.upbound.io/v1beta1 2kind: Subnet 3spec: 4 forProvider: 5 # Removed for brevity 6 vpcIdSelector: 7 matchLabels: 8 my-label: label-value Immutable fields Some providers don\u0026rsquo;t support changing the fields of some managed resources after creation. For example, you can\u0026rsquo;t change the region of an Amazon AWS RDSInstance. These fields are immutable fields. Amazon requires you delete and recreate the resource.\nCrossplane allows you to edit the immutable field of a managed resource, but doesn\u0026rsquo;t apply the change. Crossplane never deletes a resource based on a forProvider change.\nNote Crossplane behaves differently than other tools like Terraform. Terraform deletes and recreates a resource to change an immutable field. Crossplane only deletes an external resource if their corresponding managed resource object is deleted from Kubernetes and the deletionPolicy is delete.\nLate initialization Crossplane treats the managed resource as the source of truth by default; it expects to have all values under spec.forProvider including the optional ones. If not provided, Crossplane populates the empty fields with the values assigned by the provider. For example, consider fields such as region and availabilityZone. You might specify only the region and let the cloud provider choose the availability zone. In this case, if the provider assigns an availability zone, Crossplane uses that value to populate the spec.forProvider.availabilityZone field.\nNote With managementPolicies, this behavior can be turned off by not including the LateInitialize policy in the managementPolicies list.\ninitProvider Important The managed resource initProvider option is a beta feature related to managementPolicies. The initProvider defines settings Crossplane applies only when creating a new managed resource.\nCrossplane ignores settings defined in the initProvider field that change after creation.\nNote Settings in forProvider are always enforced by Crossplane. Crossplane reverts any changes to a forProvider field in the external resource.\nSettings in initProvider aren\u0026rsquo;t enforced by Crossplane. Crossplane ignores any changes to a initProvider field in the external resource.\nUsing initProvider is useful for setting initial values that a Provider may automatically change, like an auto scaling group.\nFor example, creating a NodeGroup with an initial desiredSize.\nCrossplane doesn\u0026rsquo;t change the desiredSize setting back when an autoscaler scales the Node Group external resource.\nTip Crossplane recommends configuring managementPolicies without LateInitialize to avoid conflicts with initProvider settings. 1apiVersion: eks.aws.upbound.io/v1beta1 2kind: NodeGroup 3metadata: 4 name: sample-eks-ng 5spec: 6 managementPolicies: [\u0026#34;Observe\u0026#34;, \u0026#34;Create\u0026#34;, \u0026#34;Update\u0026#34;, \u0026#34;Delete\u0026#34;] 7 initProvider: 8 scalingConfig: 9 - desiredSize: 1 10 forProvider: 11 region: us-west-1 12 scalingConfig: 13 - maxSize: 4 14 minSize: 1 managementPolicies Note The managed resource managementPolicies option is a beta feature. Crossplane enables beta features by default.\nThe Provider determines support for management policies.\nRefer to the Provider\u0026rsquo;s documentation to see if the Provider supports management policies.\nCrossplane managementPolicies determine which actions Crossplane can take on a managed resource and its corresponding external resource.\nApply one or more managementPolicies to a managed resource to determine what permissions Crossplane has over the resource.\nFor example, give Crossplane permission to create and delete an external resource, but not make any changes, set the policies to [\"Create\", \"Delete\", \"Observe\"].\n1apiVersion: ec2.aws.upbound.io/v1beta1 2kind: Subnet 3spec: 4 managementPolicies: [\u0026#34;Create\u0026#34;, \u0026#34;Delete\u0026#34;, \u0026#34;Observe\u0026#34;] 5 forProvider: 6 # Removed for brevity The default policy grants Crossplane full control over the resources.\nDefining the managementPolicies field with an empty array pauses the resource.\nImportant The Provider determines support for management policies.\nRefer to the Provider\u0026rsquo;s documentation to see if the Provider supports management policies. Crossplane supports the following policies: Policy Description * Default policy. Crossplane has full control over a resource. Create If the external resource doesn\u0026rsquo;t exist, Crossplane creates it based on the managed resource settings. Delete Crossplane can delete the external resource when deleting the managed resource. LateInitialize Crossplane initializes some external resource settings not defined in the spec.forProvider of the managed resource. See the late initialization section for more details. Observe Crossplane only observes the resource and doesn\u0026rsquo;t make any changes. Used for observe only resources. Update Crossplane changes the external resource when changing the managed resource. The following is a list of common policy combinations: Create Delete LateInitialize Observe Update Description ✔️ ✔️ ✔️ ✔️ ✔️ Default policy. Crossplane has full control over the resource. ✔️ ✔️ ✔️ ✔️ After creation any changes made to the managed resource aren\u0026rsquo;t passed to the external resource. Useful for immutable external resources. ✔️ ✔️ ✔️ ✔️ Prevent Crossplane from managing any settings not defined in the managed resource. Useful for immutable fields in an external resource. ✔️ ✔️ ✔️ Crossplane doesn\u0026rsquo;t import any settings from the external resource and doesn\u0026rsquo;t push changes to the managed resource. Crossplane recreates the external resource if it\u0026rsquo;s deleted. ✔️ ✔️ ✔️ ✔️ Crossplane doesn\u0026rsquo;t delete the external resource when deleting the managed resource. ✔️ ✔️ ✔️ Crossplane doesn\u0026rsquo;t delete the external resource when deleting the managed resource. Crossplane doesn\u0026rsquo;t apply changes to the external resource after creation. ✔️ ✔️ ✔️ Crossplane doesn\u0026rsquo;t delete the external resource when deleting the managed resource. Crossplane doesn\u0026rsquo;t import any settings from the external resource. ✔️ ✔️ Crossplane creates the external resource but doesn\u0026rsquo;t apply any changes to the external resource or managed resource. Crossplane can\u0026rsquo;t delete the resource. ✔️ Crossplane only observes a resource. Used for observe only resources. No policy set. An alternative method for pausing a resource. providerConfigRef The providerConfigRef on a managed resource tells the Provider which ProviderConfig to use when creating the managed resource.\nUse a ProviderConfig to define the authentication method to use when communicating to the Provider.\nImportant If providerConfigRef isn\u0026rsquo;t applied, Providers use the ProviderConfig named default. For example, a managed resource references a ProviderConfig named user-keys.\nThis matches the name of a ProviderConfig.\n1apiVersion: ec2.aws.upbound.io/v1beta1 2kind: Instance 3spec: 4 forProvider: 5 # Removed for brevity 6 providerConfigRef: user-keys 1apiVersion: aws.crossplane.io/v1beta1 2kind: ProviderConfig 3metadata: 4 name: user-keys 5# Removed for brevity Tip Each managed resource can reference different ProviderConfigs. This allows different managed resources to authenticate with different credentials to the same Provider. providerRef Crossplane deprecated the providerRef field in crossplane-runtime v0.10.0. Managed resources using providerRefmust use providerConfigRef.\nwriteConnectionSecretToRef When a Provider creates a managed resource it may generate resource-specific details, like usernames, passwords or connection details like an IP address.\nCrossplane stores these details in a Kubernetes Secret object specified by the writeConnectionSecretToRef values.\nFor example, when creating an AWS RDS database instance with the Crossplane community AWS provider generates an endpoint, password, port and username data. The Provider saves these variables in the Kubernetes secret rds-secret, referenced by the writeConnectionSecretToRef field.\n1apiVersion: database.aws.crossplane.io/v1beta1 2kind: RDSInstance 3metadata: 4 name: my-rds-instance 5spec: 6 forProvider: 7 # Removed for brevity 8 writeConnectionSecretToRef: 9 name: rds-secret Viewing the Secret object shows the saved fields.\n1kubectl describe secret rds-secret 2Name: rds-secret 3# Removed for brevity 4Data 5==== 6port: 4 bytes 7username: 10 bytes 8endpoint: 54 bytes 9password: 27 bytes Important The Provider determines the data written to the Secret object. Refer to the specific Provider documentation for the generated Secret data. publishConnectionDetailsTo The publishConnectionDetailsTo field expands on writeConnectionSecretToRef supporting storing managed resource information as a Kubernetes Secret object or in an external secrets store like HashiCorp Vault.\nUsing publishConnectionDetailsTo requires enabling Crossplane External Secrets Stores (ESS). Enable ESS inside a Provider with a DeploymentRuntimeConfig and in Crossplane with the --enable-external-secret-stores argument.\nNote Not all Providers support publishConnectionDetailsTo. Check your Provider documentation for details. Publish secrets to Kubernetes To publish the data generated by a managed resource as a Kubernetes Secret object provide a publishConnectionDetailsTo.name\n1apiVersion: rds.aws.upbound.io/v1beta1 2kind: Instance 3spec: 4 forProvider: 5 # Removed for brevity 6 publishConnectionDetailsTo: 7 name: rds-kubernetes-secret Crossplane can apply labels and annotations to the Kubernetes secret as well using publishConnectionDetailsTo.metadata.\n1apiVersion: rds.aws.upbound.io/v1beta1 2kind: Instance 3spec: 4 forProvider: 5 # Removed for brevity 6 publishConnectionDetailsTo: 7 name: rds-kubernetes-secret 8 metadata: 9 labels: 10 label-tag: label-value 11 annotations: 12 annotation-tag: annotation-value Publish secrets to an external secrets store Publishing secrets data to an external secret store like HashiCorp Vault relies on a publishConnectionDetailsTo.configRef.\nThe configRef.name references a StoreConfig object.\n1apiVersion: rds.aws.upbound.io/v1beta1 2kind: Instance 3spec: 4 forProvider: 5 # Removed for brevity 6 publishConnectionDetailsTo: 7 name: rds-kubernetes-secret 8 configRef: 9 name: my-vault-storeconfig 1apiVersion: secrets.crossplane.io/v1alpha1 2kind: StoreConfig 3metadata: 4 name: my-vault-storeconfig 5# Removed for brevity Tip Read the Vault as an External Secrets Store guide for details on using StoreConfig objects. Annotations Crossplane applies a standard set of Kubernetes annotations to managed resources.\nAnnotation Definition crossplane.io/external-name The name of the managed resource inside the Provider. crossplane.io/external-create-pending The timestamp of when Crossplane began creating the managed resource. crossplane.io/external-create-succeeded The timestamp of when the Provider successfully created the managed resource. crossplane.io/external-create-failed The timestamp of when the Provider failed to create the managed resource. crossplane.io/paused Indicates Crossplane isn\u0026rsquo;t reconciling this resource. Read the Pause Annotation for more details. crossplane.io/composition-resource-name For managed resource created by a Composition, this is the Composition\u0026rsquo;s resources.name value. Naming external resources By default Providers give external resources the same name as the Kubernetes object.\nFor example, a managed resource named my-rds-instance has the name my-rds-instance as an external resource inside the Provider\u0026rsquo;s environment.\n1apiVersion: database.aws.crossplane.io/v1beta1 2kind: RDSInstance 3metadata: 4 name: my-rds-instance 1kubectl get rdsinstance 2NAME READY SYNCED EXTERNAL-NAME AGE 3my-rds-instance True True my-rds-instance 11m Managed resource created with a crossplane.io/external-name annotation already provided use the annotation value as the external resource name.\nFor example, the Provider creates managed resource named my-rds-instance but uses the name my-custom-name for the external resource inside AWS.\n1apiVersion: database.aws.crossplane.io/v1beta1 2kind: RDSInstance 3metadata: 4 name: my-rds-instance 5 annotations: 6 crossplane.io/external-name: my-custom-namee 1kubectl get rdsinstance 2NAME READY SYNCED EXTERNAL-NAME AGE 3my-rds-instance True True my-custom-name 11m Creation annotations Providers create new managed resources with the crossplane.io/external-create-pending annotation.\nThe Provider applies the crossplane.io/external-create-succeeded or crossplane.io/external-create-failed annotation after making the external API call and receiving a response.\nNote If a Provider restarts before creating the succeed or fail annotations the Provider can\u0026rsquo;t reconcile the manged resource.\nRead Crossplane issue #3037 for more details\nPaused Manually applying the crossplane.io/paused annotation causes the Provider to stop reconciling the managed resource.\nPausing a resource is useful when modifying Providers or preventing race-conditions when editing Kubernetes objects.\nApply a crossplane.io/paused: \"true\" annotation to a managed resource to pause reconciliation.\nNote Only the value \u0026quot;true\u0026quot; pauses reconciliation. 1apiVersion: ec2.aws.upbound.io/v1beta1 2kind: Instance 3metadata: 4 name: my-rds-instance 5 annotations: 6 crossplane.io/paused: \u0026#34;true\u0026#34; 7spec: 8 forProvider: 9 region: us-west-1 10 instanceType: t2.micro Remove the annotation to resume reconciliation.\nFinalizers Crossplane applies a Finalizer on managed resources to control their deletion.\nNote Kubernetes can\u0026rsquo;t delete objects with Finalizers. When Crossplane deletes a managed resource the Provider begins deleting the external resource, but the managed resource remains until the external resource is fully deleted.\nWhen the external resource is fully deleted Crossplane removes the Finalizer and deletes the managed resource object.\nConditions Crossplane has a standard set of Conditions for a managed resource. View the Conditions of a managed resource with kubectl describe \u0026lt;managed_resource\u0026gt;\nNote Providers may define their own custom Conditions. Available Reason: Available indicates the Provider created the managed resource and it\u0026rsquo;s ready for use.\n1Conditions: 2 Type: Ready 3 Status: True 4 Reason: Available Creating Reason: Creating indicates the Provider is attempting to create the managed resource.\n1Conditions: 2 Type: Ready 3 Status: False 4 Reason: Creating Deleting Reason: Deleting indicates the Provider is attempting to delete the managed resource.\n1Conditions: 2 Type: Ready 3 Status: False 4 Reason: Deleting ReconcilePaused Reason: ReconcilePaused indicates the managed resource has a Pause annotation\n1Conditions: 2 Type: Synced 3 Status: False 4 Reason: ReconcilePaused ReconcileError Reason: ReconcileError indicates Crossplane encountered an error while reconciling the managed resource. The Message: value of the Condition helps identify the Crossplane error.\n1Conditions: 2 Type: Synced 3 Status: False 4 Reason: ReconcileError ReconcileSuccess Reason: ReconcileSuccess indicates the Provider created and is monitoring the managed resource.\n1Conditions: 2 Type: Synced 3 Status: True 4 Reason: ReconcileSuccess Unavailable Reason: Unavailable indicates Crossplane expects the managed resource to be available, but the Provider reports the resource is unhealthy.\n1Conditions: 2 Type: Ready 3 Status: False 4 Reason: Unavailable Unknown Reason: Unknown indicates the Provider has an unexpected error with the managed resource. The conditions.message provides more information on what went wrong.\n1Conditions: 2 Type: Unknown 3 Status: False 4 Reason: Unknown Upjet Provider conditions Upjet, the open source tool to generate Crossplane Providers, also has a set of standard Conditions.\nAsyncOperation Some resources may take more than a minute to create. Upjet based providers can complete their Kubernetes command before creating the managed resource by using an asynchronous operation.\nFinished The Reason: Finished indicates the asynchronous operation completed successfully.\n1Conditions: 2 Type: AsyncOperation 3 Status: True 4 Reason: Finished Ongoing Reason: Ongoing indicates the managed resource operation is still in progress.\n1Conditions: 2 Type: AsyncOperation 3 Status: True 4 Reason: Ongoing LastAsyncOperation The Upjet Type: LastAsyncOperation captures the previous asynchronous operation status as either Success or a failure Reason.\nApplyFailure Reason: ApplyFailure indicates the Provider failed to apply a setting to the managed resource. The conditions.message provides more information on what went wrong.\n1Conditions: 2 Type: LastAsyncOperation 3 Status: False 4 Reason: ApplyFailure DestroyFailure Reason: DestroyFailure indicates the Provider failed to delete the managed resource. The conditions.message provides more information on what went wrong.\n1Conditions: 2 Type: LastAsyncOperation 3 Status: False 4 Reason: DestroyFailure Success Reason: Success indicates the Provider successfully created the managed resource asynchronously.\n1Conditions: 2 Type: LastAsyncOperation 3 Status: True 4 Reason: Success ","title":"Managed Resources","url":"/v1.14/concepts/managed-resources/"},{"content":"The v1.14.0 release is a quarterly Crossplane release.\nRead the Crossplane announcement blog.\n🎉 Highlights Composition functions promoted to v1beta1. A new Provider DeploymentRuntimeConfig to eventually replace the deprecated ControllerConfig. New Crossplane CLI for troubleshooting and package management. Support for ordered deletion with Usages. Alpha support for real time composition 🚨 Warnings and breaking changes Crossplane Helm images have moved from index.docker.io to xpkg.upbound.io. Images are still published to index.docker.io but is moving to only publish on xpkg.upbound.io in a future release. Changes to TLS certificates. Existing users of external secret stores need to manually update their TLS certificates. Read Crossplane issue #4565 for more information. Removed Vault support for External Secret Stores. Crossplane suggests using the ESS Plugins as a replacement. Removed the controllerConfigRef from the Configuration package and package revision APIs. The introduction of the new Crossplane CLI deprecates the existing kubectl crossplane plugin. The v1beta1 implementation of Composition Functions is incompatable with existing v1alpha1 functions. 💡 New features What\u0026rsquo;s new in v1.14.0\nCrossplane CLI Crossplane v1.14 introduces a rebuilt Crossplane CLI.\nThe Crossplane CLI provides features to help troubleshoot Crossplane resources, build and publish Crossplane packages and locally test composition functions.\nRead the CLI documentation for information on installing and the full set of supported features.\nReal time Compositions This release adds the alpha feature \u0026ldquo;real time compositions\u0026rdquo; to Crossplane.\nReal time compositions allow Kubernetes to immediately notify Crossplane of changes to composed resources. Crossplane doesn\u0026rsquo;t need to poll resources to determine their state.\nReal time compositions dramatically speed up the time Crossplane reacts to changes or failures of managed resources.\nThe real time compositions feature is an alpha feature and isn\u0026rsquo;t enabled by default.\nThe Crossplane pods documentation has more information about real time compositions.\nOrdered resource deletion Crossplane introduces a new usages type to prevent resources from deletion or to ensure deletion happens in the correct order.\nA Usages defines a dependency mapping between a resource and any dependencies. Crossplane can\u0026rsquo;t delete the parent resource until after deleting the child resource.\nA usage also allow Crossplane to prevent accidental deletion of a resource.\nThe usage feature is an alpha feature and isn\u0026rsquo;t enabled by default.\nThe Usages documentation provides information on enabling and configuring Usages.\n🏗️ Notable changes Composition functions v1.14 promotes composition functions to v1beta1 with a new, more scalable architecture for running functions.\nCrossplane v1.14 includes CLI tooling, templates, SDKs, and documentation for building functions.\nSeveral new functions available for the new architecture, including function patch and transform, function Go templating, and function cue.\nManagement policies enabled by default Managed resource \u0026ldquo;management policies\u0026rdquo; moved to beta and are now enabled by default.\nObject has been modified warnings Crossplane changed the behavior causing the event message\ncannot patch object: Operation cannot be fulfilled on compositenetworks.gcp.platformref.crossplane.io \u0026ldquo;test-network-d6xjh\u0026rdquo;: the object has been modified; please apply your changes to the latest version and try again`\nAdding extra objects during Crossplane install The Crossplane Helm chart now supports an extraObjects: [] array to install other Kubernetes objects during the Crossplane install.\nSupport for pausing other Crossplane objects The Crossplane annotation crossplane.io/paused is now supported in Claims, Composites, Configurations, Functions and Provider objects.\n","title":"v1.14.0","url":"/v1.14/release-notes/1.14.0/"},{"content":"Using connection details in Crossplane requires the following components:\nDefining the writeConnectionSecretToRef.name in a Claim. Defining the writeConnectionSecretsToNamespace value in the Composition. Define the writeConnectionSecretToRef name and namespace for each resource in the Composition. Define the list of secret keys produced by each composed resource with connectionDetails in the Composition. Optionally, define the connectionSecretKeys in a CompositeResourceDefinition. Note This guide discusses creating Kubernetes secrets.\nCrossplane also supports using external secret stores like HashiCorp Vault.\nRead the external secrets store guide for more information on using Crossplane with an external secret store.\nBackground When a Provider creates a managed resource, the resource may generate resource-specific details. These details can include usernames, passwords or connection details like an IP address.\nCrossplane refers to this information as the connection details or connection secrets.\nThe Provider defines what information to present as a connection detail from a managed resource.\nWhen a managed resource is part of a Composition, the Composition, Composite Resource Definition and optionally, the Claim define what details are visible and where they\u0026rsquo;re stored.\nNote All the following examples use the same set of Compositions, CompositeResourceDefinitions and Claims.\nAll examples rely on Upbound provider-aws-iam to create resources.\nReference Composition 1apiVersion: apiextensions.crossplane.io/v1 2kind: Composition 3metadata: 4 name: xsecrettest.example.org 5spec: 6 writeConnectionSecretsToNamespace: other-namespace 7 compositeTypeRef: 8 apiVersion: example.org/v1alpha1 9 kind: XSecretTest 10 resources: 11 - name: key 12 base: 13 apiVersion: iam.aws.upbound.io/v1beta1 14 kind: AccessKey 15 spec: 16 forProvider: 17 userSelector: 18 matchControllerRef: true 19 writeConnectionSecretToRef: 20 namespace: docs 21 name: key1 22 connectionDetails: 23 - fromConnectionSecretKey: username 24 - fromConnectionSecretKey: password 25 - fromConnectionSecretKey: attribute.secret 26 - fromConnectionSecretKey: attribute.ses_smtp_password_v4 27 patches: 28 - fromFieldPath: \u0026#34;metadata.uid\u0026#34; 29 toFieldPath: \u0026#34;spec.writeConnectionSecretToRef.name\u0026#34; 30 transforms: 31 - type: string 32 string: 33 fmt: \u0026#34;%s-secret1\u0026#34; 34 - name: user 35 base: 36 apiVersion: iam.aws.upbound.io/v1beta1 37 kind: User 38 spec: 39 forProvider: {} 40 - name: user2 41 base: 42 apiVersion: iam.aws.upbound.io/v1beta1 43 kind: User 44 metadata: 45 labels: 46 docs.crossplane.io: user 47 spec: 48 forProvider: {} 49 - name: key2 50 base: 51 apiVersion: iam.aws.upbound.io/v1beta1 52 kind: AccessKey 53 spec: 54 forProvider: 55 userSelector: 56 matchLabels: 57 docs.crossplane.io: user 58 writeConnectionSecretToRef: 59 namespace: docs 60 name: key2 61 connectionDetails: 62 - name: key2-user 63 fromConnectionSecretKey: username 64 - name: key2-password 65 fromConnectionSecretKey: password 66 - name: key2-secret 67 fromConnectionSecretKey: attribute.secret 68 - name: key2-smtp 69 fromConnectionSecretKey: attribute.ses_smtp_password_v4 70 patches: 71 - fromFieldPath: \u0026#34;metadata.uid\u0026#34; 72 toFieldPath: \u0026#34;spec.writeConnectionSecretToRef.name\u0026#34; 73 transforms: 74 - type: string 75 string: 76 fmt: \u0026#34;%s-secret2\u0026#34; Reference CompositeResourceDefinition 1apiVersion: apiextensions.crossplane.io/v1 2kind: CompositeResourceDefinition 3metadata: 4 name: xsecrettests.example.org 5spec: 6 group: example.org 7 connectionSecretKeys: 8 - username 9 - password 10 - attribute.secret 11 - attribute.ses_smtp_password_v4 12 - key2-user 13 - key2-pass 14 - key2-secret 15 - key2-smtp 16 names: 17 kind: XSecretTest 18 plural: xsecrettests 19 claimNames: 20 kind: SecretTest 21 plural: secrettests 22 versions: 23 - name: v1alpha1 24 served: true 25 referenceable: true 26 schema: 27 openAPIV3Schema: 28 type: object 29 properties: 30 spec: 31 type: object Reference Claim 1apiVersion: example.org/v1alpha1 2kind: SecretTest 3metadata: 4 name: test-secrets 5 namespace: default 6spec: 7 writeConnectionSecretToRef: 8 name: my-access-key-secret Connection secrets in a managed resource When a managed resource creates connection secrets, Crossplane can write the secrets to a Kubernetes secret or an external secret store.\nCreating an individual managed resource shows the connection secrets the resource creates.\nNote Read the managed resources documentation for more information on configuring resources and storing connection secrets for individual resources. For example, create an AccessKey resource and save the connection secrets in a Kubernetes secret named my-accesskey-secret in the default namespace.\n1apiVersion: iam.aws.upbound.io/v1beta1 2kind: AccessKey 3metadata: 4 name: test-accesskey 5spec: 6 forProvider: 7 userSelector: 8 matchLabels: 9 docs.crossplane.io: user 10 writeConnectionSecretToRef: 11 namespace: default 12 name: my-accesskey-secret View the Kubernetes secret to see the connection details from the managed resource.\nThis includes an attribute.secret, attribute.ses_smtp_password_v4, password and username\n1kubectl describe secret my-accesskey-secret 2Name: my-accesskey-secret 3Namespace: default 4Labels: \u0026lt;none\u0026gt; 5Annotations: \u0026lt;none\u0026gt; 6 7Type: connection.crossplane.io/v1alpha1 8 9Data 10==== 11attribute.secret: 40 bytes 12attribute.ses_smtp_password_v4: 44 bytes 13password: 40 bytes 14username: 20 bytes Compositions and CompositeResourceDefinitions require the exact names of the secrets generated by a resource.\nConnection secrets in Compositions Resources in a Composition that create connection details still create a secret object containing their connection details.\nCrossplane also generates another secret object for each composite resource, containing the secrets from all the defined resources.\nFor example, a Composition defines two AccessKey objects.\nEach AccessKey writes a connection secrets to the name inside the namespace defined by the resource writeConnectionSecretToRef.\nCrossplane also creates a secret object for the entire Composition saved in the namespace defined by writeConnectionSecretsToNamespace with a Crossplane generated name.\n1apiVersion: apiextensions.crossplane.io/v1 2kind: Composition 3spec: 4 writeConnectionSecretsToNamespace: other-namespace 5 resources: 6 - name: key1 7 base: 8 apiVersion: iam.aws.upbound.io/v1beta1 9 kind: AccessKey 10 spec: 11 forProvider: 12 # Removed for brevity 13 writeConnectionSecretToRef: 14 namespace: docs 15 name: key1-secret 16 - name: key2 17 base: 18 apiVersion: iam.aws.upbound.io/v1beta1 19 kind: AccessKey 20 spec: 21 forProvider: 22 # Removed for brevity 23 writeConnectionSecretToRef: 24 namespace: docs 25 name: key2-secret 26 # Removed for brevity After applying a Claim, view the Kubernetes secrets to see three secret objects created.\nThe secret key1-secret is from the resource key1, key2-secret is from the resource key2.\nCrossplane creates another secret in the namespace other-namespace with the secrets from resource in the Composition.\n1kubectl get secrets -A 2NAMESPACE NAME TYPE DATA AGE 3docs key1-secret connection.crossplane.io/v1alpha1 4 4s 4docs key2-secret connection.crossplane.io/v1alpha1 4 4s 5other-namespace 70975471-c44f-4f6d-bde6-6bbdc9de1eb8 connection.crossplane.io/v1alpha1 0 6s Although Crossplane creates a secret object, by default, Crossplane doesn\u0026rsquo;t add any data to the object.\n1kubectl describe secret 70975471-c44f-4f6d-bde6-6bbdc9de1eb8 -n other-namespace 2Name: 70975471-c44f-4f6d-bde6-6bbdc9de1eb8 3Namespace: other-namespace 4 5Type: connection.crossplane.io/v1alpha1 6 7Data 8==== The Composition must list the connection secrets to store for each resource.\nUse the connectionDetails object under each resource and define the secret keys the resource creates.\nWarning You can\u0026rsquo;t change the connectionDetails of a Composition.\nYou must delete and recreate the Composition to change the connectionDetails. 1apiVersion: apiextensions.crossplane.io/v1 2kind: Composition 3spec: 4 writeConnectionSecretsToNamespace: other-namespace 5 resources: 6 - name: key 7 base: 8 apiVersion: iam.aws.upbound.io/v1beta1 9 kind: AccessKey 10 spec: 11 forProvider: 12 # Removed for brevity 13 writeConnectionSecretToRef: 14 namespace: docs 15 name: key1 16 connectionDetails: 17 - fromConnectionSecretKey: username 18 - fromConnectionSecretKey: password 19 - fromConnectionSecretKey: attribute.secret 20 - fromConnectionSecretKey: attribute.ses_smtp_password_v4 21 # Removed for brevity After applying a Claim the composite resource secret object contains the list of keys listed in the connectionDetails.\n1kubectl describe secret -n other-namespace 2Name: b0dc71f8-2688-4ebc-818a-bbad6a2c4f9a 3Namespace: other-namespace 4 5Type: connection.crossplane.io/v1alpha1 6 7Data 8==== 9username: 20 bytes 10attribute.secret: 40 bytes 11attribute.ses_smtp_password_v4: 44 bytes 12password: 40 bytes Important If a key isn\u0026rsquo;t listed in the connectionDetails it isn\u0026rsquo;t stored in the secret object. Managing conflicting secret keys If resources produce conflicting keys, create a unique name with a connection details name.\n1apiVersion: apiextensions.crossplane.io/v1 2kind: Composition 3spec: 4 writeConnectionSecretsToNamespace: other-namespace 5 resources: 6 - name: key 7 base: 8 kind: AccessKey 9 spec: 10 # Removed for brevity 11 writeConnectionSecretToRef: 12 namespace: docs 13 name: key1 14 connectionDetails: 15 - fromConnectionSecretKey: username 16 - name: key2 17 base: 18 kind: AccessKey 19 spec: 20 # Removed for brevity 21 writeConnectionSecretToRef: 22 namespace: docs 23 name: key2 24 connectionDetails: 25 - name: key2-user 26 fromConnectionSecretKey: username The secret object contains both keys, username and key2-user\n1kubectl describe secret -n other-namespace 2Name: b0dc71f8-2688-4ebc-818a-bbad6a2c4f9a 3Namespace: other-namespace 4 5Type: connection.crossplane.io/v1alpha1 6 7Data 8==== 9username: 20 bytes 10key2-user: 20 bytes 11# Removed for brevity. Connection secrets in Composite Resource Definitions The CompositeResourceDefinition (XRD), can restrict which secrets keys are put in the combined secret and provided to a Claim.\nBy default an XRD writes all secret keys listed in the composed resource connectionDetails to the combined secret object.\nLimit the keys passed to the combined secret object and Claims with a connectionSecretKeys object.\nInside the connectionSecretKeys list the secret key names to create. Crossplane only adds the keys listed to the combined secret.\nWarning You can\u0026rsquo;t change the connectionSecretKeys of an XRD. You must delete and recreate the XRD to change the connectionSecretKeys. For example, an XRD may restrict the secrets to only the username, password and custom named key2-user keys.\n1kind: CompositeResourceDefinition 2spec: 3 # Removed for brevity. 4 connectionSecretKeys: 5 - username 6 - password 7 - key2-user The secret from an individual resource contains all the resources detailed in the Composition\u0026rsquo;s connectionDetails.\n1kubectl describe secret key1 -n docs 2Name: key1 3Namespace: docs 4 5Data 6==== 7password: 40 bytes 8username: 20 bytes 9attribute.secret: 40 bytes 10attribute.ses_smtp_password_v4: 44 bytes The Claim\u0026rsquo;s secret only contains the keys allowed by the XRD connectionSecretKeys fields.\n1kubectl describe secret my-access-key-secret 2Name: my-access-key-secret 3 4Data 5==== 6key2-user: 20 bytes 7password: 40 bytes 8username: 20 bytes Secret objects Compositions create a secret object for each resource and an extra secret containing all the secrets from all resources.\nCrossplane saves the resource secret objects in the location defined by the resource\u0026rsquo;s writeConnectionSecretToRef.\nCrossplane saves the combined secret with a Crossplane generated name in the namespace defined in the Composition\u0026rsquo;s writeConnectionSecretsToNamespace.\n1apiVersion: apiextensions.crossplane.io/v1 2kind: Composition 3spec: 4 writeConnectionSecretsToNamespace: other-namespace 5 resources: 6 - name: key 7 base: 8 kind: AccessKey 9 spec: 10 # Removed for brevity 11 writeConnectionSecretToRef: 12 namespace: docs 13 name: key1 14 connectionDetails: 15 - fromConnectionSecretKey: username 16 - name: key2 17 base: 18 kind: AccessKey 19 spec: 20 # Removed for brevity 21 writeConnectionSecretToRef: 22 namespace: docs 23 name: key2 24 connectionDetails: 25 - name: key2-user 26 fromConnectionSecretKey: username If a Claim uses a secret, it\u0026rsquo;s stored in the same namespace as the Claim with the name defined in the Claim\u0026rsquo;s writeConnectionSecretToRef.\n1apiVersion: example.org/v1alpha1 2kind: SecretTest 3metadata: 4 name: test-secrets 5 namespace: default 6spec: 7 writeConnectionSecretToRef: 8 name: my-access-key-secret After applying the Claim Crossplane creates the following secrets:\nThe Claim\u0026rsquo;s secret, my-access-key-secret in the Claim\u0026rsquo;s namespace. The first resource\u0026rsquo;s secret object, key1. The second resource\u0026rsquo;s secret object, key2. The composite resource secret object in the other-namespace defined by the Composition\u0026rsquo;s writeConnectionSecretsToNamespace. 1 kubectl get secret -A 2NAMESPACE NAME TYPE DATA AGE 3default my-access-key-secret connection.crossplane.io/v1alpha1 8 29m 4docs key1 connection.crossplane.io/v1alpha1 4 31m 5docs key2 connection.crossplane.io/v1alpha1 4 31m 6other-namespace b0dc71f8-2688-4ebc-818a-bbad6a2c4f9a connection.crossplane.io/v1alpha1 8 31m ","title":"Understanding Connection Details","url":"/knowledge-base/guides/connection-details/"},{"content":"Compositions are a template for creating multiple managed resources as a single object.\nA Composition composes individual managed resources together into a larger, reusable, solution.\nAn example Composition may combine a virtual machine, storage resources and networking policies. A Composition template links all these individual resources together.\nConfused about Compositions, XRDs, XRs and Claims? Crossplane has four core components that users commonly mix up:\nCompositions - This page. A template to define how to create resources. Composite Resource Definition (XRD) - A custom API specification. Composite Resource (XR) - Created by using the custom API defined in a Composite Resource Definition. XRs use the Composition template to create new managed resources. Claims (XRC) - Like a Composite Resource, but with namespace scoping. Creating Compositions Creating Compositions consists of:\nResource templates defining the resources to create. Enabling Composite Resources to use this Composition template. Optionally, Compositions also support:\nModifying and patching resource settings. Storing connection details and secrets generated by the managed resources. Using Composition Functions to template resources using custom programs. Creating a custom check of when a resource is ready to use. Resource templates The resources field of a Composition\u0026rsquo;s spec defines the set of things that a Composite Resource creates.\nNote Read more about Composite Resources in the Composite Resources page. For example, a Composition can define a template to create a virtual machine and an associated storage bucket at the same time.\nThe resources field lists the individual resources with a name.\nThis name identifies the resource inside the Composition and isn\u0026rsquo;t related to the external name used with the Provider.\nTemplate a managed resource The contents of the base are identical to creating a standalone managed resource.\nThis example uses Upbound\u0026rsquo;s Provider AWS to define a S3 storage Bucket and EC2 compute Instance.\nAfter defining the apiVersion and kind, define the spec.forProvider fields defining the settings of the resource.\n1apiVersion: apiextensions.crossplane.io/v1 2kind: Composition 3spec: 4 resources: 5 - name: StorageBucket 6 base: 7 apiVersion: s3.aws.upbound.io/v1beta1 8 kind: Bucket 9 spec: 10 forProvider: 11 region: \u0026#34;us-east-2\u0026#34; 12 - name: VM 13 base: 14 apiVersion: ec2.aws.upbound.io/v1beta1 15 kind: Instance 16 spec: 17 forProvider: 18 ami: ami-0d9858aa3c6322f73 19 instanceType: t2.micro 20 region: \u0026#34;us-east-2\u0026#34; When a Composite Resource uses this Composition template, the Composite Resource creates two new managed resources with all the provided spec.forProvider settings.\nThe spec supports any settings used in a managed resource including applying annotations and labels or using a specific providerConfigRef.\nNote Compositions allow applying a metadata.name to a resource\u0026rsquo;s spec but ignores it. The metadata.name field doesn\u0026rsquo;t influence the name of the managed resource in Crossplane or the external resource inside the Provider.\nUse the crossplane.io/external-name annotation on the resource to influence the external resource name.\nTemplate a ProviderConfig Compositions can define a ProviderConfig like it defines managed resources. Generating a ProviderConfig may be useful in providing unique credentials to each deployment.\n1apiVersion: apiextensions.crossplane.io/v1 2kind: Composition 3spec: 4 resources: 5 - name: my-aws-provider-config 6 base: 7 apiVersion: aws.upbound.io/v1beta1 8 kind: ProviderConfig 9 spec: 10 source: Secret 11 secretRef: 12 namespace: crossplane-system 13 name: aws-secret 14 key: creds Template another Composite Resource Compositions can use other Composite Resources to define more complicated templates.\nA common use case is a Composition that uses other Compositions. For example, creating a Composition to create a standard set of networking resources that other Compositions reference.\nNote Both Compositions must have corresponding XRDs. This example networking Composition defines the set of resources required to create a new AWS virtual network. This includes a VPC, InternetGateway and Subnet.\n1apiVersion: apiextensions.crossplane.io/v1 2kind: Composition 3spec: 4 resources: 5 - name: vpc-resource 6 base: 7 apiVersion: ec2.aws.upbound.io/v1beta1 8 kind: VPC 9 # Removed for Brevity 10 - name: gateway-resource 11 base: 12 apiVersion: ec2.aws.upbound.io/v1beta1 13 kind: InternetGateway 14 # Removed for Brevity 15 - name: subnet-resource 16 base: 17 apiVersion: ec2.aws.upbound.io/v1beta1 18 kind: Subnet 19 # Removed for Brevity 20 compositeTypeRef: 21 apiVersion: aws.platformref.upbound.io/v1alpha1 22 kind: XNetwork The compositeTypeRef gives this Composition an apiVersion and kind to reference in another Composition.\nNote The Enabling a Composite Resource section describes the compositeTypeRef field. A second Composition, defining other resources, in this example, an AWS Elastic Kubernetes Cluster, can reference the previous XNetwork\n1apiVersion: apiextensions.crossplane.io/v1 2kind: Composition 3spec: 4 resources: 5 - name: nested-network-composition 6 base: 7 apiVersion: aws.platformref.upbound.io/v1alpha1 8 kind: XNetwork 9 # Removed for brevity 10 - name: eks-cluster-resource 11 base: 12 apiVersion: eks.aws.upbound.io/v1beta1 13 kind: Cluster 14 # Removed for brevity When a Composite Resource creates all the managed resources from this Composition, the resources defined by the XNetwork get created along with the EKS cluster.\nNote This abbreviated example is from the Upbound AWS Reference Platform.\nView the complete Compositions in the reference platform\u0026rsquo;s package directory.\nCross-resource references Inside a Composition some resources use identifiers or names of other resources. For example, creating a new network and applying the network identifier to a virtual machine.\nResources inside a Composition can cross-reference other resources by matching a label or a controller reference.\nNote Providers allow matching of labels and controller references on a per-resource basis. Check the documentation for the specific Provider resource to see what\u0026rsquo;s supported.\nMatching labels and controllers isn\u0026rsquo;t supported across different Providers.\nMatch resource labels To match a resource label, first apply a label to the resource to match and use matchLabels in the second resource.\nThis example creates a AWS Role and applies a label. The second resource is a RolePolicyAttachment, which requires attaching to an existing Role.\nUsing the resource\u0026rsquo;s roleSelector.matchLabels ensures this RolePolicyAttachment references the matching Role, even if the unique role identifier isn\u0026rsquo;t known.\n1apiVersion: apiextensions.crossplane.io/v1 2kind: Composition 3spec: 4 resources: 5 - base: 6 apiVersion: iam.aws.upbound.io/v1beta1 7 kind: Role 8 name: iamRole 9 metadata: 10 labels: 11 role: controlplane 12 - base: 13 apiVersion: iam.aws.upbound.io/v1beta1 14 kind: RolePolicyAttachment 15 name: iamPolicy 16 spec: 17 forProvider: 18 roleSelector: 19 matchLabels: 20 role: controlplane 21 # Removed for brevity Match a controller reference Matching a controller reference ensures that the matching resource is in the same composite resource.\nMatching only a controller reference simplifies the matching process without requiring labels or more information.\nFor example, creating an AWS InternetGateway requires a VPC.\nThe InternetGateway could match a label, but every VPC created by this Composition share the same label.\nUsing matchControllerRef matches only the VPC created in the same composite resource that created the InternetGateway.\n1apiVersion: apiextensions.crossplane.io/v1 2kind: Composition 3spec: 4 resources: 5 - base: 6 apiVersion: ec2.aws.upbound.io/v1beta1 7 kind: VPC 8 name: my-vpc 9 spec: 10 forProvider: 11 # Removed for brevity 12 - base: 13 apiVersion: ec2.aws.upbound.io/v1beta1 14 kind: InternetGateway 15 name: my-gateway 16 spec: 17 forProvider: 18 vpcIdSelector: 19 matchControllerRef: true 20# Removed for brevity Resources can match both labels and a controller reference to match a specific resource in the larger composite resource.\nFor example, this Composition creates two VPC resources, but the InternetGateway must match only one.\nApplying a label to the second VPC allows the InternetGateway to match the label type: internet and only match objects in the same composite resource with matchControllerRef.\n1apiVersion: apiextensions.crossplane.io/v1 2kind: Composition 3spec: 4 resources: 5 - base: 6 apiVersion: ec2.aws.upbound.io/v1beta1 7 kind: VPC 8 name: my-first-vpc 9 metadata: 10 labels: 11 type: backend 12 spec: 13 forProvider: 14 # Removed for brevity 15 - base: 16 apiVersion: ec2.aws.upbound.io/v1beta1 17 kind: VPC 18 name: my-second-vpc 19 metadata: 20 labels: 21 type: internet 22 spec: 23 forProvider: 24 # Removed for brevity 25 - base: 26 apiVersion: ec2.aws.upbound.io/v1beta1 27 kind: InternetGateway 28 name: my-gateway 29 spec: 30 forProvider: 31 vpcIdSelector: 32 matchControllerRef: true 33 matchLabels: 34 type: internet 35# Removed for brevity Enabling Composite Resources A Composition is only a template defining how to create managed resources. A Composition limits which Composite Resources can use this template.\nA Composition\u0026rsquo;s compositeTypeRef defines which Composite Resource type can use this Composition.\nNote Read more about Composite Resources in the Composite Resources page. Inside a Composition\u0026rsquo;s spec define the Composite Resource apiVersion and kind that the Composition allows to use this template.\n1apiVersion: apiextensions.crossplane.io/v1 2kind: Composition 3metadata: 4 name: dynamodb-with-bucket 5spec: 6 compositeTypeRef: 7 apiVersion: custom-api.example.org/v1alpha1 8 kind: database 9 # Removed for brevity Changing resource fields Most Compositions require customizing the fields of the resources. This can include applying unique passwords, modifying where to deploy resources, or applying labels or annotations.\nThe primary method to change resources is using a resource patch and transform. Patch and transforms allow matching specific input fields, modifying them and applying them to the managed resource.\nImportant The details of creating patch and transforms and their options are in the Patch and Transform page.\nThis section describes applying patches and transforms to Compositions.\nApply patches to individual resources with the patches field.\nFor example, taking the location provided in a Claim and applying it to the region value in the managed resource.\n1apiVersion: example.org/v1alpha1 2kind: ExampleClaim 3metadata: 4 name: my-example-claim 5spec: 6 location: \u0026#34;eu-north-1\u0026#34; The Composition patch uses the fromFieldPath to match the location field in the Claim and the toFieldPath to define which field to change inside the Composition.\n1apiVersion: apiextensions.crossplane.io/v1 2kind: Composition 3# Removed for Brevity 4spec: 5 resources: 6 - name: s3Bucket 7 base: 8 apiVersion: s3.aws.upbound.io/v1beta1 9 kind: Bucket 10 spec: 11 forProvider: 12 region: \u0026#34;us-east-2\u0026#34; 13 patches: 14 - type: FromCompositeFieldPath 15 fromFieldPath: \u0026#34;spec.location\u0026#34; 16 toFieldPath: \u0026#34;spec.forProvider.region\u0026#34; Patch sets Some Compositions have resources which need identical patches applied. Instead of repeating the same patches field, resources can reference a single patchSet.\nDefine a patchSet with a name and patch operations.\nThen apply the patchSet to each resource with type: patchSet, referencing the name in the patchSetName field.\n1apiVersion: apiextensions.crossplane.io/v1 2kind: Composition 3# Removed for Brevity 4spec: 5 patchSets: 6 - name: reusable-patch 7 patches: 8 - type: FromCompositeFieldPath 9 fromFieldPath: \u0026#34;location\u0026#34; 10 toFieldPath: \u0026#34;spec.forProvider.region\u0026#34; 11 resources: 12 - name: first-resource 13 base: 14 # Removed for Brevity 15 patches: 16 - type: PatchSet 17 patchSetName: reusable-patch 18 - name: second-resource 19 base: 20 # Removed for Brevity 21 patches: 22 - type: PatchSet 23 patchSetName: reusable-patch Patch with EnvironmentConfigs Crossplane uses EnvironmentConfigs to create in-memory data stores. Compositions can read and write from this data store as part of the patch process.\nImportant EnvironmentConfigs are an alpha feature. Alpha features aren\u0026rsquo;t enabled by default. EnvironmentConfigs can predefine data that Compositions can use or a Composite Resource can write data to their in-memory environment for other resources to read.\nNote Read the EnvironmentConfigs page for more information on using EnvironmentConfigs. To apply a patch using EnvironmentConfigs, first define which EnvironmentConfigs to use with environment.environmentConfigs.\nUse either a reference or a selector to identify the EnvironmentConfigs to use.\n1apiVersion: apiextensions.crossplane.io/v1 2kind: Composition 3# Removed for Brevity 4spec: 5 environment: 6 environmentConfigs: 7 - ref: 8 name: example-environment 9 resources: 10 # Removed for Brevity Patch a composite resource To patch between the composite resource and the in-memory environment use patches inside of the environment.\nUse the ToCompositeFieldPath to copy data from the in-memory environment to the composite resource.\nUse the FromCompositeFieldPath to copy data from the composite resource to the in-memory environment.\n1apiVersion: apiextensions.crossplane.io/v1 2kind: Composition 3# Removed for Brevity 4spec: 5 environment: 6 # Removed for Brevity 7 patches: 8 - type: ToCompositeFieldPath 9 fromFieldPath: tags 10 toFieldPath: metadata.labels[envTag] 11 - type: FromCompositeFieldPath 12 fromFieldPath: metadata.name 13 toFieldPath: newEnvironmentKey Individual resources can use any data written to their in-memory environment.\nPatch an individual resource To patch an individual resource, inside the patches of the resource, use ToEnvironmentFieldPath to copy data from the resource to the in-memory environment.\nUse FromEnvironmentFieldPath to copy data to the resource from the in-memory environment.\n1apiVersion: apiextensions.crossplane.io/v1 2kind: Composition 3# Removed for Brevity 4spec: 5 environment: 6 # Removed for Brevity 7 resources: 8 # Removed for Brevity 9 - name: vpc 10 base: 11 apiVersion: ec2.aws.upbound.io/v1beta1 12 kind: VPC 13 spec: 14 forProvider: 15 cidrBlock: 172.16.0.0/16 16 patches: 17 - type: ToEnvironmentFieldPath 18 fromFieldPath: status.atProvider.id 19 toFieldPath: vpcId 20 - type: FromEnvironmentFieldPath 21 fromFieldPath: tags 22 toFieldPath: spec.forProvider.tags The EnvironmentConfigs page has more information on EnvironmentConfigs options and usage.\nUse composition functions Composition functions (or just functions, for short) are custom programs that template Crossplane resources. You can write a function to template resources using a general purpose programming language like Go or Python. Using a general purpose programming language allows a function to use more advanced logic to template resources, like loops and conditionals.\nImportant Composition functions is a beta feature. Crossplane enables beta functions by default. The Composition Functions page explains how to disable composition functions. To use composition functions set the Composition mode to Pipeline.\nDefine a pipeline of steps. Each step calls a Function.\nEach step uses a functionRef to reference the name of the Function to call.\nSome Functions also allow you to specify an input.\nThe function defines the kind of input.\nImportant Compositions using mode: Pipeline can\u0026rsquo;t specify resource templates with a resources field.\nUse function \u0026ldquo;Patch and Transform\u0026rdquo; to create resource templates.\nThis example uses Function Patch and Transform. Function Patch and Transform is a function that implements Crossplane resource templates. You can use Function Patch and Transform to specify resource templates in a pipeline with other Functions.\n1apiVersion: apiextensions.crossplane.io/v1 2kind: Composition 3# Removed for Brevity 4spec: 5 # Removed for Brevity 6 mode: Pipeline 7 pipeline: 8 - step: patch-and-transform 9 functionRef: 10 name: function-patch-and-transform 11 input: 12 apiVersion: pt.fn.crossplane.io/v1beta1 13 kind: Resources 14 resources: 15 - name: storage-bucket 16 base: 17 apiVersion: s3.aws.upbound.io/v1beta1 18 kind: Bucket 19 spec: 20 forProvider: 21 region: \u0026#34;us-east-2\u0026#34; Read the composition functions page for details on building and using composition functions.\nStoring connection details Some managed resources generate unique details like usernames, passwords, IP addresses, ports or other connection details.\nWhen resources inside a Composition create connection details Crossplane creates a Kubernetes secret object for each managed resource generating connection details.\nNote This section discusses creating Kubernetes secrets.\nCrossplane also supports using external secret stores like HashiCorp Vault.\nRead the external secrets store guide for more information on using Crossplane with an external secret store.\nComposite resource combined secret Crossplane can combine all the secrets generated by the resources inside a Composition into a single Kubernetes secret and optionally copy the secret object for Claims.\nSet the value of writeConnectionSecretsToNamespace to the namespace where Crossplane should store the combined secret object.\n1apiVersion: apiextensions.crossplane.io/v1 2kind: Composition 3# Removed for Brevity 4spec: 5 writeConnectionSecretsToNamespace: my-namespace 6 resources: 7 # Removed for brevity Composed resource secrets Inside the spec of each resource producing connection details, define the writeConnectionSecretToRef, with a namespace and name of the secret object for the resource.\nIf a writeConnectionSecretToRef isn\u0026rsquo;t defined, Crossplane doesn\u0026rsquo;t write any keys to the secret.\n1apiVersion: apiextensions.crossplane.io/v1 2kind: Composition 3spec: 4 writeConnectionSecretsToNamespace: other-namespace 5 resources: 6 - name: key 7 base: 8 apiVersion: iam.aws.upbound.io/v1beta1 9 kind: AccessKey 10 spec: 11 forProvider: 12 # Removed for brevity 13 writeConnectionSecretToRef: 14 namespace: docs 15 name: key1 Crossplane saves a secret with the name in the namespace provided.\n1kubectl get secrets -n docs 2NAME TYPE DATA AGE 3key1 connection.crossplane.io/v1alpha1 4 4m30s Tip Crossplane recommends using a Patch to create a unique name for each secret.\nFor example, a patch to add the unique identifier of the resource as the key name.\n1apiVersion: apiextensions.crossplane.io/v1 2kind: Composition 3spec: 4 # Removed for brevity 5 resources: 6 - name: key 7 base: 8 apiVersion: iam.aws.upbound.io/v1beta1 9 kind: AccessKey 10 spec: 11 # Removed for brevity 12 writeConnectionSecretToRef: 13 namespace: docs 14 name: key1 15 patches: 16 - fromFieldPath: \u0026#34;metadata.uid\u0026#34; 17 toFieldPath: \u0026#34;spec.writeConnectionSecretToRef.name\u0026#34; 18 transforms: 19 - type: string 20 string: 21 fmt: \u0026#34;%s-secret\u0026#34; Define secret keys A Composition must define the specific secret keys a resource creates with the connectionDetails object.\nSecret Type Description fromConnectionSecretKey Create a secret key matching the key of a secret generated by the resource. fromFieldPath Create a secret key matching a field path of the resource. value Create a secret key with a predefined value. Note The value type must use a string value.\nThe value isn\u0026rsquo;t added to the individual resource secret object. The value only appears in the combined composite resource secret.\n1kind: Composition 2spec: 3 writeConnectionSecretsToNamespace: other-namespace 4 resources: 5 - name: key 6 base: 7 # Removed for brevity 8 spec: 9 forProvider: 10 # Removed for brevity 11 writeConnectionSecretToRef: 12 namespace: docs 13 name: key1 14 connectionDetails: 15 - name: myUsername 16 fromConnectionSecretKey: username 17 - name: myFieldSecret 18 fromFieldPath: spec.forProvider.user 19 - name: myStaticSecret 20 value: \u0026#34;docs.crossplane.io\u0026#34; The connectionDetails in a resource can reference a secret from a resource with fromConnectionSecretKey,\nfrom another field in the resource with fromFieldPath\nor a statically defined value with value.\nCrossplane sets the secret key to the name value.\nDescribe the secret to view the secret keys inside the secret object.\nTip If more than one resource generates secrets with the same secret key name, Crossplane only saves one value.\nUse a custom name to create unique secret keys.\nImportant Crossplane only adds connection details listed in the connectionDetails to the combined secret object.\nAny connection secrets in a managed resource, not defined in the connectionDetails aren\u0026rsquo;t added to the combined secret object. 1kubectl describe secret 2Name: my-access-key-secret 3Namespace: default 4Labels: \u0026lt;none\u0026gt; 5Annotations: \u0026lt;none\u0026gt; 6 7Type: connection.crossplane.io/v1alpha1 8 9Data 10==== 11myUsername: 20 bytes 12myFieldSecret: 24 bytes 13myStaticSecret: 18 bytes Note The CompositeResourceDefinition can also limit which keys Crossplane stores from the composite resources.\nBy default an XRD writes all secret keys listed in the composed resources connectionDetails to the combined secret object.\nRead the CompositeResourceDefinition documentation for more information on restricting secret keys.\nFor more information on connection secrets read the Connection Secrets knowledge base article.\nWarning You can\u0026rsquo;t change the connectionDetails of a Composition.\nYou must delete and recreate the Composition to change the connectionDetails . Save connection details to an external secret store Crossplane External Secret Stores write secrets and connection details to external secret stores like HashiCorp Vault.\nImportant External Secret Stores are an alpha feature.\nThey\u0026rsquo;re not recommended for production use. Crossplane disables External Secret Stores by default.\nUse publishConnectionDetailsWithStoreConfigRef in place of writeConnectionSecretsToNamespace to define the StoreConfig to save connection details to.\nFor example, using a StoreConfig with the name \u0026ldquo;vault,\u0026rdquo; use publishConnectionDetailsWithStoreConfigRef.name matching the StoreConfig.name, in this example, \u0026ldquo;vault.\u0026rdquo;\n1apiVersion: gcp.crossplane.io/v1alpha1 2kind: StoreConfig 3metadata: 4 name: vault 5# Removed for brevity. 6--- 7apiVersion: apiextensions.crossplane.io/v1 8kind: Composition 9# Removed for Brevity 10spec: 11 publishConnectionDetailsWithStoreConfigRef: 12 name: vault 13 resources: 14 # Removed for brevity For more details read the External Secret Stores integration guide.\nResource readiness checks By default Crossplane considers a Composite Resource or Claim as READY when the status of all created resource are Type: Ready and Status: True\nSome resources, for example, a ProviderConfig, don\u0026rsquo;t have a Kubernetes status and are never considered Ready.\nCustom readiness checks allow Compositions to define what custom conditions to meet for a resource to be Ready.\nTip Use multiple readiness checks if a resource must meet multiple conditions for it to be Ready. Define a custom readiness check with the readinessChecks field on a resource.\nChecks have a type defining how to match the resource and a fieldPath of which field in the resource to compare.\n1apiVersion: apiextensions.crossplane.io/v1 2kind: Composition 3# Removed for Brevity 4spec: 5 resources: 6 # Removed for Brevity 7 - name: my-resource 8 base: 9 # Removed for brevity 10 readinessChecks: 11 - type: \u0026lt;match type\u0026gt; 12 fieldPath: \u0026lt;resource field\u0026gt; Compositions support matching resource fields by:\nstring match integer match non-empty match always ready condition match boolean match Match a string MatchString considers the composed resource to be ready when the value of a field in that resource matches a specified string.\nNote Crossplane only supports exact string matches. Substrings and regular expressions aren\u0026rsquo;t supported in a readiness check.\nFor example, matching the string Online in the resource\u0026rsquo;s status.atProvider.state field.\n1apiVersion: apiextensions.crossplane.io/v1 2kind: Composition 3# Removed for Brevity 4spec: 5 resources: 6 # Removed for Brevity 7 - name: my-resource 8 base: 9 # Removed for brevity 10 readinessChecks: 11 - type: MatchString 12 fieldPath: status.atProvider.state 13 matchString: \u0026#34;Online\u0026#34; Match an integer MatchInteger considers the composed resource to be ready when the value of a field in that resource matches a specified integer.\nNote Crossplane doesn\u0026rsquo;t support matching 0.\nFor example, matching the number 4 in the resource\u0026rsquo;s status.atProvider.state field.\n1apiVersion: apiextensions.crossplane.io/v1 2kind: Composition 3# Removed for Brevity 4spec: 5 resources: 6 # Removed for Brevity 7 - name: my-resource 8 base: 9 # Removed for brevity 10 readinessChecks: 11 - type: MatchInteger 12 fieldPath: status.atProvider.state 13 matchInteger: 4 Match that a field exists NonEmpty considers the composed resource to be ready when a field exists with a value.\nNote Crossplane considers a value of 0 or an empty string as empty. For example, to check that a resource\u0026rsquo;s status.atProvider.state field isn\u0026rsquo;t empty.\n1apiVersion: apiextensions.crossplane.io/v1 2kind: Composition 3# Removed for Brevity 4spec: 5 resources: 6 # Removed for Brevity 7 - name: my-resource 8 base: 9 # Removed for brevity 10 readinessChecks: 11 - type: NonEmpty 12 fieldPath: status.atProvider.state Tip Checking NonEmpty doesn\u0026rsquo;t require setting any other fields. Always consider a resource ready None considers the composed resource to be ready as soon as it\u0026rsquo;s created. Crossplane doesn\u0026rsquo;t wait for any other conditions before declaring the resource ready.\nFor example, consider my-resource ready as soon as it\u0026rsquo;s created.\n1apiVersion: apiextensions.crossplane.io/v1 2kind: Composition 3# Removed for Brevity 4spec: 5 resources: 6 # Removed for Brevity 7 - name: my-resource 8 base: 9 # Removed for brevity 10 readinessChecks: 11 - type: None Match a condition Condition considers the composed resource to be ready when it finds the expected condition type, with the expected status for it in its status.conditions.\nFor example, consider my-resource, which is ready if there is a condition of type MyType with a status of Success.\n1apiVersion: apiextensions.crossplane.io/v1 2kind: Composition 3# Removed for Brevity 4spec: 5 resources: 6 # Removed for Brevity 7 - name: my-resource 8 base: 9 # Removed for brevity 10 readinessChecks: 11 - type: MatchCondition 12 matchCondition: 13 type: MyType 14 status: Success Match a boolean Two types of checks exist for matching boolean fields:\nMatchTrue MatchFalse MatchTrue considers the composed resource to be ready when the value of a field inside that resource is true.\nMatchFalse considers the composed resource to be ready when the value of a field inside that resource is false.\nFor example, consider my-resource, which is ready if status.atProvider.manifest.status.ready is true.\n1apiVersion: apiextensions.crossplane.io/v1 2kind: Composition 3# Removed for Brevity 4spec: 5 resources: 6 # Removed for Brevity 7 - name: my-resource 8 base: 9 # Removed for brevity 10 readinessChecks: 11 - type: MatchTrue 12 fieldPath: status.atProvider.manifest.status.ready Tip Checking MatchTrue doesn\u0026rsquo;t require setting any other fields. MatchFalse matches fields that express readiness with the value false.\nFor example, consider my-resource, is ready if status.atProvider.manifest.status.pending is false.\n1apiVersion: apiextensions.crossplane.io/v1 2kind: Composition 3# Removed for Brevity 4spec: 5 resources: 6 # Removed for Brevity 7 - name: my-resource 8 base: 9 # Removed for brevity 10 readinessChecks: 11 - type: MatchFalse 12 fieldPath: status.atProvider.manifest.status.pending Tip Checking MatchFalse doesn\u0026rsquo;t require setting any other fields. Verify a Composition View all available Compositions with kubectl get composition.\n1kubectl get composition 2NAME XR-KIND XR-APIVERSION AGE 3xapps.aws.platformref.upbound.io XApp aws.platformref.upbound.io/v1alpha1 123m 4xclusters.aws.platformref.upbound.io XCluster aws.platformref.upbound.io/v1alpha1 123m 5xeks.aws.platformref.upbound.io XEKS aws.platformref.upbound.io/v1alpha1 123m 6xnetworks.aws.platformref.upbound.io XNetwork aws.platformref.upbound.io/v1alpha1 123m 7xservices.aws.platformref.upbound.io XServices aws.platformref.upbound.io/v1alpha1 123m 8xsqlinstances.aws.platformref.upbound.io XSQLInstance aws.platformref.upbound.io/v1alpha1 123m The XR-KIND lists the Composite Resource kind that\u0026rsquo;s allowed to use the Composition template.\nThe XR-APIVERSION lists the Composite Resource API versions allowed to use the Composition template.\nNote The output of kubectl get composition is different than kubectl get composite.\nkubectl get composition lists all available Compositions.\nkubectl get composite lists all created Composite Resources and their related Composition.\nComposition validation When creating a Composition, Crossplane automatically validates its integrity, checking that the Composition is well formed, for example:\nIf using mode: Resources:\nThe resources field isn\u0026rsquo;t empty. All resources either use a name or don\u0026rsquo;t. Compositions can\u0026rsquo;t use both named and unnamed resources. No duplicate resource names. Patch sets must have names. Patches that require a fromFieldPath value provide it. Patches that require a toFieldPath value provide it. Patches that require a combine field provide it. Readiness checks using matchString aren\u0026rsquo;t empty. Readiness checks using matchInteger isn\u0026rsquo;t 0. Readiness checks requiring a fieldPath value provide it. If using mode: Pipeline (Composition Functions):\nThe pipeline field isn\u0026rsquo;t empty. No duplicate step names. Composition schema aware validation Crossplane also performs schema aware validation of Compositions. Schema validation checks that patches, readinessChecks and connectionDetails are valid according to the resource schemas. For example, checking that the source and destination fields of a patch are valid according to the source and destination resource schema.\nNote Composition schema aware validation is a beta feature. Crossplane enables beta features by default.\nDisable schema aware validation by setting the --enable-composition-webhook-schema-validation=false flag on the Crossplane pod.\nThe Crossplane Pods page has more information on enabling Crossplane flags.\nSchema aware validation modes Crossplane always rejects Compositions in case of integrity errors.\nSet the schema aware validation mode to configure how Crossplane handles both missing resource schemas and schema aware validation errors.\nNote If a resource schema is missing, Crossplane skips schema aware validation but still returns an error for integrity errors and a warning or an error for the missing schemas. The following modes are available:\nMode Missing Schema Schema Aware Error Integrity Error warn Warning Warning Error loose Warning Error Error strict Error Error Error Change the validation mode for a Composition with the crossplane.io/composition-schema-aware-validation-mode annotation.\nIf not specified, the default mode is warn.\nFor example, to enable loose mode checking set the annotation value to loose.\n1apiVersion: apiextensions.crossplane.io/v1 2kind: Composition 3metadata: 4 annotations: 5 crossplane.io/composition-schema-aware-validation-mode: loose 6 # Removed for brevity 7spec: 8 # Removed for brevity Important Validation modes also apply to Compositions defined by Configuration packages.\nDepending on the mode configured in the Composition, schema aware validation issues may result in warnings or the rejection of the Composition.\nView the Crossplane logs for validation warnings.\nCrossplane sets a Configuration as unhealthy if there are validation errors. View the Configuration details with kubectl describe configuration to see the specific errors.\n","title":"Compositions","url":"/v1.14/concepts/compositions/"},{"content":"Composite resource definitions (XRDs) define the schema for a custom API.\nUsers create composite resources (XRs) and Claims (XCs) using the API schema defined by an XRD.\nNote Read the composite resources page for more information about composite resources.\nRead the Claims page for more information about Claims.\nConfused about Compositions, XRDs, XRs and Claims? Crossplane has four core components that users commonly mix up:\nCompositions - A template to define how to create resources. Composite Resource Definition (XRD) - This page. A custom API specification. Composite Resource (XR) - Created by using the custom API defined in a Composite Resource Definition. XRs use the Composition template to create new managed resources. Claims (XRC) - Like a Composite Resource, but with namespace scoping. Crossplane XRDs are like Kubernetes custom resource definitions. XRDs require fewer fields and add options related to Crossplane, like Claims and connection secrets.\nCreating a CompositeResourceDefinition Creating a CompositeResourceDefinition consists of:\nDefining a custom API group. Defining a custom API name. Defining a custom API schema and version. Optionally, CompositeResourceDefinitions also support:\nOffering a Claim. Defining connection secrets. Setting composite resource defaults. Composite resource definitions (XRDs) create new API endpoints inside a Kubernetes cluster.\nCreating a new API requires defining an API group, name and version.\n1apiVersion: apiextensions.crossplane.io/v1 2kind: CompositeResourceDefinition 3metadata: 4 name: xmydatabases.example.org 5spec: 6 group: example.org 7 names: 8 kind: XMyDatabase 9 plural: xmydatabases 10 versions: 11 - name: v1alpha1 12 # Removed for brevity After applying an XRD, Crossplane creates a new Kubernetes custom resource definition matching the defined API.\nFor example, the XRD xmydatabases.example.org creates a custom resource definition xmydatabases.example.org.\n1kubectl api-resources 2NAME SHORTNAMES APIVERSION NAMESPACED KIND 3xmydatabases.example.org v1alpha1 false xmydatabases 4# Removed for brevity Warning You can\u0026rsquo;t change the XRD group or names.\nYou must delete and recreate the XRD to change the group or names. XRD groups Groups define a collection of related API endpoints. The group can be any value, but common convention is to map to a fully qualified domain name.\nMany XRDs may use the same group to create a logical collection of APIs.\nFor example a database group may have a relational and nosql kinds.\nTip Group names are cluster scoped. Choose group names that don\u0026rsquo;t conflict with Providers.\nAvoid Provider names in the group. XRD names The names field defines how to refer to this specific XRD.\nThe required name fields are:\nkind - the kind value to use when calling this API. The kind is UpperCamelCased. Crossplane recommends starting XRD kinds with an X to show it\u0026rsquo;s a custom Crossplane API definition. plural - the plural name used for the API URL. The plural name must be lowercase. Important The XRD metadata.name must be plural name, . (dot character), group.\nFor example, xmydatabases.example.org matches the plural name xmydatabases, . group name, example.org.\n1apiVersion: apiextensions.crossplane.io/v1 2kind: CompositeResourceDefinition 3metadata: 4 name: xmydatabases.example.org 5spec: 6 group: example.org 7 names: 8 kind: XMyDatabase 9 plural: xmydatabases 10 # Removed for brevity XRD versions The XRD version is like the API versioning used by Kubernetes. The version shows how mature or stable the API is and increments when changing, adding or removing fields in the API.\nCrossplane doesn\u0026rsquo;t require specific versions or a specific version naming convention, but following Kubernetes API versioning guidelines is strongly recommended.\nv1alpha1 - A new API that may change at any time. v1beta1 - An existing API that\u0026rsquo;s considered stable. Breaking changes are strongly discouraged. v1 - A stable API that doesn\u0026rsquo;t have breaking changes. Define a schema The schema defines the names of the parameters, the data types of the parameters and which parameters are required or optional.\nNote All schemas follow the Kubernetes custom resource definition OpenAPIv3 structural schema. Each version of the API has a unique schema.\nAll XRD schemas validate against the openAPIV3Schema. The schema is an OpenAPI object with the properties of a spec object.\nInside the spec.properties is the custom API definition.\nIn this example, the key region is a string.\n1apiVersion: apiextensions.crossplane.io/v1 2kind: CompositeResourceDefinition 3metadata: 4 name: xdatabases.custom-api.example.org 5spec: 6 group: custom-api.example.org 7 names: 8 kind: xDatabase 9 plural: xdatabases 10 versions: 11 - name: v1alpha1 12 schema: 13 openAPIV3Schema: 14 type: object 15 properties: 16 spec: 17 type: object 18 properties: 19 region: 20 type: string 21 # Removed for brevity A composite resource using this API references the group/version and kind. The spec has the region key with a string value.\n1apiVersion: custom-api.example.org/v1alpha1 2kind: xDatabase 3metadata: 4 name: my-composite-resource 5spec: 6 region: \u0026#34;US\u0026#34; Tip The custom API defined inside the spec.properties is an OpenAPIv3 specification. The data models page of the Swagger documentation provides a list of examples using data types and input restrictions.\nThe Kubernetes documentation lists the set of special restrictions on what your OpenAPIv3 custom API can use.\nImportant Changing or expanding the XRD schema requires restarting the Crossplane pod to take effect. Required fields By default all fields in a schema are optional. Define a parameter as required with the required attribute.\nIn this example the XRD requires region and size but name is optional.\n1apiVersion: apiextensions.crossplane.io/v1 2kind: CompositeResourceDefinition 3metadata: 4 name: xdatabases.custom-api.example.org 5spec: 6 group: custom-api.example.org 7 names: 8 kind: xDatabase 9 plural: xdatabases 10 versions: 11 - name: v1alpha1 12 schema: 13 openAPIV3Schema: 14 type: object 15 properties: 16 spec: 17 type: object 18 properties: 19 region: 20 type: string 21 size: 22 type: string 23 name: 24 type: string 25 required: 26 - region 27 - size 28 # Removed for brevity According to the OpenAPIv3 specification, the required field is per-object. If a schema contains multiple objects the schema may need multiple required fields.\nThis XRD defines two objects:\nthe top-level spec object a second location object The spec object requires the size and location but name is optional.\nInside the required location object, country is required and zone is optional.\n1# Removed for brevity 2- name: v1alpha1 3 schema: 4 openAPIV3Schema: 5 type: object 6 properties: 7 spec: 8 type: object 9 properties: 10 size: 11 type: string 12 name: 13 type: string 14 location: 15 type: object 16 properties: 17 country: 18 type: string 19 zone: 20 type: string 21 required: 22 - country 23 required: 24 - size 25 - location The Swagger \u0026ldquo;Describing Parameters\u0026rdquo; documentation has more examples.\nCrossplane reserved fields Crossplane doesn\u0026rsquo;t allow the following fields in a schema:\nspec.resourceRef spec.resourceRefs spec.claimRef spec.writeConnectionSecretToRef status.conditions status.connectionDetails Crossplane ignores any fields matching the reserved fields.\nServe and reference a schema To use a schema it must be served: true and referenceable: true.\n1apiVersion: apiextensions.crossplane.io/v1 2kind: CompositeResourceDefinition 3metadata: 4 name: xdatabases.custom-api.example.org 5spec: 6 group: custom-api.example.org 7 names: 8 kind: xDatabase 9 plural: xdatabases 10 versions: 11 - name: v1alpha1 12 served: true 13 referenceable: true 14 schema: 15 openAPIV3Schema: 16 type: object 17 properties: 18 spec: 19 type: object 20 properties: 21 region: 22 type: string Composite resources can use any schema version set as served: true.\nKubernetes rejects any composite resource using a schema version set as served: false.\nTip Setting a schema version as served:false causes errors for users using an older schema. This can be an effective way to identify and upgrade users before deleting the older schema version. The referenceable: true field indicates which version of the schema Compositions use. Only one version can be referenceable.\nNote Changing which version is referenceable:true requires updating the compositeTypeRef.apiVersion of any Compositions referencing that XRD. Multiple schema versions Warning Crossplane supports defining multiple versions, but the schema of each version can\u0026rsquo;t change any existing fields, also called \u0026ldquo;making a breaking change.\u0026rdquo;\nBreaking schema changes between versions requires the use of conversion webhooks.\nNew versions may define new optional parameters, but new required fields are a \u0026ldquo;breaking change.\u0026rdquo;\nCrossplane XRDs use Kubernetes custom resource definitions for versioning. Read the Kubernetes documentation on versions in CustomResourceDefinitions for more background on versions and breaking changes.\nCrossplane recommends implementing breaking schema changes as brand new XRDs.\nFor XRDs, to create a new version of an API add a new name in the versions list.\nFor example, this XRD version v1alpha1 only has the field region.\nA second version, v1 expands the API to have both region and size.\n1apiVersion: apiextensions.crossplane.io/v1 2kind: CompositeResourceDefinition 3metadata: 4 name: xdatabases.custom-api.example.org 5spec: 6 group: custom-api.example.org 7 names: 8 kind: xDatabase 9 plural: xdatabases 10 versions: 11 - name: v1alpha1 12 schema: 13 openAPIV3Schema: 14 type: object 15 properties: 16 spec: 17 type: object 18 properties: 19 region: 20 type: string 21 - name: v1 22 schema: 23 openAPIV3Schema: 24 type: object 25 properties: 26 spec: 27 type: object 28 properties: 29 region: 30 type: string 31 size: 32 type: string Important Changing or expanding the XRD schema requires restarting the Crossplane pod to take effect. Enable Claims Optionally, XRDs can allow Claims to use the XRD API.\nNote Read the Claims page for more information about Claims. XRDs offer Claims with a claimNames object.\nThe claimNames defines a kind and plural like the XRD names object.\nAlso like XRD names, use UpperCamelCase for the kind and lowercase for the plural.\nThe Claim kind and plural must be unique. They can\u0026rsquo;t match any other Claim or other XRD kind.\nTip Common Crossplane convention is to use claimNames that match the XRD names, but without the beginning \u0026ldquo;x.\u0026rdquo; 1apiVersion: apiextensions.crossplane.io/v1 2kind: CompositeResourceDefinition 3metadata: 4 name: xdatabases.custom-api.example.org 5spec: 6 group: custom-api.example.org 7 names: 8 kind: xDatabase 9 plural: xdatabases 10 claimNames: 11 kind: Database 12 plural: databases 13 versions: 14 # Removed for brevity Important You can\u0026rsquo;t change the claimNames after they\u0026rsquo;re defined. You must delete and recreate the XRD to change the claimNames. Manage connection secrets When a composite resource creates managed resources, Crossplane provides any connection secrets to the composite resource or Claim. This requires the creators of composite resources and Claims to know the secrets provided by a managed resource. In other cases, Crossplane administrators may not want to expose some or all the generated connection secrets.\nXRDs can define a list of connectionSecretKeys to limit what\u0026rsquo;s provided to a composite resource or Claim.\nCrossplane only provides the keys listed in the connectionSecretKeys to the composite resource or Claim using this XRD. Any other connection secrets aren\u0026rsquo;t passed to the composite resource or Claim.\nImportant The keys listed in the connectionSecretKeys must match the key names listed in the Composition\u0026rsquo;s connectionDetails.\nAn XRD ignores any keys listed that aren\u0026rsquo;t created by a managed resource.\nFor more information read the Composition documentation.\nFor example, an XRD passes the keys username, password and address.\nComposite resources or Claims save these in the secret defined by their writeConnectionSecretToRef field.\n1apiVersion: apiextensions.crossplane.io/v1 2kind: CompositeResourceDefinition 3metadata: 4 name: xdatabases.custom-api.example.org 5spec: 6 group: custom-api.example.org 7 names: 8 kind: xDatabase 9 plural: xdatabases 10 connectionSecretKeys: 11 - username 12 - password 13 - address 14 versions: 15 # Removed for brevity Warning You can\u0026rsquo;t change the connectionSecretKeys of an XRD. You must delete and recreate the XRD to change the connectionSecretKeys. For more information on connection secrets read the Connection Secrets knowledge base article.\nSet composite resource defaults XRDs can set default parameters for composite resources and Claims.\ndefaultCompositeDeletePolicy The defaultCompositeDeletePolicy defines the deletion policy for composite resources and claims.\nUsing a defaultCompositeDeletePolicy: Background policy deletes the composite resource or Claim and relies on Kubernetes to delete the remaining dependent objects, like managed resources or secrets.\nUsing defaultCompositeDeletePolicy: Foreground causes Kubernetes to attach a foregroundDeletion finalizer to the composite resource or Claim. Kubernetes deletes all the dependent objects before deleting the composite resource or Claim.\nThe default value is defaultCompositeDeletePolicy: Background.\nSet defaultCompositeDeletePolicy: Foreground to change the XRD deletion policy.\n1apiVersion: apiextensions.crossplane.io/v1 2kind: CompositeResourceDefinition 3metadata: 4 name: xdatabases.custom-api.example.org 5spec: 6 defaultCompositeDeletePolicy: Foreground 7 group: custom-api.example.org 8 names: 9 # Removed for brevity 10 versions: 11 # Removed for brevity defaultCompositionRef It\u0026rsquo;s possible for multiple Compositions to reference the same XRD. If more than one Composition references the same XRD, the composite resource or Claim must select which Composition to use.\nAn XRD can define the default Composition to use with the defaultCompositionRef value.\nSet a defaultCompositionRef to set the default Composition.\n1apiVersion: apiextensions.crossplane.io/v1 2kind: CompositeResourceDefinition 3metadata: 4 name: xdatabases.custom-api.example.org 5spec: 6 defaultCompositionRef: 7 name: myComposition 8 group: custom-api.example.org 9 names: 10 # Removed for brevity 11 versions: 12 # Removed for brevity defaultCompositionUpdatePolicy Changes to a Composition generate a new Composition revision. By default all composite resources and Claims use the updated Composition revision.\nSet the XRD defaultCompositionUpdatePolicy to Manual to prevent composite resources and Claims from automatically using the new revision.\nThe default value is defaultCompositionUpdatePolicy: Automatic.\nSet defaultCompositionUpdatePolicy: Manual to set the default Composition update policy for composite resources and Claims using this XRD.\n1apiVersion: apiextensions.crossplane.io/v1 2kind: CompositeResourceDefinition 3metadata: 4 name: xdatabases.custom-api.example.org 5spec: 6 defaultCompositionUpdatePolicy: Manual 7 group: custom-api.example.org 8 names: 9 # Removed for brevity 10 versions: 11 # Removed for brevity enforcedCompositionRef To require all composite resources or Claims to use a specific Composition use the enforcedCompositionRef setting in the XRD.\nFor example, to require all composite resources and Claims using this XRD to use the Composition myComposition set enforcedCompositionRef.name: myComposition.\n1apiVersion: apiextensions.crossplane.io/v1 2kind: CompositeResourceDefinition 3metadata: 4 name: xdatabases.custom-api.example.org 5spec: 6 enforcedCompositionRef: 7 name: myComposition 8 group: custom-api.example.org 9 names: 10 # Removed for brevity 11 versions: 12 # Removed for brevity Verify a CompositeResourceDefinition Verify an XRD with kubectl get compositeresourcedefinition or the short form, kubectl get xrd.\n1kubectl get xrd 2NAME ESTABLISHED OFFERED AGE 3xdatabases.custom-api.example.org True True 22m The ESTABLISHED field indicates Crossplane installed the Kubernetes custom resource definition for this XRD.\nThe OFFERED field indicates this XRD offers a Claim and Crossplane installed the Kubernetes custom resource definitions for the Claim.\nXRD conditions Crossplane uses a standard set of Conditions for XRDs.\nView the conditions of a XRD under their Status with kubectl describe xrd.\n1kubectl describe xrd 2Name: xpostgresqlinstances.database.starter.org 3API Version: apiextensions.crossplane.io/v1 4Kind: CompositeResourceDefinition 5# Removed for brevity 6Status: 7 Conditions: 8 Reason: WatchingCompositeResource 9 Status: True 10 Type: Established 11 Reason: WatchingCompositeResourceClaim 12 Status: True 13 Type: Offered 14# Removed for brevity WatchingCompositeResource Reason: WatchingCompositeResource indicates Crossplane defined the new Kubernetes custom resource definitions related to the composite resource and is watching for the creation of new composite resources.\n1Type: Established 2Status: True 3Reason: WatchingCompositeResource TerminatingCompositeResource Reason: TerminatingCompositeResource indicates Crossplane is deleting the custom resource definitions related to the composite resource and is terminating the composite resource controller.\n1Type: Established 2Status: False 3Reason: TerminatingCompositeResource WatchingCompositeResourceClaim Reason: WatchingCompositeResourceClaim indicates Crossplane defined the new Kubernetes custom resource definitions related to the offered Claims and is watching for the creation of new Claims.\n1Type: Offered 2Status: True 3Reason: WatchingCompositeResourceClaim TerminatingCompositeResourceClaim Reason: TerminatingCompositeResourceClaim indicates Crossplane is deleting the custom resource definitions related to the offered Claims and is terminating the Claims controller.\n1Type: Offered 2Status: False 3Reason: TerminatingCompositeResourceClaim ","title":"Composite Resource Definitions","url":"/v1.14/concepts/composite-resource-definitions/"},{"content":" The crossplane CLI provides utilities to make using Crossplane easier.\nRead the Crossplane CLI overview page for information on installing crossplane.\nGlobal flags The following flags are available for all commands.\nShort flag Long flag Description -h --help Show context sensitive help. -v --version Print version and exit. --verbose Print verbose output. xpkg The crossplane xpkg commands create, install and update Crossplane packages as well as enable authentication and publishing of Crossplane packages to a Crossplane package registry.\nxpkg build Using crossplane xpkg build provides automation and simplification to build Crossplane packages.\nThe Crossplane CLI combines a directory of YAML files and packages them as an OCI container image.\nThe CLI applies the required annotations and values to meet the Crossplane XPKG specification.\nThe crossplane CLI supports building configuration, function and provider package types.\nFlags Short flag Long flag Description --embed-runtime-image-name=NAME The image name and tag of an image to include in the package. Only for provider and function packages. --embed-runtime-image-tarball=PATH The filename of an image to include in the package. Only for provider and function packages. -e --examples-root=\u0026quot;./examples\u0026quot; The path to a directory of examples related to the package. --ignore=PATH,... List of files and directories to ignore. -o --package-file=PATH Directory and filename of the created package. -f --package-root=\u0026quot;.\u0026quot; Directory to search for YAML files. The crossplane xpkg build command recursively looks in the directory set by --package-root and attempts to combine any files ending in .yml or .yaml into a package.\nAll YAML files must be valid Kubernetes manifests with apiVersion, kind, metadata and spec fields.\nIgnore files Use --ignore to provide a list of files and directories to ignore.\nFor example,\ncrossplane xpkg build --ignore=\u0026quot;./test/*,kind-config.yaml\u0026quot;\nSet the package name crossplane automatically names the new package a combination of the metadata.name and a hash of the package contents and saves the contents in the same location as --package-root. Define a specific location and filename with --package-file or -o.\nFor example,\ncrossplane xpkg build -o /home/crossplane/example.xpkg.\nInclude examples Include YAML files demonstrating how to use the package with --examples-root.\nUpbound Marketplace uses files included with --examples-root as documentation for published packages.\nInclude a runtime image Functions and Providers require YAML files describing their dependencies and settings as well as a container image for their runtime.\nUsing --embed-runtime-image-name runs a specified image and includes the image inside the function or provider package.\nNote Images referenced with --embed-runtime-image-name must be in the local Docker cache.\nUse docker pull to download a missing image.\nThe --embed-runtime-image-tarball flag includes a local OCI image tarball inside the function or provider package.\nxpkg install Download and install packages into Crossplane with crossplane xpkg install.\nBy default the crossplane xpkg install command uses the Kubernetes configuration defined in ~/.kube/config.\nDefine a custom Kubernetes configuration file location with the environmental variable KUBECONFIG.\nSpecify the package kind, package file and optionally a name to give the package inside Crossplane.\ncrossplane xpkg install \u0026lt;package-kind\u0026gt; \u0026lt;registry URL package name and tag\u0026gt; [\u0026lt;optional-name\u0026gt;]\nThe \u0026lt;package-kind\u0026gt; is either a configuration, function or provider.\nFor example, to install version 0.42.0 of the AWS S3 provider:\ncrossplane xpkg install provider xpkg.upbound.io/upbound/provider-aws-s3:v0.42.0\nFlags Short flag Long flag Description --runtime-config=\u0026lt;runtime config name\u0026gt; Install the package with a runtime configuration. -m --manual-activation Set the revisionActiviationPolicy to Manual. --package-pull-secrets=\u0026lt;list of secrets\u0026gt; A comma-separated list of Kubernetes secrets to use for authenticating to the package registry. -r --revision-history-limit=\u0026lt;number of revisions\u0026gt; Set the revisionHistoryLimit. Defaults to 1. -w --wait=\u0026lt;number of seconds\u0026gt; Number of seconds to wait for a package to install. Wait for package install When installing a package the crossplane xpkg install command doesn\u0026rsquo;t wait for the package to download and install. View any download or installation problems by inspecting the configuration with kubectl describe configuration.\nUse --wait to have the crossplane xpkg install command to wait for a package to have the condition HEALTHY before continuing. The command returns an error if the wait time expires before the package is HEALTHY.\nRequire manual package activation Set the package to require manual activation, preventing an automatic upgrade of a package with --manual-activation\nAuthenticate to a private registry To authenticate to a private package registry use --package-pull-secrets and provide a list of Kubernetes Secret objects.\nImportant The secrets must be in the same namespace as the Crossplane pod. Customize the number of stored package versions By default Crossplane only stores a single inactive package in the local package cache.\nStore more inactive copies of a package with --revision-history-limit.\nRead more about package revisions in the package documentation.\nxpkg login Use xpkg login to authenticate to xpkg.upbound.io, the Upbound Marketplace container registry.\nRegister with the Upbound Marketplace to push packages and create private repositories.\nFlags Short flag Long flag Description -u --username=\u0026lt;username\u0026gt; Username to use for authentication. -p --password=\u0026lt;password\u0026gt; Password to use for authentication. -t --token=\u0026lt;token string\u0026gt; User token string to use for authentication. -a --account=\u0026lt;organization\u0026gt; Specify an Upbound organization during authentication. Authentication options The crossplane xpkg login command can use a username and password or Upbound API token.\nBy default, crossplane xpkg login without arguments, prompts for a username and password.\nProvide a username and password with the --username and --password flags or set the environmental variable UP_USER for a username or UP_PASSWORD for the password.\nUse an Upbound user token instead of a username and password with --token or the UP_TOKEN environmental variable.\nImportant The --token or UP_TOKEN environmental variables take precedence over a username and password. Using - as the input for --password or --token reads the input from stdin.\nFor example, crossplane xpkg login --password -.\nAfter logging in the Crossplane CLI creates a profile in .crossplane/config.json to cache unprivileged account information.\nNote The session field of config.json file is a session cookie identifier.\nThe session value isn\u0026rsquo;t used for authentication. This isn\u0026rsquo;t a token.\nAuthenticate with a registered Upbound organization Authenticate to a registered organization in the Upbound Marketplace with the --account option, along with the username and password or token.\nFor example, crossplane xpkg login --account=Upbound --username=my-user --password -.\nxpkg logout Use crossplane xpkg logout to invalidate the current crossplane xpkg login session.\nNote Using crossplane xpkg logout removes the session from the ~/.crossplane/config.json file, but doesn\u0026rsquo;t delete the configuration file. xpkg push Push a Crossplane package file to a package registry.\nThe Crossplane CLI pushes images to the Upbound Marketplace at xpkg.upbound.io by default.\nNote Pushing a package may require authentication with crossplane xpkg login Specify the organization, package name and tag with\ncrossplane xpkg push \u0026lt;package\u0026gt;\nBy default the command looks in the current directory for a single .xpkg file to push.\nTo push multiple files or to specify a specific .xpkg file use the -f flag.\nFor example, to push a local package named my-package to crossplane-docs/my-package:v0.14.0 use:\ncrossplane xpkg push -f my-package.xpkg crossplane-docs/my-package:v0.14.0\nTo push to another package registry, like DockerHub provide the full URL along with the package name.\nFor example, to push a local package named my-package to DockerHub organization crossplane-docs/my-package:v0.14.0 use: crossplane xpkg push -f my-package.xpkg index.docker.io/crossplane-docs/my-package:v0.14.0.\nFlags Short flag Long flag Description -f --package-files=PATH A comma-separated list of xpkg files to push. xpkg update The crossplane xpkg update command downloads and updates an existing package.\nBy default the crossplane xpkg update command uses the Kubernetes configuration defined in ~/.kube/config.\nDefine a custom Kubernetes configuration file location with the environmental variable KUBECONFIG.\nSpecify the package kind, package file and optionally the name of the package already installed in Crossplane.\ncrossplane xpkg update \u0026lt;package-kind\u0026gt; \u0026lt;registry package name and tag\u0026gt; [\u0026lt;optional-name\u0026gt;]\nThe package file must be an organization, image and tag on the xpkg.upbound.io registry on Upbound Marketplace.\nFor example, to update to version 0.42.0 of the AWS S3 provider:\ncrossplane xpkg update provider xpkg.upbound.io/upbound/provider-aws-s3:v0.42.0\nbeta Crossplane beta commands are experimental. These commands may change the flags, options or outputs in future releases.\nCrossplane maintainers may promote or remove commands under beta in future releases.\nbeta render The crossplane beta render command previews the output of a composite resource after applying any composition functions.\nImportant The crossplane beta render command doesn\u0026rsquo;t apply patch and transform composition patches.\nThe command only supports function \u0026ldquo;patch and transforms.\u0026rdquo;\nThe crossplane beta render command connects to the locally running Docker Engine to pull and run composition functions.\nImportant Running crossplane beta render requires Docker. Provide a composite resource, composition and composition function YAML definition with the command to render the output locally.\nFor example, crossplane beta render xr.yaml composition.yaml function.yaml\nThe output includes the original composite resource followed by the generated managed resources.\nAn example render output 1--- 2apiVersion: nopexample.org/v1 3kind: XBucket 4metadata: 5 name: test-xrender 6status: 7 bucketRegion: us-east-2 8--- 9apiVersion: s3.aws.upbound.io/v1beta1 10kind: Bucket 11metadata: 12 annotations: 13 crossplane.io/composition-resource-name: my-bucket 14 generateName: test-xrender- 15 labels: 16 crossplane.io/composite: test-xrender 17 ownerReferences: 18 - apiVersion: nopexample.org/v1 19 blockOwnerDeletion: true 20 controller: true 21 kind: XBucket 22 name: test-xrender 23 uid: \u0026#34;\u0026#34; 24spec: 25 forProvider: 26 region: us-east-2 Flags Short flag Long flag Description --context-files=\u0026lt;key\u0026gt;=\u0026lt;file\u0026gt;,\u0026lt;key\u0026gt;=\u0026lt;file\u0026gt; A comma separated list of files to load for function \u0026ldquo;contexts.\u0026rdquo; --context-values=\u0026lt;key\u0026gt;=\u0026lt;value\u0026gt;,\u0026lt;key\u0026gt;=\u0026lt;value\u0026gt; A comma separated list of key-value pairs to load for function \u0026ldquo;contexts.\u0026rdquo; -r --include-function-results Include the \u0026ldquo;results\u0026rdquo; or events from the function. -o --observed-resources=\u0026lt;directory or file\u0026gt; Provide artificial managed resource data to the function. --timeout= Amount of time to wait for a function to finish. The crossplane beta render command relies on standard Docker environmental variables to connect to the local Docker engine and run composition functions.\nProvide function context The --context-files and --context-values flags can provide data to a function\u0026rsquo;s context.\nThe context is JSON formatted data.\nInclude function results If a function produces Kubernetes events with statuses use the --include-function-results to print them along with the managed resource outputs.\nMock managed resources Provide mocked, or artificial data representing a managed resource with --observed-resources. The crossplane beta render command treats the provided inputs as if they were resources in a Crossplane cluster.\nA function can reference and manipulate the included resource as part of running the function.\nThe observed-resources may be a single YAML file with multiple resources or a directory of YAML files representing multiple resources.\nInside the YAML file include an apiVersion, kind, metadata and spec.\n1apiVersion: example.org/v1alpha1 2kind: ComposedResource 3metadata: 4 name: test-render-b 5 annotations: 6 crossplane.io/composition-resource-name: resource-b 7spec: 8 coolerField: \u0026#34;I\u0026#39;m cooler!\u0026#34; The schema of the resource isn\u0026rsquo;t validated and may contain any data.\nbeta trace Use the crossplane beta trace command to display a visual relationship of Crossplane objects. The trace command supports claims, compositions or managed resources.\nThe command requires a resource type and a resource name.\ncrossplane beta trace \u0026lt;resource kind\u0026gt; \u0026lt;resource name\u0026gt;\nFor example to view a resource named my-claim of type example.crossplane.io:\ncrossplane beta trace example.crossplane.io my-claim\nThe command also accepts Kubernetes CLI style \u0026lt;kind\u0026gt;/\u0026lt;name\u0026gt; input.\nFor example,\ncrossplane beta trace example.crossplane.io/my-claim\nBy default the crossplane beta trace command uses the Kubernetes configuration defined in ~/.kube/config.\nDefine a custom Kubernetes configuration file location with the environmental variable KUBECONFIG.\nFlags Short flag Long flag Description -n --namespace The namespace of the resource. -o --output= Change the graph output with wide, json, or dot for a Graphviz dot output. -s --show-connection-secrets Print any connection secret names. Doesn\u0026rsquo;t print the secret values. Output options By default crossplane beta trace prints directly to the terminal, limiting the \u0026ldquo;Ready\u0026rdquo; condition and \u0026ldquo;Status\u0026rdquo; messages to 64 characters.\nThe following an example output a \u0026ldquo;cluster\u0026rdquo; claim from the AWS reference platform, which includes multiple Compositions and composed resources:\n1crossplane beta trace cluster.aws.platformref.upbound.io platform-ref-aws 2NAME SYNCED READY STATUS 3Cluster/platform-ref-aws (default) True True Available 4└─ XCluster/platform-ref-aws-mlnwb True True Available 5 ├─ XNetwork/platform-ref-aws-mlnwb-6nvkx True True Available 6 │ ├─ VPC/platform-ref-aws-mlnwb-ckblr True True Available 7 │ ├─ InternetGateway/platform-ref-aws-mlnwb-r7w47 True True Available 8 │ ├─ Subnet/platform-ref-aws-mlnwb-lhr4h True True Available 9 │ ├─ Subnet/platform-ref-aws-mlnwb-bss4b True True Available 10 │ ├─ Subnet/platform-ref-aws-mlnwb-fzbxx True True Available 11 │ ├─ Subnet/platform-ref-aws-mlnwb-vxbf4 True True Available 12 │ ├─ RouteTable/platform-ref-aws-mlnwb-cs9nl True True Available 13 │ ├─ Route/platform-ref-aws-mlnwb-vpxdg True True Available 14 │ ├─ MainRouteTableAssociation/platform-ref-aws-mlnwb-sngx5 True True Available 15 │ ├─ RouteTableAssociation/platform-ref-aws-mlnwb-hprsp True True Available 16 │ ├─ RouteTableAssociation/platform-ref-aws-mlnwb-shb8f True True Available 17 │ ├─ RouteTableAssociation/platform-ref-aws-mlnwb-hvb2h True True Available 18 │ ├─ RouteTableAssociation/platform-ref-aws-mlnwb-m58vl True True Available 19 │ ├─ SecurityGroup/platform-ref-aws-mlnwb-xxbl2 True True Available 20 │ ├─ SecurityGroupRule/platform-ref-aws-mlnwb-7qt56 True True Available 21 │ └─ SecurityGroupRule/platform-ref-aws-mlnwb-szgxp True True Available 22 ├─ XEKS/platform-ref-aws-mlnwb-fqjzz True True Available 23 │ ├─ Role/platform-ref-aws-mlnwb-gmpqv True True Available 24 │ ├─ RolePolicyAttachment/platform-ref-aws-mlnwb-t6rct True True Available 25 │ ├─ Cluster/platform-ref-aws-mlnwb-crrt8 True True Available 26 │ ├─ ClusterAuth/platform-ref-aws-mlnwb-dgn6f True True Available 27 │ ├─ Role/platform-ref-aws-mlnwb-tdnx4 True True Available 28 │ ├─ RolePolicyAttachment/platform-ref-aws-mlnwb-qzljh True True Available 29 │ ├─ RolePolicyAttachment/platform-ref-aws-mlnwb-l64q2 True True Available 30 │ ├─ RolePolicyAttachment/platform-ref-aws-mlnwb-xn2px True True Available 31 │ ├─ NodeGroup/platform-ref-aws-mlnwb-4sfss True True Available 32 │ ├─ OpenIDConnectProvider/platform-ref-aws-mlnwb-h26xx True True Available 33 │ └─ ProviderConfig/platform-ref-aws - - 34 └─ XServices/platform-ref-aws-mlnwb-bgndx True True Available 35 ├─ Release/platform-ref-aws-mlnwb-bcj7r True True Available 36 └─ Release/platform-ref-aws-mlnwb-7hfkv True True Available Wide outputs Print the entire \u0026ldquo;Ready\u0026rdquo; or \u0026ldquo;Status\u0026rdquo; message if they\u0026rsquo;re longer than 64 characters with --output=wide.\nFor example, the output truncates the \u0026ldquo;Status\u0026rdquo; message that\u0026rsquo;s too long.\n1crossplane trace cluster.aws.platformref.upbound.io platform-ref-aws 2NAME SYNCED READY STATUS 3Cluster/platform-ref-aws (default) True False Waiting: ...resource claim is waiting for composite resource to become Ready Use --output=wide to see the full message.\n1crossplane trace cluster.aws.platformref.upbound.io platform-ref-aws --output=wide 2NAME SYNCED READY STATUS 3Cluster/platform-ref-aws (default) True False Waiting: Composite resource claim is waiting for composite resource to become Ready Graphviz dot file output Use the --output=dot to print out a textual Graphviz dot output.\nSave the output and export it or the output directly to Graphviz dot to render an image.\nFor example, to save the output as a graph.png file use dot -Tpng -o graph.png.\ncrossplane beta trace cluster.aws.platformref.upbound.io platform-ref-aws -o dot | dot -Tpng -o graph.png\nPrint connection secrets Use -s to print any connection secret names along with the other resources.\nImportant The crossplane beta trace command doesn\u0026rsquo;t print secret values. The output includes both the secret name along with the secret\u0026rsquo;s namespace.\n1NAME SYNCED READY STATUS 2Cluster/platform-ref-aws (default) True True Available 3└─ XCluster/platform-ref-aws-mlnwb True True Available 4 ├─ XNetwork/platform-ref-aws-mlnwb-6nvkx True True Available 5 │ ├─ SecurityGroupRule/platform-ref-aws-mlnwb-szgxp True True Available 6 │ └─ Secret/3f11c30b-dd94-4f5b-aff7-10fe4318ab1f (upbound-system) - - 7 ├─ XEKS/platform-ref-aws-mlnwb-fqjzz True True Available 8 │ ├─ OpenIDConnectProvider/platform-ref-aws-mlnwb-h26xx True True Available 9 │ └─ Secret/9666eccd-929c-4452-8658-c8c881aee137-eks (upbound-system) - - 10 ├─ XServices/platform-ref-aws-mlnwb-bgndx True True Available 11 │ ├─ Release/platform-ref-aws-mlnwb-7hfkv True True Available 12 │ └─ Secret/d0955929-892d-40c3-b0e0-a8cabda55895 (upbound-system) - - 13 └─ Secret/9666eccd-929c-4452-8658-c8c881aee137 (upbound-system) - - beta xpkg init The crossplane beta xpkg init command populates the current directory with files to build a package.\nProvide a name to use for the package and the package template to start from with the command\ncrossplane beta xpkg init \u0026lt;name\u0026gt; \u0026lt;template\u0026gt;\nThe \u0026lt;name\u0026gt; input isn\u0026rsquo;t used. Crossplane reserves the \u0026lt;name\u0026gt; for future releases.\nThe \u0026lt;template\u0026gt; value may be one of three well known templates:\nfunction-template-go - A template to build Crossplane composition functions from the crossplane/function-template-go repository. provider-template - A template to build a basic Crossplane provider from the Crossplane/provider-template repository. provider-template-upjet - A template for building Upjet based Crossplane providers from existing Terraform providers. Copies from the upbound/upjet-provider-template repository. Instead of a well known template the \u0026lt;template\u0026gt; value can be a git repository URL.\nFlags Short flag Long flag Description -d --directory The directory to create and load the template files into. Uses the current directory by default. ","title":"Command Reference","url":"/v1.14/cli/command-reference/"},{"content":"A composite resource represents a set of managed resources as a single Kubernetes object. Crossplane creates composite resources when users access a custom API, defined in the CompositeResourceDefinition.\nTip Composite resources are a composite of managed resources.\nA Composition defines how to compose the managed resources together. Confused about Compositions, XRDs, XRs and Claims? Crossplane has four core components that users commonly mix up:\nCompositions - A template to define how to create resources. Composite Resource Definition (XRD) - A custom API specification. Composite Resource (XR) - This page. Created by using the custom API defined in a Composite Resource Definition. XRs use the Composition template to create new managed resources. Claims (XRC) - Like a Composite Resource, but with namespace scoping. Creating composite resources Creating composite resources requires a Composition and a CompositeResourceDefinition (XRD).\nThe Composition defines the set of resources to create.\nThe XRD defines the custom API users call to request the set of resources.\nXRDs define the API used to create a composite resource.\nFor example, this CompositeResourceDefinition creates a custom API endpoint xmydatabases.example.org.\n1apiVersion: apiextensions.crossplane.io/v1 2kind: CompositeResourceDefinition 3metadata: 4 name: xmydatabases.example.org 5spec: 6 group: example.org 7 names: 8 kind: xMyDatabase 9 plural: xmydatabases 10 # Removed for brevity When a user calls the custom API, xmydatabases.example.org, Crossplane chooses the Composition to use based on the Composition\u0026rsquo;s compositeTypeRef\n1apiVersion: apiextensions.crossplane.io/v1 2kind: Composition 3metadata: 4 name: my-composition 5spec: 6 compositeTypeRef: 7 apiVersion: example.org/v1alpha1 8 kind: xMyDatabase 9 # Removed for brevity The Composition compositeTypeRef matches the XRD group and kind.\nCrossplane creates the resources defined in the matching Composition and represents them as a single composite resource.\n1kubectl get composite 2NAME SYNCED READY COMPOSITION AGE 3my-composite-resource True True my-composition 4s Naming external resources By default, managed resources created by a composite resource have the name of the composite resource, followed by a random suffix.\nFor example, a composite resource named \u0026ldquo;my-composite-resource\u0026rdquo; creates external resources named \u0026ldquo;my-composite-resource-fqvkw.\u0026rdquo;\nResource names can be deterministic by applying an annotation to the composite resource.\n1apiVersion: example.org/v1alpha1 2kind: xMyDatabase 3metadata: 4 name: my-composite-resource 5 annotations: 6 crossplane.io/external-name: my-custom-name 7# Removed for brevity Inside the Composition, use a patch to apply the external-name to the resources.\nThe fromFieldPath patch copies the metadata.annotations field from the composite resource to the metadata.annotations inside the managed resource.\nNote If a managed resource has the crossplane.io/external-name annotation Crossplane uses the annotation value to name the external resource. 1apiVersion: apiextensions.crossplane.io/v1 2kind: Composition 3metadata: 4 name: my-composition 5spec: 6 resources: 7 - name: database 8 base: 9 # Removed for brevity 10 patches: 11 - fromFieldPath: metadata.annotations 12 toFieldPath: metadata.annotations For more information on patching resources refer to the Patch and Transform documentation.\nComposition selection Select a specific Composition for a composite resource to use with compositionRef\nImportant The selected Composition must allow the composite resource to use it with a compositeTypeRef. Read more about the compositeTypeRef field in the Enabling Composite Resources section of the Composition documentation. 1apiVersion: example.org/v1alpha1 2kind: xMyDatabase 3metadata: 4 name: my-composite-resource 5spec: 6 compositionRef: 7 name: my-other-composition 8 # Removed for brevity A composite resource can also select a Composition based on labels instead of the exact name with a compositionSelector.\nInside the matchLabels section provide one or more Composition labels to match.\n1apiVersion: example.org/v1alpha1 2kind: xMyDatabase 3metadata: 4 name: my-composite-resource 5spec: 6 compositionSelector: 7 matchLabels: 8 environment: production 9 # Removed for brevity Composition revision policy Crossplane tracks changes to Compositions as Composition revisions .\nA composite resource can use a compositionUpdatePolicy to manually or automatically reference newer Composition revisions.\nThe default compositionUpdatePolicy is \u0026ldquo;Automatic.\u0026rdquo; Composite resources automatically use the latest Composition revision.\nChange the policy to Manual to prevent composite resources from automatically upgrading.\n1apiVersion: example.org/v1alpha1 2kind: xMyDatabase 3metadata: 4 name: my-composite-resource 5spec: 6 compositionUpdatePolicy: Manual 7 # Removed for brevity Composition revision selection Crossplane records changes to Compositions as Composition revisions. A composite resource can select a specific Composition revision.\nUse compositionRevisionRef to select a specific Composition revision by name.\nFor example, to select a specific Composition revision use the name of the desired Composition revision.\n1apiVersion: example.org/v1alpha1 2kind: xMyDatabase 3metadata: 4 name: my-composite-resource 5spec: 6 compositionUpdatePolicy: Manual 7 compositionRevisionRef: 8 name: my-composition-b5aa1eb 9 # Removed for brevity Note Find the Composition revision name from kubectl get compositionrevision\n1kubectl get compositionrevision 2NAME REVISION XR-KIND XR-APIVERSION AGE 3my-composition-5c976ad 1 xmydatabases example.org/v1alpha1 65m 4my-composition-b5aa1eb 2 xmydatabases example.org/v1alpha1 64m A Composite resource can also select Composition revisions based on labels instead of the exact name with a compositionRevisionSelector.\nInside the matchLabels section provide one or more Composition revision labels to match.\n1apiVersion: example.org/v1alpha1 2kind: xMyDatabase 3metadata: 4 name: my-composite-resource 5spec: 6 compositionRevisionSelector: 7 matchLabels: 8 channel: dev 9 # Removed for brevity Manage connection secrets When a composite resource creates resources, Crossplane provides any connection secrets to the composite resource.\nImportant A resource may only access connection secrets allowed by the XRD. By default XRDs provide access to all connection secrets generated by managed resources.\nRead more about managing connection secrets in the XRD documentation. Use writeConnectionSecretToRef to specify where the composite resource writes their connection secrets to.\nFor example, this composite resource saves the connection secrets in a Kubernetes secret object named my-secret in the namespace crossplane-system.\n1apiVersion: example.org/v1alpha1 2kind: xMyDatabase 3metadata: 4 name: my-composite-resource 5spec: 6 writeConnectionSecretToRef: 7 name: my-secret 8 namespace: crossplane-system 9 # Removed for brevity Composite resources can write connection secrets to an external secret store, like HashiCorp Vault.\nImportant External secret stores are an alpha feature. Alpha features aren\u0026rsquo;t enabled by default. Use the publishConnectionDetailsTo field to save connection secrets to an external secrets store.\n1apiVersion: example.org/v1alpha1 2kind: xMyDatabase 3metadata: 4 name: my-composite-resource 5spec: 6 publishConnectionDetailsTo: 7 name: my-external-secret-store 8 # Removed for brevity Read the External Secrets Store documentation for more information on using external secret stores.\nFor more information on connection secrets read the Connection Secrets knowledge base article.\nPausing composite resources Crossplane supports pausing composite resources. A paused composite resource doesn\u0026rsquo;t check or make changes on its external resources.\nTo pause a composite resource apply the crossplane.io/paused annotation.\n1apiVersion: example.org/v1alpha1 2kind: xMyDatabase 3metadata: 4 name: my-composite-resource 5 annotations: 6 crossplane.io/paused: \u0026#34;true\u0026#34; 7spec: 8 # Removed for brevity Verify composite resources Use kubectl get composite to view all the composite resources Crossplane created.\n1kubectl get composite 2NAME SYNCED READY COMPOSITION AGE 3my-composite-resource True True my-composition 4s Use kubectl get for the specific custom API endpoint to view only those resources.\n1kubectl get xMyDatabase.example.org 2NAME SYNCED READY COMPOSITION AGE 3my-composite-resource True True my-composition 12m Use kubectl describe composite to view the linked Composition Ref, and unique managed resources created in the Resource Refs.\n1kubectl describe composite my-composite-resource 2Name: my-composite-resource 3API Version: example.org/v1alpha1 4Kind: xMyDatabase 5Spec: 6 Composition Ref: 7 Name: my-composition 8 Composition Revision Ref: 9 Name: my-composition-cf2d3a7 10 Composition Update Policy: Automatic 11 Resource Refs: 12 API Version: s3.aws.upbound.io/v1beta1 13 Kind: Bucket 14 Name: my-composite-resource-fmrks 15 API Version: dynamodb.aws.upbound.io/v1beta1 16 Kind: Table 17 Name: my-composite-resource-wnr9t 18# Removed for brevity Composite resource conditions The conditions of composite resources match the conditions of their managed resources.\nRead the conditions section of the managed resources documentation for details.\nComposite resource labels Crossplane adds labels to composite resources to show their relationship to other Crossplane components.\nComposite label Crossplane adds the crossplane.io/composite label to all composite resources. The label matches the name of the composite. Crossplane applies the composite label to any manged resource created by a composite, creating a reference between the managed resource and owning composite resource.\n1kubectl describe xmydatabase.example.org/my-claimed-database-x9rx9 2Name: my-claimed-database2-x9rx9 3Namespace: 4Labels: crossplane.io/composite=my-claimed-database-x9rx9 Claim name label Crossplane adds the crossplane.io/claim-name label to composite resources created from a Claim. The label indicates the name of the Claim linked to this composite resource.\n1kubectl describe xmydatabase.example.org/my-claimed-database-x9rx9 2Name: my-claimed-database2-x9rx9 3Namespace: 4Labels: crossplane.io/claim-name=my-claimed-database Composite resources created directly, without using a Claim, don\u0026rsquo;t have a crossplane.io/claim-name label.\nClaim namespace label Crossplane adds the crossplane.io/claim-namespace label to composite resources created from a Claim. The label indicates the namespace of the Claim linked to this composite resource.\n1kubectl describe xmydatabase.example.org/my-claimed-database-x9rx9 2Name: my-claimed-database2-x9rx9 3Namespace: 4Labels: crossplane.io/claim-namespace=default Composite resources created directly, without using a Claim, don\u0026rsquo;t have a crossplane.io/claim-namespace label.\n","title":"Composite Resources","url":"/v1.14/concepts/composite-resources/"},{"content":"Claims represents a set of managed resources as a single Kubernetes object, inside a namespace.\nUsers create claims when they access the custom API, defined in the CompositeResourceDefinition.\nTip Claims are like composite resources. The difference between Claims and composite resources is Crossplane can create Claims in a namespace, while composite resources are cluster scoped. Confused about Compositions, XRDs, XRs and Claims? Crossplane has four core components that users commonly mix up:\nCompositions - A template to define how to create resources. Composite Resource Definition (XRD) - A custom API specification. Composite Resources (XR) - Created by using the custom API defined in a Composite Resource Definition. XRs use the Composition template to create new managed resources. Claims (XRC) - This page. Like a Composite Resource, but with namespace scoping. Creating a Claim Creating a Claim requires a Composition and a CompositeResourceDefinition (XRD) already installed.\nNote The XRD must enable Claims. The Composition defines the set of resources to create.\nThe XRD defines the custom API users call to request the set of resources.\nFor example, this CompositeResourceDefinition creates a composite resource API endpoint xmydatabases.example.org and enables a Claim API endpoint database.example.org\n1apiVersion: apiextensions.crossplane.io/v1 2kind: CompositeResourceDefinition 3metadata: 4 name: xmydatabases.example.org 5spec: 6 group: example.org 7 names: 8 kind: XMyDatabase 9 plural: xmydatabases 10 claimNames: 11 kind: Database 12 plural: databases 13 # Removed for brevity The Claim uses the XRD\u0026rsquo;s kind API endpoint to request resources.\nThe Claim\u0026rsquo;s apiVersion matches the XRD group and the kind matches the XRD claimNames.kind\n1apiVersion: example.org/v1alpha1 2kind: database 3metadata: 4 name: my-claimed-database 5spec: 6 # Removed for brevity When a user creates a Claim in a namespace Crossplane also creates a composite resource.\nUse kubectl describe on the Claim to view the related composite resource.\nThe Resource Ref is the composite resource Crossplane created for this Claim.\n1kubectl describe database.example.org/my-claimed-database 2Name: my-claimed-database 3API Version: example.org/v1alpha1 4Kind: database 5Spec: 6 Resource Ref: 7 API Version: example.org/v1alpha1 8 Kind: XMyDatabase 9 Name: my-claimed-database-rr4ll 10# Removed for brevity. Use kubectl describe on the composite resource to view the Claim Ref linking the composite resource to the original Claim.\n1kubectl describe xmydatabase.example.org/my-claimed-database-rr4ll 2Name: my-claimed-database-rr4ll 3API Version: example.org/v1alpha1 4Kind: XMyDatabase 5Spec: 6 Claim Ref: 7 API Version: example.org/v1alpha1 8 Kind: database 9 Name: my-claimed-database 10 Namespace: default Note Crossplane supports directly creating composite resources. Claims allow namespace scoping and isolation for users consuming the custom APIs.\nIf you don\u0026rsquo;t use namespaces in your Kubernetes deployment Claims aren\u0026rsquo;t necessary.\nClaiming existing composite resources By default, creating a Claim creates a new composite resource. Claims can also link to existing composite resources.\nA use case for claiming existing composite resources may be slow to provision resources. Composite resources can be pre-provisioned and a Claim can use those resources without waiting for their creation.\nSet the Claim\u0026rsquo;s resourceRef and match the pre-existing composite resource name.\n1apiVersion: example.org/v1alpha1 2kind: database 3metadata: 4 name: my-claimed-database 5spec: 6 resourceRef: 7 apiVersion: example.org/v1alpha1 8 kind: XMyDatabase 9 name: my-pre-created-xr If a Claim specifies a resourceRef that doesn\u0026rsquo;t exist, Crossplane doesn\u0026rsquo;t create a composite resource.\nNote All Claims have a resourceRef. Manually defining the resourceRef isn\u0026rsquo;t required. Crossplane fills in the resourceRef with the information from the composite resource created for the Claim. Claim connection secrets If a Claim expects connection secrets the Claim must define a writeConnectionSecretToRef object.\nThe writeConnectionSecretToRef object defines the name of the Kubernetes secret object where Crossplane saves the connection details.\nNote The Crossplane creates the secret object in the same namespace as the Claim. For example, to a new secret object named my-claim-secret use writeConnectionSecretToRef with the name: my-claim-secret.\n1apiVersion: example.org/v1alpha1 2kind: database 3metadata: 4 name: my-claimed-database 5spec: 6 writeConnectionSecretToRef: 7 name: my-claim-secret For more information on connection secrets read the Connection Secrets knowledge base article.\n","title":"Claims","url":"/v1.14/concepts/claims/"},{"content":"Crossplane Compositions allow for \u0026ldquo;patch and transform\u0026rdquo; operations. With patches a Composition can apply changes to the resources defined by the Composition.\nWhen users create Claims, Crossplane passes the settings in the Claim to the associated composite resource. Patches can use these settings to change the associated composite resource or managed resources.\nExamples of using patch and transforms include:\nchanging the name of the external resource mapping generic terms like \u0026ldquo;east\u0026rdquo; or \u0026ldquo;west\u0026rdquo; to specific provider locations appending custom labels or strings to resource fields Note Crossplane expects patch and transform operations to be simple changes.\nUse Composition Functions for more complex or programmatic modifications.\nA Composition patch is the action of changing a field.\nA Composition transform modifies the values before applying the patch.\nCreate a patch Patches are part of an individual resource inside a Composition.\nThe patches field takes a list of patches to apply to the individual resource.\nEach patch has a type, which defines what kind of patch action Crossplane applies.\nPatches reference fields inside a composite resource or Composition differently depending on the patch type, but all patches reference a fromFieldPath and toFieldPath.\nThe fromFieldPath defines the patch\u0026rsquo;s input values. The toFieldPath defines the data to change with a patch.\nHere is an example patch applied to a resource in a Composition.\n1apiVersion: apiextensions.crossplane.io/v1 2kind: Composition 3spec: 4 resources: 5 - name: my-composed-resource 6 base: 7 # Removed for brevity 8 patches: 9 - type: FromCompositeFieldPath 10 fromFieldPath: spec.field1 11 toFieldPath: metadata.labels[\u0026#34;patchLabel\u0026#34;] Selecting fields Crossplane selects fields in a composite resource or managed resource with a subset of JSONPath selectors, called \u0026ldquo;field selectors.\u0026rdquo;\nField selectors can select any field in a composite resource or managed resource object, including the metadata, spec or status fields.\nField selectors can be a string matching a field name or an array index, in brackets. Field names may use a . character to select child elements.\nExample field selectors Here are some example selectors from a composite resource object. Selector Selected element kind kind metadata.labels['crossplane.io/claim-name'] my-example-claim spec.desiredRegion eu-north-1 spec.resourceRefs[0].name my-example-claim-978mh-r6z64 1$ kubectl get composite -o yaml 2apiVersion: example.org/v1alpha1 3kind: xExample 4metadata: 5 # Removed for brevity 6 labels: 7 crossplane.io/claim-name: my-example-claim 8 crossplane.io/claim-namespace: default 9 crossplane.io/composite: my-example-claim-978mh 10spec: 11 desiredRegion: eu-north-1 12 field1: field1-text 13 resourceRefs: 14 - apiVersion: s3.aws.upbound.io/v1beta1 15 kind: Bucket 16 name: my-example-claim-978mh-r6z64 17 - apiVersion: s3.aws.upbound.io/v1beta1 18 kind: Bucket 19 name: my-example-claim-978mh-cnlhj 20 - apiVersion: s3.aws.upbound.io/v1beta1 21 kind: Bucket 22 name: my-example-claim-978mh-rv5nm 23 # Removed for brevity Reuse a patch A Composition can reuse a patch object on multiple resources with a PatchSet.\nTo create a PatchSet, define a PatchSets object inside the Composition\u0026rsquo;s spec.\nEach patch inside a PatchSet has a name and a list of patches.\nNote For multiple PatchSets only use a single PatchSets object.\nIdentify each unique PatchSet with a unique name.\nApply the PatchSet to a resource with a patch type: PatchSet.\nSet the patchSetName to the name of the PatchSet.\n1apiVersion: apiextensions.crossplane.io/v1 2kind: Composition 3# Removed for brevity 4spec: 5 patchSets: 6 - name: my-patchset 7 patches: 8 - type: FromCompositeFieldPath 9 fromFieldPath: spec.desiredRegion 10 toFieldPath: spec.forProvider.region 11 resources: 12 - name: bucket1 13 base: 14 # Removed for brevity 15 patches: 16 - type: PatchSet 17 patchSetName: my-patchset 18 - name: bucket2 19 base: 20 # Removed for brevity 21 patches: 22 - type: PatchSet 23 patchSetName: my-patchset Important A PatchSet can\u0026rsquo;t contain other PatchSets.\nCrossplane ignores any transforms or policies in a PatchSet.\nPatching between resources Compositions can\u0026rsquo;t directly patch between resources in the same Composition.\nFor example, generating a network resource and patching the resource name to a compute resource.\nImportant The ToEnvironmentFieldPath patch can\u0026rsquo;t read from a Status field. A resource can patch to a user-defined Status field in the composite resource.\nA resource can then read from that Status field to patch a field.\nFirst, define a custom Status in the Composite Resource Definition and a custom field, for example secondResource\n1kind: CompositeResourceDefinition 2# Removed for brevity. 3spec: 4 # Removed for brevity. 5 versions: 6 - name: v1alpha1 7 schema: 8 openAPIV3Schema: 9 type: object 10 properties: 11 spec: 12 # Removed for brevity. 13 status: 14 type: object 15 properties: 16 secondResource: 17 type: string Inside the Composition the resource with the source data uses a ToCompositeFieldPath patch to write data to the status.secondResource field in the composite resource.\nThe destination resource uses a FromCompositeFieldPath patch to read data from the composite resource status.secondResource field in the composite resource and write it to a label named secondResource in the managed resource.\n1apiVersion: apiextensions.crossplane.io/v1 2kind: Composition 3# Removed for brevity 4 - name: bucket1 5 base: 6 apiVersion: s3.aws.upbound.io/v1beta1 7 kind: Bucket 8 # Removed for brevity 9 patches: 10 - type: ToCompositeFieldPath 11 fromFieldPath: metadata.name 12 toFieldPath: status.secondResource 13 - name: bucket2 14 base: 15 apiVersion: s3.aws.upbound.io/v1beta1 16 kind: Bucket 17 # Removed for brevity 18 patches: 19 - type: FromCompositeFieldPath 20 fromFieldPath: status.secondResource 21 toFieldPath: metadata.labels[\u0026#39;secondResource\u0026#39;] Describe the composite resource to view the resources and the status.secondResource value.\n1$ kubectl describe composite 2Name: my-example-claim-jp7rx 3Spec: 4 # Removed for brevity 5 Resource Refs: 6 Name: my-example-claim-jp7rx-gfg4m 7 # Removed for brevity 8 Name: my-example-claim-jp7rx-fttpj 9Status: 10 # Removed for brevity 11 Second Resource: my-example-claim-jp7rx-gfg4m Describe the destination managed resource to see the label secondResource.\n1$ kubectl describe bucket 2kubectl describe bucket my-example-claim-jp7rx-fttpj 3Name: my-example-claim-jp7rx-fttpj 4Labels: crossplane.io/composite=my-example-claim-jp7rx 5 secondResource=my-example-claim-jp7rx-gfg4m Types of patches Crossplane supports multiple patch types, each using a different source for data and applying the patch to a different location.\nImportant This section describes patches applied to individual resources inside a Composition.\nFor information about applying patches to an entire composite resource with a Composition\u0026rsquo;s environment.patches read the Environment Configurations documentation.\nSummary of Crossplane patches Patch Type Data Source Data Destination FromCompositeFieldPath A field in the composite resource. A field in the patched managed resource. ToCompositeFieldPath A field in the patched managed resource. A field in the composite resource. CombineFromComposite Multiple fields in the composite resource. A field in the patched managed resource. CombineToComposite Multiple fields in the patched managed resource. A field in the composite resource. FromEnvironmentFieldPath Data in the in-memory EnvironmentConfig Environment A field in the patched managed resource. ToEnvironmentFieldPath A field in the patched managed resource. The in-memory EnvironmentConfig Environment. CombineFromEnvironment Multiple fields in the in-memory EnvironmentConfig Environment. A field in the patched managed resource. CombineToEnvironment Multiple fields in the patched managed resource. A field in the in-memory EnvironmentConfig Environment. Note All the following examples use the same set of Compositions, CompositeResourceDefinitions, Claims and EnvironmentConfigs.\nOnly the applied patches change between examples.\nAll examples rely on Upbound provider-aws-s3 to create resources.\nReference Composition 1apiVersion: apiextensions.crossplane.io/v1 2kind: Composition 3metadata: 4 name: example-composition 5spec: 6 compositeTypeRef: 7 apiVersion: example.org/v1alpha1 8 kind: xExample 9 environment: 10 environmentConfigs: 11 - ref: 12 name: example-environment 13 resources: 14 - name: bucket1 15 base: 16 apiVersion: s3.aws.upbound.io/v1beta1 17 kind: Bucket 18 spec: 19 forProvider: 20 region: us-east-2 21 - name: bucket2 22 base: 23 apiVersion: s3.aws.upbound.io/v1beta1 24 kind: Bucket 25 spec: 26 forProvider: 27 region: us-east-2 Reference CompositeResourceDefinition 1apiVersion: apiextensions.crossplane.io/v1 2kind: CompositeResourceDefinition 3metadata: 4 name: xexamples.example.org 5spec: 6 group: example.org 7 names: 8 kind: xExample 9 plural: xexamples 10 claimNames: 11 kind: ExampleClaim 12 plural: exampleclaims 13 versions: 14 - name: v1alpha1 15 served: true 16 referenceable: true 17 schema: 18 openAPIV3Schema: 19 type: object 20 properties: 21 spec: 22 type: object 23 properties: 24 field1: 25 type: string 26 field2: 27 type: string 28 field3: 29 type: string 30 desiredRegion: 31 type: string 32 boolField: 33 type: boolean 34 numberField: 35 type: integer 36 status: 37 type: object 38 properties: 39 url: 40 type: string Reference Claim 1apiVersion: example.org/v1alpha1 2kind: ExampleClaim 3metadata: 4 name: my-example-claim 5spec: 6 field1: \u0026#34;field1-text\u0026#34; 7 field2: \u0026#34;field2-text\u0026#34; 8 desiredRegion: \u0026#34;eu-north-1\u0026#34; 9 boolField: false 10 numberField: 10 Reference EnvironmentConfig 1apiVersion: apiextensions.crossplane.io/v1alpha1 2kind: EnvironmentConfig 3metadata: 4 name: example-environment 5data: 6 locations: 7 us: us-east-2 8 eu: eu-north-1 9 key1: value1 10 key2: value2 FromCompositeFieldPath The FromCompositeFieldPath patch takes a value in a composite resource and applies it to a field in the managed resource.\nTip Use the FromCompositeFieldPath patch to apply options from users in their Claims to settings in managed resource forProvider settings. For example, to use the value desiredRegion provided by a user in a composite resource to a managed resource\u0026rsquo;s region.\nThe fromFieldPath value is a field in the composite resource.\nThe toFieldPath value is the field in the managed resource to change.\n1apiVersion: apiextensions.crossplane.io/v1 2kind: Composition 3# Removed for brevity 4 - name: bucket1 5 base: 6 apiVersion: s3.aws.upbound.io/v1beta1 7 kind: Bucket 8 spec: 9 forProvider: 10 region: us-east-2 11 patches: 12 - type: FromCompositeFieldPath 13 fromFieldPath: spec.desiredRegion 14 toFieldPath: spec.forProvider.region View the managed resource to see the updated region\n1$ kubectl describe bucket 2Name: my-example-claim-qlr68-29nqf 3# Removed for brevity 4Spec: 5 For Provider: 6 Region: eu-north-1 ToCompositeFieldPath The ToCompositeFieldPath writes data from an individual managed resource to the composite resource that created it.\nTip Use ToCompositeFieldPath patches to take data from one managed resource in a Composition and use it in a second managed resource in the same Composition. For example, after Crossplane creates a new managed resource, take the value hostedZoneID and apply it as a label in the composite resource.\n1apiVersion: apiextensions.crossplane.io/v1 2kind: Composition 3# Removed for brevity 4 - name: bucket1 5 base: 6 apiVersion: s3.aws.upbound.io/v1beta1 7 kind: Bucket 8 spec: 9 forProvider: 10 region: us-east-2 11 patches: 12 - type: ToCompositeFieldPath 13 fromFieldPath: status.atProvider.hostedZoneId 14 toFieldPath: metadata.labels[\u0026#39;ZoneID\u0026#39;] View the created managed resource to see the Hosted Zone Id field.\n1$ kubectl describe bucket 2Name: my-example-claim-p5pxf-5vnp8 3# Removed for brevity 4Status: 5 At Provider: 6 Hosted Zone Id: Z2O1EMRO9K5GLX 7 # Removed for brevity Next view the composite resource and confirm the patch applied the label\n1$ kubectl describe composite 2Name: my-example-claim-p5pxf 3Labels: ZoneID=Z2O1EMRO9K5GLX Important Crossplane doesn\u0026rsquo;t apply the patch to the composite resource until the next reconcile loop, after creating the managed resource. This creates a delay between a managed resource being Ready and applying the patch. CombineFromComposite The CombineFromComposite patch takes values from the composite resource, combines them and applies them to the managed resource.\nTip Use the CombineFromComposite patch to create complex strings, like security policies and apply them to a managed resource. For example, use the Claim value desiredRegion and field2 to generate the managed resource\u0026rsquo;s name\nThe CombineFromComposite patch only supports the combine option.\nThe variables are the list of fromFieldPath values from the composite resource to combine.\nThe only supported strategy is strategy: string.\nOptionally you can apply a string.fmt, based on Go string formatting to specify how to combine the strings.\nThe toFieldPath is the field in the managed resource to apply the new string to.\n1apiVersion: apiextensions.crossplane.io/v1 2kind: Composition 3# Removed for brevity 4 - name: bucket1 5 base: 6 apiVersion: s3.aws.upbound.io/v1beta1 7 kind: Bucket 8 spec: 9 forProvider: 10 region: us-east-2 11 patches: 12 - type: CombineFromComposite 13 combine: 14 variables: 15 - fromFieldPath: spec.desiredRegion 16 - fromFieldPath: spec.field2 17 strategy: string 18 string: 19 fmt: \u0026#34;my-resource-%s-%s\u0026#34; 20 toFieldPath: metadata.name Describe the managed resource to see the applied patch.\n1$ kubectl describe bucket 2Name: my-resource-eu-north-1-field2-text CombineToComposite The CombineToComposite patch takes values from the managed resource, combines them and applies them to the composite resource.\nTip Use CombineToComposite patches to create a single field like a URL from multiple fields in a managed resource. For example, use the managed resource name and region to generate a custom url field.\nImportant Writing custom fields in the Status field of a composite resource requires defining the custom fields in the CompositeResourceDefinition first. The CombineToComposite patch only supports the combine option.\nThe variables are the list of fromFieldPath the managed resource to combine.\nThe only supported strategy is strategy: string.\nOptionally you can apply a string.fmt, based on Go string formatting to specify how to combine the strings.\nThe toFieldPath is the field in the composite resource to apply the new string to.\n1apiVersion: apiextensions.crossplane.io/v1 2kind: Composition 3# Removed for brevity 4 - name: bucket1 5 base: 6 apiVersion: s3.aws.upbound.io/v1beta1 7 kind: Bucket 8 spec: 9 forProvider: 10 region: us-east-2 11 patches: 12 - type: CombineToComposite 13 combine: 14 variables: 15 - fromFieldPath: metadata.name 16 - fromFieldPath: spec.forProvider.region 17 strategy: string 18 string: 19 fmt: \u0026#34;https://%s.%s.com\u0026#34; 20 toFieldPath: status.url View the composite resource to verify the applied patch.\n1$ kubectl describe composite 2Name: my-example-claim-bjdjw 3API Version: example.org/v1alpha1 4Kind: xExample 5# Removed for brevity 6Status: 7 # Removed for brevity 8 URL: https://my-example-claim-bjdjw-r6ncd.us-east-2.com FromEnvironmentFieldPath Important EnvironmentConfigs are an alpha feature. They aren\u0026rsquo;t enabled by default.\nFor more information about using an EnvironmentConfig, read the EnvironmentConfigs documentation.\nThe FromEnvironmentFieldPath patch takes values from the in-memory EnvironmentConfig environment and applies them to the managed resource.\nTip Use FromEnvironmentFieldPath to apply custom managed resource settings based on the current environment. For example, use the environment\u0026rsquo;s locations.eu value and apply it as the region.\n1apiVersion: apiextensions.crossplane.io/v1 2kind: Composition 3# Removed for brevity 4 - name: bucket1 5 base: 6 apiVersion: s3.aws.upbound.io/v1beta1 7 kind: Bucket 8 spec: 9 forProvider: 10 region: us-east-2 11 patches: 12 - type: FromEnvironmentFieldPath 13 fromFieldPath: locations.eu 14 toFieldPath: spec.forProvider.region Verify managed resource to confirm the applied patch.\n1kubectl describe bucket 2Name: my-example-claim-8vrvc-xx5sr 3Labels: crossplane.io/claim-name=my-example-claim 4# Removed for brevity 5Spec: 6 For Provider: 7 Region: eu-north-1 8 # Removed for brevity ToEnvironmentFieldPath Important EnvironmentConfigs are an alpha feature. They aren\u0026rsquo;t enabled by default.\nFor more information about using an EnvironmentConfig, read the EnvironmentConfigs documentation.\nThe ToEnvironmentFieldPath patch takes values the managed resource and applies them to the in-memory EnvironmentConfig environment.\nTip Use ToEnvironmentFieldPath write data to the environment that any FromEnvironmentFieldPath patch can access. For example, use the desired region value and apply it as the environment\u0026rsquo;s key1.\n1apiVersion: apiextensions.crossplane.io/v1 2kind: Composition 3# Removed for brevity 4 - name: bucket1 5 base: 6 apiVersion: s3.aws.upbound.io/v1beta1 7 kind: Bucket 8 spec: 9 forProvider: 10 region: us-east-2 11 patches: 12 - type: ToEnvironmentFieldPath 13 fromFieldPath: spec.forProvider.region 14 toFieldPath: key1 Because the environment is in-memory, there is no command to confirm the patch wrote the value to the environment.\nImportant The ToEnvironmentFieldPath patch happens before creating a resource.\nThe fromFieldPath can\u0026rsquo;t read from the atProvider or Status fields. CombineFromEnvironment Important EnvironmentConfigs are an alpha feature. They aren\u0026rsquo;t enabled by default.\nFor more information about using an EnvironmentConfig, read the EnvironmentConfigs documentation.\nThe CombineFromEnvironment patch combines multiple values from the in-memory EnvironmentConfig environment and applies them to the managed resource.\nTip Use CombineFromEnvironment patch to create complex strings, like security policies and apply them to a managed resource. For example, combine multiple fields in the environment to create a unique annotation .\nThe CombineFromEnvironment patch only supports the combine option.\nThe only supported strategy is strategy: string.\nThe variables are the list of fromFieldPath values from the in-memory environment to combine.\nOptionally you can apply a string.fmt, based on Go string formatting to specify how to combine the strings.\nThe toFieldPath is the field in the managed resource to apply the new string to.\n1apiVersion: apiextensions.crossplane.io/v1 2kind: Composition 3# Removed for brevity 4 - name: bucket1 5 base: 6 apiVersion: s3.aws.upbound.io/v1beta1 7 kind: Bucket 8 spec: 9 forProvider: 10 region: us-east-2 11 patches: 12 - type: CombineFromEnvironment 13 combine: 14 strategy: string 15 variables: 16 - fromFieldPath: key1 17 - fromFieldPath: key2 18 string: 19 fmt: \u0026#34;%s-%s\u0026#34; 20 toFieldPath: metadata.annotations[EnvironmentPatch] Describe the managed resource to see new annotation.\n1$ kubectl describe bucket 2Name: my-example-claim-zmxdg-grl6p 3# Removed for brevity 4Annotations: EnvironmentPatch: value1-value2 5# Removed for brevity CombineToEnvironment Important EnvironmentConfigs are an alpha feature. They aren\u0026rsquo;t enabled by default.\nFor more information about using an EnvironmentConfig, read the EnvironmentConfigs documentation.\nThe CombineToEnvironment patch combines multiple values from the managed resource and applies them to the in-memory EnvironmentConfig environment.\nTip Use CombineToEnvironment patch to create complex strings, like security policies to use in other managed resources. For example, combine multiple fields in the managed resource to create a unique string and store it in the environment\u0026rsquo;s key2 value.\nThe string combines the managed resource Kind and region.\nThe CombineToEnvironment patch only supports the combine option.\nThe only supported strategy is strategy: string.\nThe variables are the list of fromFieldPath values in the managed resource to combine.\nOptionally you can apply a string.fmt, based on Go string formatting to specify how to combine the strings.\nThe toFieldPath is the key in the environment to write the new string to.\nImportant The environment\u0026rsquo;s key must already exist. Patches can\u0026rsquo;t create new environment keys. 1apiVersion: apiextensions.crossplane.io/v1 2kind: Composition 3# Removed for brevity 4 - name: bucket1 5 base: 6 apiVersion: s3.aws.upbound.io/v1beta1 7 kind: Bucket 8 spec: 9 forProvider: 10 region: us-east-2 11 patches: 12 - type: CombineToEnvironment 13 combine: 14 strategy: string 15 variables: 16 - fromFieldPath: kind 17 - fromFieldPath: spec.forProvider.region 18 string: 19 fmt: \u0026#34;%s.%s\u0026#34; 20 toFieldPath: key2 Because the environment is in-memory, there is no command to confirm the patch wrote the value to the environment.\nTransform a patch When applying a patch, Crossplane supports modifying the data before applying it as a patch. Crossplane calls this a \u0026ldquo;transform\u0026rdquo; operation.\nSummary of Crossplane transforms. Transform Type Action convert Converts an input data type to a different type. Also called \u0026ldquo;casting.\u0026rdquo; map Selects a specific output based on a specific input. match Selects a specific output based on a string or regular expression. math Applies a mathematical operation on the input. string Change the input string using Go string formatting. Apply a transform directly to an individual patch with the transforms field.\nA transform requires a type, indicating the transform action to take.\nThe other transform field is the same as the type, in this example, map.\nThe other fields depend on the patch type used.\nThis example uses a type: map transform, taking the input spec.desiredRegion, matching it to either us or eu and returning the corresponding AWS region for the spec.forProvider.region value.\n1apiVersion: apiextensions.crossplane.io/v1 2kind: Composition 3# Removed for brevity 4 - name: bucket1 5 base: 6 apiVersion: s3.aws.upbound.io/v1beta1 7 kind: Bucket 8 spec: 9 forProvider: 10 region: us-east-2 11 patches: 12 - type: FromCompositeFieldPath 13 fromFieldPath: spec.desiredRegion 14 toFieldPath: spec.forProvider.region 15 transforms: 16 - type: map 17 map: 18 us: us-east-2 19 eu: eu-north-1 Convert transforms The convert transform type changes the input data type to a different data type.\nTip Some provider APIs require a field to be a string. Use a convert type to change any boolean or integer fields to strings. A convert transform requires a toType, defining the output data type.\n1patches: 2 - type: FromCompositeFieldPath 3 fromFieldPath: spec.numberField 4 toFieldPath: metadata.label[\u0026#34;numberToString\u0026#34;] 5 transforms: 6 - type: convert 7 convert: 8 toType: string Supported toType values: toType value Description bool A boolean value of true or false. float64 A 64-bit float value. int A 32-bit integer value. int64 A 64-bit integer value. string A string value. object An object. array An array. Converting strings to booleans When converting from a string to a bool Crossplane considers the string values\n1, t, T, TRUE, True and true\nequal to the boolean value True.\nThe strings\n0, f, F, FALSE, False and false\nare equal to the boolean value False.\nConverting numbers to booleans Crossplane considers the integer 1 and float 1.0 equal to the boolean value True.\nAny other integer or float value is False.\nConverting booleans to numbers Crossplane converts the boolean value True to the integer 1 or float64 1.0.\nThe value False converts to the integer 0 or float64 0.0\nConverting strings to float64 When converting from a string to a float64 Crossplane supports an optional\nformat: quantity field.\nUsing format: quantity translates size suffixes like M for megabyte or Mi for megabit into the correct float64 value.\nNote Refer to the Go language docs for a full list of supported suffixes. Add format: quantity to the convert object to enable quantity suffix support.\n1- type: convert 2 convert: 3 toType: float64 4 format: quantity Converting strings to objects Crossplane converts JSON strings to objects.\nAdd format: json to the convert object which is the only supported string format for this conversion.\n1- type: convert 2 convert: 3 toType: object 4 format: json Tip This conversion is useful for patching keys in an object. The following example adds a tag to a resource with a customized key:\n1 - type: FromCompositeFieldPath 2 fromFieldPath: spec.clusterName 3 toFieldPath: spec.forProvider.tags 4 transforms: 5 - type: string 6 string: 7 type: Format 8 fmt: \u0026#39;{\u0026#34;kubernetes.io/cluster/%s\u0026#34;: \u0026#34;true\u0026#34;}\u0026#39; 9 - type: convert 10 convert: 11 toType: object 12 format: json Converting strings to arrays Crossplane converts JSON strings to arrays.\nAdd format: json to the convert object which is the only supported string format for this conversion.\n1- type: convert 2 convert: 3 toType: array 4 format: json Map transforms The map transform type maps an input value to an output value.\nTip The map transform is useful for translating generic region names like US or EU to provider specific region names. The map transform compares the value from the fromFieldPath to the options listed in the map.\nIf Crossplane finds the value, Crossplane puts the mapped value in the toFieldPath.\nNote Crossplane ignores the patch if the value isn\u0026rsquo;t found. spec.field1 is the string \"field1-text\" then Crossplane uses the string firstField for the annotation.\nIf spec.field1 is the string \"field2-text\" then Crossplane uses the string secondField for the annotation.\n1patches: 2 - type: FromCompositeFieldPath 3 fromFieldPath: spec.field1 4 toFieldPath: metadata.annotations[\u0026#34;myAnnotation\u0026#34;] 5 transforms: 6 - type: map 7 map: 8 \u0026#34;field1-text\u0026#34;: \u0026#34;firstField\u0026#34; 9 \u0026#34;field2-text\u0026#34;: \u0026#34;secondField\u0026#34; In this example, the value of spec.field1 is field1-text.\n1$ kubectl describe composite 2Name: my-example-claim-twx7n 3Spec: 4 # Removed for brevity 5 field1: field1-text The annotation applied to the managed resource is firstField.\n1$ kubectl describe bucket 2Name: my-example-claim-twx7n-ndb2f 3Annotations: crossplane.io/composition-resource-name: bucket1 4 myLabel: firstField 5# Removed for brevity. Match transform The match transform is like the map transform.\nThe match transform adds support for regular expressions along with exact strings and can provide default values if there isn\u0026rsquo;t a match.\nA match object requires a patterns object.\nThe patterns is a list of one or more patterns to attempt to match the input value against.\n1patches: 2 - type: FromCompositeFieldPath 3 fromFieldPath: spec.field1 4 toFieldPath: metadata.annotations[\u0026#34;myAnnotation\u0026#34;] 5 transforms: 6 - type: match 7 match: 8 patterns: 9 - type: literal 10 # Removed for brevity 11 - type: regexp 12 # Removed for brevity Match patterns can be either type: literal to match an exact string or type: regexp to match a regular expression.\nNote Crossplane stops processing matches after the first pattern match. Match an exact string Use a pattern with type: literal to match an exact string.\nOn a successful match Crossplane provides the result: to the patch toFieldPath.\n1patches: 2 - type: FromCompositeFieldPath 3 fromFieldPath: spec.field1 4 toFieldPath: metadata.annotations[\u0026#34;myAnnotation\u0026#34;] 5 transforms: 6 - type: match 7 match: 8 patterns: 9 - type: literal 10 literal: \u0026#34;field1-text\u0026#34; 11 result: \u0026#34;matchedLiteral\u0026#34; Match a regular expression Use a pattern with type: regexp to match a regular expression.\nDefine a regexp key with the value of the regular expression to match.\nOn a successful match Crossplane provides the result: to the patch toFieldPath.\n1patches: 2 - type: FromCompositeFieldPath 3 fromFieldPath: spec.field1 4 toFieldPath: metadata.annotations[\u0026#34;myAnnotation\u0026#34;] 5 transforms: 6 - type: match 7 match: 8 patterns: 9 - type: regexp 10 regexp: \u0026#39;^field1.*\u0026#39; 11 result: \u0026#34;foundField1\u0026#34; Using default values Optionally you can provide a default value to use if there is no matching pattern.\nThe default value can either be the original input value or a defined default value.\nUse fallbackTo: Value to provide a default value if a match isn\u0026rsquo;t found.\nFor example if the string unknownString isn\u0026rsquo;t matched, Crossplane provides the Value StringNotFound to the toFieldPath\n1patches: 2 - type: FromCompositeFieldPath 3 fromFieldPath: spec.field1 4 toFieldPath: metadata.annotations[\u0026#34;myAnnotation\u0026#34;] 5 transforms: 6 - type: match 7 match: 8 patterns: 9 - type: literal 10 literal: \u0026#34;UnknownString\u0026#34; 11 result: \u0026#34;foundField1\u0026#34; 12 fallbackTo: Value 13 fallbackValue: \u0026#34;StringNotFound\u0026#34; To use the original input as the fallback value use fallbackTo: Input.\nCrossplane uses the original fromFieldPath input for the toFieldPath value.\n1patches: 2 - type: FromCompositeFieldPath 3 fromFieldPath: spec.field1 4 toFieldPath: metadata.annotations[\u0026#34;myAnnotation\u0026#34;] 5 transforms: 6 - type: match 7 match: 8 patterns: 9 - type: literal 10 literal: \u0026#34;UnknownString\u0026#34; 11 result: \u0026#34;foundField1\u0026#34; 12 fallbackTo: Input Math transforms Use the math transform to multiply an input or apply a minimum or maximum value.\nImportant A math transform only supports integer inputs. 1patches: 2 - type: FromCompositeFieldPath 3 fromFieldPath: spec.numberField 4 toFieldPath: metadata.annotations[\u0026#34;mathAnnotation\u0026#34;] 5 transforms: 6 - type: math 7 math: 8 ... clampMin The type: clampMin uses a defined minimum value if an input is larger than the type: clampMin value.\nFor example, this type: clampMin requires an input to be greater than 20.\nIf an input is lower than 20, Crossplane uses the clampMin value for the toFieldPath.\n1patches: 2 - type: FromCompositeFieldPath 3 fromFieldPath: spec.numberField 4 toFieldPath: metadata.annotations[\u0026#34;mathAnnotation\u0026#34;] 5 transforms: 6 - type: math 7 math: 8 type: clampMin 9 clampMin: 20 clampMax The type: clampMax uses a defined minimum value if an input is larger than the type: clampMax value.\nFor example, this type: clampMax requires an input to be less than 5.\nIf an input is higher than 5, Crossplane uses the clampMax value for the toFieldPath.\n1patches: 2 - type: FromCompositeFieldPath 3 fromFieldPath: spec.numberField 4 toFieldPath: metadata.annotations[\u0026#34;mathAnnotation\u0026#34;] 5 transforms: 6 - type: math 7 math: 8 type: clampMax 9 clampMax: 5 Multiply The type: multiply multiplies the input by the multiply value.\nFor example, this type: multiply multiplies the value from the fromFieldPath value by 2\n1patches: 2 - type: FromCompositeFieldPath 3 fromFieldPath: spec.numberField 4 toFieldPath: metadata.annotations[\u0026#34;mathAnnotation\u0026#34;] 5 transforms: 6 - type: math 7 math: 8 type: multiply 9 multiply: 2 Note The multiply value only supports integers. String transforms The string transform applies string formatting or manipulation to string inputs.\n1patches: 2 - type: FromCompositeFieldPath 3 fromFieldPath: spec.field1 4 toFieldPath: metadata.annotations[\u0026#34;stringAnnotation\u0026#34;] 5 transforms: 6 - type: string 7 string: 8 type: ... String transforms support the following types\nConvert Format Regexp TrimPrefix TrimSuffix String convert The type: convert converts the input based on one of the following conversion types:\nToUpper - Change the string to all upper case letters. ToLower - Change the string to all lower case letters. ToBase64 - Create a new base64 string from the input. FromBase64 - Create a new text string from a base64 input. ToJson - Convert the input string to valid JSON. ToSha1 - Create a SHA-1 hash of the input string. ToSha256 - Create a SHA-256 hash of the input string. ToSha512 - Create a SHA-512 hash of the input string. ToAdler32 - Create an Adler32 hash of the input string. 1patches: 2 - type: FromCompositeFieldPath 3 fromFieldPath: spec.field1 4 toFieldPath: metadata.annotations[\u0026#34;FIELD1-TEXT\u0026#34;] 5 transforms: 6 - type: string 7 string: 8 type: Convert 9 convert: \u0026#34;ToUpper\u0026#34; String format The type: format applies Go string formatting to the input.\n1patches: 2 - type: FromCompositeFieldPath 3 fromFieldPath: spec.field1 4 toFieldPath: metadata.annotations[\u0026#34;stringAnnotation\u0026#34;] 5 transforms: 6 - type: string 7 string: 8 type: Format 9 fmt: \u0026#34;the-field-%s\u0026#34; Regular expression type The type: Regexp extracts the part of the input matching a regular expression.\nOptionally use a group to match a regular expression capture group.\nBy default Crossplane matches the entire regular expression.\n1patches: 2 - type: FromCompositeFieldPath 3 fromFieldPath: spec.desiredRegion 4 toFieldPath: metadata.annotations[\u0026#34;euRegion\u0026#34;] 5 transforms: 6 - type: string 7 string: 8 type: Regexp 9 regexp: 10 match: \u0026#39;^eu-(.*)-\u0026#39; 11 group: 1 Trim prefix The type: TrimPrefix removes the matching string and all preceding characters.\n1patches: 2 - type: FromCompositeFieldPath 3 fromFieldPath: spec.desiredRegion 4 toFieldPath: metadata.annotations[\u0026#34;north-1\u0026#34;] 5 transforms: 6 - type: string 7 string: 8 type: TrimPrefix 9 trim: `eu- Trim suffix The type: TrimSuffix removes the matching string and all proceeding characters.\n1patches: 2 - type: FromCompositeFieldPath 3 fromFieldPath: spec.desiredRegion 4 toFieldPath: metadata.annotations[\u0026#34;eu\u0026#34;] 5 transforms: 6 - type: string 7 string: 8 type: TrimSuffix 9 trim: `-north-1\u0026#39; Patch policies Crossplane supports two types of patch policies:\nfromFieldPath mergeOptions fromFieldPath policy Using a fromFieldPath: Required policy on a patch requires the fromFieldPath to exist in the composite resource.\nTip If a resource patch isn\u0026rsquo;t working applying the fromFieldPath: Required policy may produce an error in the composite resource to help troubleshoot. By default, Crossplane applies the policy fromFieldPath: Optional. With fromFieldPath: Optional Crossplane ignores a patch if the fromFieldPath doesn\u0026rsquo;t exist.\nWith fromFieldPath: Required the composite resource produces an error if the fromFieldPath doesn\u0026rsquo;t exist.\n1patches: 2 - type: FromCompositeFieldPath 3 fromFieldPath: spec.desiredRegion 4 toFieldPath: metadata.annotations[\u0026#34;eu\u0026#34;] 5 policy: 6 fromFieldPath: Required Merge options By default when applying a patch the destination data is overridden. Use mergeOptions to allow patches to merge arrays and objects without overwriting them.\nWith an array input, use appendSlice: true to append the array data to the end of the existing array.\nWith an object, use keepMapValues: true to leave existing object keys in tact. The patch updates any matching keys between the input and destination data.\n1patches: 2 - type: FromCompositeFieldPath 3 fromFieldPath: spec.desiredRegion 4 toFieldPath: metadata.annotations[\u0026#34;eu\u0026#34;] 5 policy: 6 mergeOptions: 7 appendSlice: true 8 keepMapValues: true ","title":"Patch and Transforms","url":"/v1.14/concepts/patch-and-transform/"},{"content":" A Crossplane EnvironmentConfig is a cluster scoped ConfigMap-like resource used by Compositions. Compositions can use the environment to store information from individual resources or to apply patches.\nCrossplane supports multiple EnvironmentConfigs, each acting as a unique data store.\nWhen Crossplane creates a composite resource, Crossplane merges all the EnvironmentConfigs referenced in the associated Composition and creates a unique in-memory environment for that composite resource.\nThe composite resource can read and write data to their unique in-memory environment.\nImportant The in-memory environment is unique to each composite resource.\nA composite resource can\u0026rsquo;t read data in another composite resource\u0026rsquo;s environment. Enable EnvironmentConfigs EnvironmentConfigs are an alpha feature. Alpha features aren\u0026rsquo;t enabled by default.\nEnable EnvironmentConfig support by changing the Crossplane pod setting and enabling\n--enable-environment-configs argument.\n1$ kubectl edit deployment crossplane --namespace crossplane-system 2apiVersion: apps/v1 3kind: Deployment 4spec: 5# Removed for brevity 6 template: 7 spec: 8 containers: 9 - args: 10 - core 11 - start 12 - --enable-environment-configs Tip The Crossplane install guide describes enabling feature flags like \u0026ndash;enable-environment-configs with Helm. Create an EnvironmentConfig An EnvironmentConfig has a single object field, data.\nAn EnvironmentConfig supports any data inside the data field.\nHere an example EnvironmentConfig.\n1apiVersion: apiextensions.crossplane.io/v1alpha1 2kind: EnvironmentConfig 3metadata: 4 name: example-environment 5data: 6 locations: 7 us: us-east-2 8 eu: eu-north-1 9 key1: value1 10 key2: value2 11 key3: 12 - item1 13 - item2 Select an EnvironmentConfig Select the EnvironmentConfigs to use inside a Composition\u0026rsquo;s environment field.\nThe environmentConfigs field is a list of environments this Composition can use.\nSelect an environment by Reference or by Selector.\nA Reference selects an environment by name.\nThe Selector selects an environment based on the Labels applied to the environment.\n1apiVersion: apiextensions.crossplane.io/v1 2kind: Composition 3metadata: 4 name: example-composition 5spec: 6 environment: 7 environmentConfigs: 8 - type: Reference 9 ref: 10 name: example-environment 11 - type: Selector 12 selector: 13 matchLabels: 14 # Removed for brevity If a Composition uses multiple environmentConfigs Crossplane merges them together in the order they\u0026rsquo;re listed.\nNote If multiple environmentConfigs use the same key, the Composition uses the value of the last environment listed. Select by name Select an environment by name with type: Reference.\nDefine the ref object and the name matching the exact name of the environment.\nFor example, select the environmentConfig named example-environment\n1apiVersion: apiextensions.crossplane.io/v1 2kind: Composition 3metadata: 4 name: example-composition 5spec: 6 environment: 7 environmentConfigs: 8 - type: Reference 9 ref: 10 name: example-environment Select by label Select an environment by labels with a type: Selector.\nDefine the selector object.\nThe matchLabels object contains a list of labels to match on.\nSelecting a label requires matching both the label key and the value of key.\nWhen matching the label\u0026rsquo;s value, provide an exact value with a type: Value and provide the value to match in the value field.\nCrossplane can also match a label\u0026rsquo;s value based on an input in the composite resource. Use type: FromCompositeFieldPath and provide the field to match in the valueFromFieldPath field.\n1apiVersion: apiextensions.crossplane.io/v1 2kind: Composition 3metadata: 4 name: example-composition 5spec: 6 environment: 7 environmentConfigs: 8 - type: Selector 9 selector: 10 matchLabels: 11 - key: my-label-key 12 type: Value 13 value: my-label-value 14 - key: my-label-key 15 type: FromCompositeFieldPath 16 valueFromFieldPath: spec.parameters.deploy 17 resources: 18 # Removed for brevity Manage selector results Selecting environments by labels may return more than one environment.\nThe Composition sorts all the results by the name of the environments and only uses the first environment in the sorted list.\nSet the mode as mode: Multiple to return all matched environments. Use mode: Single to return a single environment.\nNote Sorting and the selection mode only applies to a single type: Selector.\nThis doesn\u0026rsquo;t change how Compositions merge multiple environmentConfigs.\n1apiVersion: apiextensions.crossplane.io/v1 2kind: Composition 3metadata: 4 name: example-composition 5spec: 6 environment: 7 environmentConfigs: 8 - type: Selector 9 selector: 10 mode: Multiple 11 matchLabels: 12 - key: my-label-key 13 type: Value 14 value: my-label-value 15 - key: my-label-key 16 type: FromCompositeFieldPath 17 valueFromFieldPath: spec.parameters.deploy 18 - type: Selector 19 selector: 20 mode: Single 21 matchLabels: 22 - key: my-other-label-key 23 type: Value 24 value: my-other-label-value 25 - key: my-other-label-key 26 type: FromCompositeFieldPath 27 valueFromFieldPath: spec.parameters.deploy When using mode: Multiple limit the number of returned environments with maxMatch and define the maximum number of environments returned.\nThe Composition sorts the returned environments alphabetically by name. Sort the environments on a different field with sortByFieldPath and define the field to sort by.\n1apiVersion: apiextensions.crossplane.io/v1 2kind: Composition 3metadata: 4 name: example-composition 5spec: 6 environment: 7 environmentConfigs: 8 - type: Selector 9 selector: 10 mode: Multiple 11 maxMatch: 4 12 sortByFieldPath: metadata.annotations[sort.by/weight] 13 matchLabels: 14 - key: my-label-key 15 type: Value 16 value: my-label-value 17 - key: my-label-key 18 type: FromCompositeFieldPath 19 valueFromFieldPath: spec.parameters.deploy The environments selected by matchLabels are then merged into any other environments listed in the environmentConfigs.\nOptional selector labels By default, Crossplane issues an error if a valueFromFieldPath field doesn\u0026rsquo;t exist in the composite resource.\nAdd fromFieldPathPolicy as Optional to ignore a field if it doesn\u0026rsquo;t exist.\n1apiVersion: apiextensions.crossplane.io/v1 2kind: Composition 3metadata: 4 name: example-composition 5spec: 6 environment: 7 environmentConfigs: 8 - type: Selector 9 selector: 10 matchLabels: 11 - key: my-first-label-key 12 type: Value 13 value: my-first-label-value 14 - key: my-second-label-key 15 type: FromCompositeFieldPath 16 valueFromFieldPath: spec.parameters.deploy 17 fromFieldPathPolicy: Optional 18 resources: 19 # Removed for brevity Set a default value for an optional label by setting the default value for the key first, then define the Optional label.\nFor example, this Composition defines value: my-default-value for the key my-second-label-key. If the label my-second-label-key exists, Crossplane uses the value from the label instead.\n1apiVersion: apiextensions.crossplane.io/v1 2kind: Composition 3metadata: 4 name: example-composition 5spec: 6 environment: 7 environmentConfigs: 8 - type: Selector 9 selector: 10 matchLabels: 11 - key: my-first-label-key 12 type: Value 13 value: my-label-value 14 - key: my-second-label-key 15 type: Value 16 value: my-default-value 17 - key: my-second-label-key 18 type: FromCompositeFieldPath 19 valueFromFieldPath: spec.parameters.deploy 20 fromFieldPathPolicy: Optional 21 resources: 22 # Removed for brevity Warning Crossplane applies values in order. The value of the last key defined always takes precedence.\nDefining the default value after the label always overwrites the label value.\nPatching with EnvironmentConfigs When Crossplane creates or updates a composite resource, Crossplane merges all the specified EnvironmentConfigs into an in-memory environment.\nThe composite resource can read or write data between the EnvironmentConfig and composite resource or between the EnvironmentConfig and individual resources defined inside the composite resource.\nTip Read about EnvironmentConfig patch types in the Patch and Transform documentation. Patch a composite resource To patch the composite resource use patches inside of the environment.\nUse the ToCompositeFieldPath to copy data from the in-memory environment to the composite resource.\nUse the FromCompositeFieldPath to copy data from the composite resource to the in-memory environment.\n1apiVersion: apiextensions.crossplane.io/v1 2kind: Composition 3# Removed for Brevity 4spec: 5 environment: 6 # Removed for Brevity 7 patches: 8 - type: ToCompositeFieldPath 9 fromFieldPath: tags 10 toFieldPath: metadata.labels[envTag] 11 - type: FromCompositeFieldPath 12 fromFieldPath: metadata.name 13 toFieldPath: newEnvironmentKey Individual resources can use any data written to the in-memory environment.\nPatch an individual resource To patch an individual resource, inside the patches of the resource, use ToEnvironmentFieldPath to copy data from the resource to the in-memory environment.\nUse FromEnvironmentFieldPath to copy data to the resource from the in-memory environment.\n1apiVersion: apiextensions.crossplane.io/v1 2kind: Composition 3# Removed for Brevity 4spec: 5 environment: 6 # Removed for Brevity 7 resources: 8 # Removed for Brevity 9 - name: vpc 10 base: 11 apiVersion: ec2.aws.upbound.io/v1beta1 12 kind: VPC 13 spec: 14 forProvider: 15 cidrBlock: 172.16.0.0/16 16 patches: 17 - type: ToEnvironmentFieldPath 18 fromFieldPath: status.atProvider.id 19 toFieldPath: vpcId 20 - type: FromEnvironmentFieldPath 21 fromFieldPath: tags 22 toFieldPath: spec.forProvider.tags The Patch and Transform documentation has more information on patching individual resources.\n","title":"Environment Configurations","url":"/v1.14/concepts/environment-configs/"},{"content":"Composition functions (or just functions, for short) are custom programs that template Crossplane resources. Crossplane calls composition functions to determine what resources it should create when you create a composite resource (XR). You can write a function to template resources using a general purpose programming language like Go or Python. Using a general purpose programming language allows a Function to use more advanced logic to template resources, like loops and conditionals.\nYou can build a function using general purpose programming languages such as Go or Python. The Crossplane community has also built functions that let you template Crossplane resources using CUE, Helm-like Go templates or Patch and Transforms.\nInstall a composition function Installing a Function creates a function pod. Crossplane sends requests to this pod to ask it what resources to create when you create a composite resource.\nInstall a Function with a Crossplane Function object setting the spec.package value to the location of the function package.\nFor example, to install Function Patch and Transform,\n1apiVersion: pkg.crossplane.io/v1beta1 2kind: Function 3metadata: 4 name: function-patch-and-transform 5spec: 6 package: xpkg.upbound.io/crossplane-contrib/function-patch-and-transform:v0.1.4 Tip Functions are Crossplane Packages. Read more about Packages in the Packages documentation. By default, the Function pod installs in the same namespace as Crossplane (crossplane-system).\nVerify a composition function View the status of a Function with kubectl get functions\nDuring the install a Function reports INSTALLED as True and HEALTHY as Unknown.\n1kubectl get functions 2NAME INSTALLED HEALTHY PACKAGE AGE 3function-patch-and-transform True Unknown xpkg.upbound.io/crossplane-contrib/function-patch-and-transform:v0.1.4 10s After the Function install completes and it\u0026rsquo;s ready for use the HEALTHY status reports True.\nUse a function in a composition Crossplane calls a Function to determine what resources it should create when you create a composite resource. The Function also tells Crossplane what to do with these resources when a you update or delete a composite resource.\nWhen Crossplane calls a Function it sends it the current state of the composite resource. It also sends it the current state of any managed resources the composite resource owns.\nCrossplane knows what Function to call when a composite resource changes by looking at the Composition the composite resource uses.\nConfused about Composite Resources and Compositions? Crossplane has four core components that users commonly mix up:\nComposition - A template to define how to create resources. CompositeResourceDefinition (XRD) - A custom API specification. Composite Resource (XR) - Created by using the custom API defined in a CompositeResourceDefinition. XRs use the Composition template to create new managed resources. Claim (XRC) - Like a Composite Resource, but with namespace scoping. To use composition functions set the Composition mode to Pipeline.\nDefine a pipeline of steps. Each step calls a Function.\nEach step uses a functionRef to reference the name of the Function to call.\nImportant Compositions using mode: Pipeline can\u0026rsquo;t specify resource templates with a resources field.\nUse function \u0026ldquo;Patch and Transform\u0026rdquo; to create resource templates.\nSome Functions also allow you to specify an input.\nThe function defines the kind of input.\nThis example uses Function Patch and Transform.\nFunction Patch and Transform implements Crossplane resource templates.\nThe input kind is Resources, and it accepts Patch and Transform resources as input.\n1apiVersion: apiextensions.crossplane.io/v1 2kind: Composition 3# Removed for Brevity 4spec: 5 # Removed for Brevity 6 mode: Pipeline 7 pipeline: 8 - step: patch-and-transform 9 functionRef: 10 name: function-patch-and-transform 11 input: 12 apiVersion: pt.fn.crossplane.io/v1beta1 13 kind: Resources 14 resources: 15 - name: storage-bucket 16 base: 17 apiVersion: s3.aws.upbound.io/v1beta1 18 kind: Bucket 19 spec: 20 forProvider: 21 region: \u0026#34;us-east-2\u0026#34; Use a pipeline of functions in a composition Crossplane can ask more than one Function what to do when a composite resource changes. When a Composition has a pipeline of two or more steps, Crossplane calls them all. It calls them in the order they appear in the pipeline.\nCrossplane passes each Function in the pipeline the result of the previous Function. This enables powerful combinations of Functions. In this example, Crossplane calls function-cue to create an S3 bucket. Crossplane then passes the bucket to function-auto-ready, which marks the composite resource as ready when the bucket becomes ready.\n1apiVersion: apiextensions.crossplane.io/v1 2kind: Composition 3# Removed for Brevity 4spec: 5 # Removed for Brevity 6 mode: Pipeline 7 pipeline: 8 - step: cue-export-resources 9 functionRef: 10 name: function-cue 11 input: 12 apiVersion: cue.fn.crossplane.io/v1beta1 13 kind: CUEInput 14 name: storage-bucket 15 export: 16 target: Resources 17 value: | 18 apiVersion: \u0026#34;s3.aws.upbound.io/v1beta1\u0026#34; 19 kind: \u0026#34;Bucket\u0026#34; 20 spec: forProvider: region: \u0026#34;us-east-2\u0026#34; 21 - step: automatically-detect-readiness 22 functionRef: 23 name: function-auto-ready Test a composition that uses functions You can preview the output of any composition that uses composition functions using the Crossplane CLI. You don\u0026rsquo;t need a Crossplane control plane to do this. The Crossplane CLI uses Docker Engine to run functions.\nTip See the Crossplane CLI docs to learn how to install and use the Crossplane CLI. Important Running crossplane beta render requires Docker. Provide a composite resource, composition and composition functions to render the output locally.\n1crossplane beta render xr.yaml composition.yaml functions.yaml crossplane beta render prints resources as YAML to stdout. It prints the composite resource first, followed by the resources the composition functions created.\n1--- 2apiVersion: example.crossplane.io/v1 3kind: XBucket 4metadata: 5 name: example-render 6--- 7apiVersion: s3.aws.upbound.io/v1beta1 8kind: Bucket 9metadata: 10 annotations: 11 crossplane.io/composition-resource-name: storage-bucket 12 generateName: example-render- 13 labels: 14 crossplane.io/composite: example-render 15 ownerReferences: 16 - apiVersion: example.crossplane.io/v1 17 blockOwnerDeletion: true 18 controller: true 19 kind: XBucket 20 name: example-render 21 uid: \u0026#34;\u0026#34; 22spec: 23 forProvider: 24 region: us-east-2 The xr.yaml, composition.yaml and function.yaml files used in the example You can recreate the output below using by running crossplane beta render with these files.\nThe xr.yaml file contains the composite resource to render:\n1apiVersion: example.crossplane.io/v1 2kind: XBucket 3metadata: 4 name: example-render 5spec: 6 bucketRegion: us-east-2 The composition.yaml file contains the Composition to use to render the composite resource:\n1apiVersion: apiextensions.crossplane.io/v1 2kind: Composition 3metadata: 4 name: example-render 5spec: 6 compositeTypeRef: 7 apiVersion: example.crossplane.io/v1 8 kind: XBucket 9 mode: Pipeline 10 pipeline: 11 - step: patch-and-transform 12 functionRef: 13 name: function-patch-and-transform 14 input: 15 apiVersion: pt.fn.crossplane.io/v1beta1 16 kind: Resources 17 resources: 18 - name: storage-bucket 19 base: 20 apiVersion: s3.aws.upbound.io/v1beta1 21 kind: Bucket 22 patches: 23 - type: FromCompositeFieldPath 24 fromFieldPath: spec.bucketRegion 25 toFieldPath: spec.forProvider.region The functions.yaml file contains the Functions the Composition references in its pipeline steps:\n1--- 2apiVersion: pkg.crossplane.io/v1beta1 3kind: Function 4metadata: 5 name: function-patch-and-transform 6spec: 7 package: xpkg.upbound.io/crossplane-contrib/function-patch-and-transform:v0.1.4 The Crossplane CLI uses Docker Engine to run functions. You can change how the Crossplane CLI run a function by adding an annotation in functions.yaml. Add the render.crossplane.io/runtime annotation to a Function to change how it\u0026rsquo;s run.\ncrossplane beta render supports two render.crossplane.io/runtime values:\nDocker (the default) connects to Docker Engine. It uses Docker to pull and run a function runtime. Development connects to a function runtime you have run manually. When you use the Development runtime the Crossplane CLI ignores the Function\u0026rsquo;s package. Instead it expects you to make sure the function is listening on localhost port 9443. The function must be listening without gRPC transport security. Most function SDKs let you run a function with the --insecure flag to disable transport security. For example you can run a Go function locally using go run . --insecure.\n1apiVersion: pkg.crossplane.io/v1beta1 2kind: Function 3metadata: 4 name: function-patch-and-transform 5 annotation: 6 render.crossplane.io/runtime: Development 7spec: 8 package: xpkg.upbound.io/crossplane-contrib/function-patch-and-transform:v0.1.4 Tip Use the Development runtime when you write a composition function to test your function end-to-end. crossplane beta render also supports the following Function annotations. These annotations affect how it runs Functions:\nrender.crossplane.io/runtime-docker-cleanup - When using the Docker runtime this annotation specifies whether the CLI should stop the function container after it calls the function. It supports the values Stop, to stop the container, and Orphan, to leave it running. render.crossplane.io/runtime-docker-pull-policy - When using the Docker runtime this annotation specifies when the CLI should pull the Function\u0026rsquo;s package. It supports the values Always, Never, and IfNotPresent. render.crossplane.io/runtime-development-target - When using the Development runtime this annotation tells the CLI to connect to a Function running at the specified target. It uses gRPC target syntax. Write a composition function Composition functions let you replace complicated Compositions with code written in your programming language of choice. Crossplane has tools, software development kits (SDKs) and templates to help you write a function.\nHere\u0026rsquo;s an example of a tiny, hello world function. This example is written in Go.\n1func (f *Function) RunFunction(_ context.Context, req *fnv1beta1.RunFunctionRequest) (*fnv1beta1.RunFunctionResponse, error) { 2 rsp := response.To(req, response.DefaultTTL) 3 response.Normal(rsp, \u0026#34;Hello world!\u0026#34;) 4 return rsp, nil 5} Some people design composition functions for you to use them with any kind of composite resource. Function Patch and Transform and Function Auto Ready work with any kind of composite resource.\nAnother common pattern is to write a composition function specific to one kind of composite resource. The function contains all the logic needed to tell Crossplane what resources to create when you create a composite resource. When you write a composition function like this, your Composition can be small. It just tells Crossplane what function to run when you create, update, or delete a composite resource.\nThis Composition tells Crossplane to call function-xr-xbucket whenever you create, update, or delete an XBucket composite resource. function-xr-xbucket is hard coded to handle XBucket composite resources.\n1apiVersion: apiextensions.crossplane.io/v1 2kind: Composition 3metadata: 4 name: example-bucket-function 5spec: 6 compositeTypeRef: 7 apiVersion: example.crossplane.io/v1 8 kind: XBucket 9 mode: Pipeline 10 pipeline: 11 - step: handle-xbucket-xr 12 functionRef: 13 name: function-xr-xbucket To write a composition function, you:\nCreate the function from a template. Edit the template to add the function\u0026rsquo;s logic. Test the function. Build the function, and push it to a package registry. You use the Crossplane CLI to create, test, build, and push a function. For example,\n1# Create the function from a template. 2crossplane beta xpkg init function-example function-template-go 3Initialized package \u0026#34;function-example\u0026#34; in directory \u0026#34;/home/negz/control/negz/function-example\u0026#34; from https://github.com/crossplane/function-template-go/tree/91a1a5eed21964ff98966d72cc6db6f089ad63f4 (main) 4 5$ ls 6Dockerfile fn.go fn_test.go go.mod go.sum input LICENSE main.go package README.md renovate.json 7 8# Edit the template to add your function\u0026#39;s logic 9$ vim fn.go 10 11# Build the function. 12$ docker build . --quiet --tag runtime 13sha256:2c31b0f7a34b34ba5b0b2dacc94c360d18aca1b99f56ca4f40a1f26535a7c1c4 14 15# Package the function. 16$ crossplane xpkg build -f package --embed-runtime-image=runtime 17 18# Test the function. 19$ go run . --insecure 20$ crossplane beta render xr.yaml composition.yaml functions.yaml 21 22# Push the function package to xpkg.upbound.io. 23$ crossplane xpkg push -f package/*.xpkg crossplane-contrib/function-example:v0.1.0 Tip Crossplane has language specific guides to writing a composition function. Refer to the guide for your preferred language for a more detailed guide to writing a function. When you\u0026rsquo;re writing a composition function it\u0026rsquo;s useful to know how composition functions work. Read the next section to learn how composition functions work.\nHow composition functions work Each composition function is actually a gRPC server. gRPC is a high performance, open source remote procedure call (RPC) framework. When you install a function Crossplane deploys the function as a gRPC server. Crossplane encrypts and authenticates all gRPC communication.\nYou don\u0026rsquo;t have to be a gRPC expert to write a function. Crossplane\u0026rsquo;s function SDKs setup gRPC for you. It\u0026rsquo;s useful to understand how Crossplane calls your function though, and how your function should respond.\nsequenceDiagram User-\u003e\u003e+API Server: Create composite resource Crossplane Pod-\u003e\u003e+API Server: Observe composite resource Crossplane Pod-\u003e\u003e+Function Pod: gRPC RunFunctionRequest Function Pod-\u003e\u003e+Crossplane Pod: gRPC RunFunctionResponse Crossplane Pod-\u003e\u003e+API Server: Apply desired composed resources When you create, update, or delete a composite resource that uses composition functions Crossplane calls each function in the order they appear in the Composition\u0026rsquo;s pipeline. Crossplane calls each function by sending it a gRPC RunFunctionRequest. The function must respond with a gRPC RunFunctionResponse.\nTip You can find detailed schemas for the RunFunctionRequest and RunFunctionResponse RPCs in the Buf Schema Registry. When Crossplane calls a function it includes four important things in the RunFunctionRequest.\nThe observed state of the composite resource, and any composed resources. The desired state of the composite resource, and any composed resources. The function\u0026rsquo;s input. The function pipeline\u0026rsquo;s context. A function\u0026rsquo;s main job is to update the desired state and return it to Crossplane. It does this by returning a RunFunctionResponse.\nMost composition functions read the observed state of the composite resource, and use it to add composed resources to the desired state. This tells Crossplane which composed resources it should create or update.\nTip A composed resource is a resource created by a composite resource. Composed resources are usually Crossplane managed resources (MRs), but they can be any kind of Crossplane resource. For example a composite resource could also create a ProviderConfig, or another kind of composite resource.\nObserved state When you create a composite resource like this one, Crossplane observes it and sends it to the composition function as part of the observed state.\n1apiVersion: example.crossplane.io/v1 2kind: XBucket 3metadata: 4 name: example-render 5spec: 6 bucketRegion: us-east-2 If any composed resources already exist, Crossplane observes them and sends them to your function to as part of the observed state.\nCrossplane also observes the connection details of your composite resource and any composed resources. It sends them to your function as part of the observed state.\nCrossplane observes the composite resource and any composed resources once, right before it starts calling the functions in the pipeline. This means that Crossplane sends every function in the pipeline the same observed state.\nDesired state Desired state is the set of the changes the function pipeline wants to make to the composite resource and any composed resources. When a function adds composed resources to the desired state Crossplane creates them.\nA function can change:\nThe status of the composite resource. The metadata and spec of any composed resource. A function can also change the connection details and readiness of the composite resource. A function indicates that the composite resource is ready by telling Crossplane whether its composed resources are ready. When the function pipeline tells Crossplane that all composed resources are ready, Crossplane marks the composite resource as ready.\nA function can\u0026rsquo;t change:\nThe metadata or spec of the composite resource. The status of any composed resource. The connection details of any composed resource. A pipeline of functions accumulates desired state. This means that each function builds upon the desired state of previous functions in the pipeline. Crossplane sends a function the desired state accumulated by all previous functions in the pipeline. The function adds to or updates the desired state and then passes it on. When the last function in the pipeline has run, Crossplane applies the desired state it returns.\nImportant A function must copy all desired state from its RunFunctionRequest to its RunFunctionResponse. If a function adds a resource to its desired state the next function must copy it to its desired state. If it doesn\u0026rsquo;t, Crossplane doesn\u0026rsquo;t apply the resource. If the resource exists, Crossplane deletes it.\nA function can intentionally choose not to copy parts of the desired state. For example a function may choose not to copy a desired resource to prevent that resource from existing.\nMost function SDKs handle copying desired state automatically.\nA function should only add the fields it cares about to the desired state. It should add these fields every time Crossplane calls it. If a function adds a field to the desired state once, but doesn\u0026rsquo;t add it the next time it\u0026rsquo;s called, Crossplane deletes the field. The same is true for composed resources. If a function adds a composed resource to the desired state, but doesn\u0026rsquo;t add it the next time it\u0026rsquo;s called, Crossplane deletes the composed resource.\nTip Crossplane uses server side apply to apply the desired state returned by a function pipeline. In server side apply terminology, the desired state is a fully specified intent. For example, if all a function wants is to make sure an S3 bucket in region us-east-2 exists, it should add this resource to its desired composed resources.\n1apiVersion: s3.aws.upbound.io/v1beta1 2kind: Bucket 3spec: 4 forProvider: 5 region: us-east-2 Even if the Bucket already exists and has other spec fields, or a status, name, labels, etc the function should omit them. The function should only include the fields it has an opinion about. Crossplane takes care of applying the fields the function cares about, merging them with the existing Bucket.\nTip Composition functions don\u0026rsquo;t actually use YAML for desired and observed resources. This example uses YAML for illustration purposes only. Function input If a Composition includes input Crossplane sends it to the function. Input is a useful way to provide extra configuration to a function. Supporting input is optional. Not all functions support input.\n1apiVersion: apiextensions.crossplane.io/v1 2kind: Composition 3metadata: 4 name: example-render 5spec: 6 compositeTypeRef: 7 apiVersion: example.crossplane.io/v1 8 kind: XBucket 9 mode: Pipeline 10 pipeline: 11 - step: patch-and-transform 12 functionRef: 13 name: function-patch-and-transform 14 input: 15 apiVersion: pt.fn.crossplane.io/v1beta1 16 kind: Resources 17 resources: 18 - name: storage-bucket 19 base: 20 apiVersion: s3.aws.upbound.io/v1beta1 21 kind: Bucket 22 patches: 23 - type: FromCompositeFieldPath 24 fromFieldPath: spec.bucketRegion 25 toFieldPath: spec.forProvider.region Important Crossplane doesn\u0026rsquo;t validate function input. It\u0026rsquo;s a good idea for a function to validate its own input. Function pipeline context Sometimes two functions in a pipeline want to share information with each other that isn\u0026rsquo;t desired state. Functions can use context for this. Any function can write to the pipeline context. Crossplane passes the context to all following functions. When Crossplane has called all functions it discards the pipeline context.\nCrossplane can write context too. If you enable the alpha composition environment feature Crossplane writes the environment to the top-level context field apiextensions.crossplane.io/environment.\nDisable composition functions Crossplane enables composition functions by default. Disable support for composition functions by disabling the beta feature flag in Crossplane with helm install --args.\n1helm install crossplane --namespace crossplane-system crossplane-stable/crossplane \\ 2 --create-namespace \\ 3 --set \u0026#34;args=\u0026#39;{--enable-composition-functions=false}\u0026#39;\u0026#34; The preceding Helm command installs Crossplane with the composition functions feature flag disabled. Confirm you have disabled composition functions by looking for a log line:\n1 kubectl -n crossplane-system logs -l app=crossplane 2{\u0026#34;level\u0026#34;:\u0026#34;info\u0026#34;,\u0026#34;ts\u0026#34;:1674535093.36186,\u0026#34;logger\u0026#34;:\u0026#34;crossplane\u0026#34;,\u0026#34;msg\u0026#34;:\u0026#34;Beta feature enabled\u0026#34;,\u0026#34;flag\u0026#34;:\u0026#34;EnableBetaCompositionFunctions\u0026#34;} If you don\u0026rsquo;t see the log line emitted when Crossplane starts, you have disabled composition functions.\n","title":"Composition Functions","url":"/v1.14/concepts/composition-functions/"},{"content":"Composition functions (or just functions, for short) are custom programs that template Crossplane resources. Crossplane calls composition functions to determine what resources it should create when you create a composite resource (XR). Read the concepts page to learn more about composition functions.\nYou can write a function to template resources using a general purpose programming language. Using a general purpose programming language allows a function to use more advanced logic to template resources, like loops and conditionals. This guide explains how to write a composition function in Go.\nImportant It helps to be familiar with how composition functions work before following this guide. Understand the steps This guide covers writing a composition function for an XBuckets composite resource (XR).\n1apiVersion: example.crossplane.io/v1 2kind: XBuckets 3metadata: 4 name: example-buckets 5spec: 6 region: us-east-2 7 names: 8 - crossplane-functions-example-a 9 - crossplane-functions-example-b 10 - crossplane-functions-example-c An XBuckets XR has a region and an array of bucket names. The function will create an Amazon Web Services (AWS) S3 bucket for each entry in the names array.\nTo write a function in Go you:\nInstall the tools you need to write the function Initialize the function from a template Edit the template to add the function\u0026rsquo;s logic Test the function end-to-end Build and push the function to a package repository This guide covers each of these steps in detail.\nInstall the tools you need to write the function To write a function in Go you need:\nGo 1.21 or newer. The guide uses Go 1.21. Docker Engine. This guide uses Engine v24. The Crossplane CLI v1.14 or newer. This guide uses Crossplane CLI v1.14. You don\u0026rsquo;t need access to a Kubernetes cluster or a Crossplane control plane to build or test a composition function.\nInitialize the function from a template Use the crossplane beta xpkg init command to initialize a new function. When you run this command it initializes your function using this GitHub repository as a template.\n1crossplane beta xpkg init function-xbuckets function-template-go -d function-xbuckets 2Initialized package \u0026#34;function-xbuckets\u0026#34; in directory \u0026#34;/home/negz/control/negz/function-xbuckets\u0026#34; from https://github.com/crossplane/function-template-go/tree/91a1a5eed21964ff98966d72cc6db6f089ad63f4 (main) The crossplane beta init xpkg command creates a directory named function-xbuckets. When you run the command the new directory should look like this:\n1ls function-xbuckets 2Dockerfile fn.go fn_test.go go.mod go.sum input/ LICENSE main.go package/ README.md renovate.json The fn.go file is where you add the function\u0026rsquo;s code. It\u0026rsquo;s useful to know about some other files in the template:\nmain.go runs the function. You don\u0026rsquo;t need to edit main.go. Dockerfile builds the function runtime. You don\u0026rsquo;t need to edit Dockerfile. The input directory defines the function\u0026rsquo;s input type. The package directory contains metadata used to build the function package. Tip In v1.14 of the Crossplane CLI crossplane beta xpkg init just clones a template GitHub repository. In a future release the command will automate tasks like replacing the template name with the new function\u0026rsquo;s name. See Crossplane issue #4941 for details.\nYou must make some changes before you start adding code:\nEdit package/crossplane.yaml to change the package\u0026rsquo;s name. Edit go.mod to change the Go module\u0026rsquo;s name. Name your package function-xbuckets.\nThe name of your module depends on where you want to keep your function code. If you push Go code to GitHub, you can use your GitHub username. For example module github.com/negz/function-xbuckets.\nThe function in this guide doesn\u0026rsquo;t use an input type. For this function you should delete the input and package/input directories.\nThe input directory defines a Go struct that a function can use to take input, using the input field from a Composition. The composition functions documentation explains how to pass an input to a composition function.\nThe package/input directory contains an OpenAPI schema generated from the structs in the input directory.\nImportant If you\u0026rsquo;re writing a function that does use an input type, don\u0026rsquo;t delete the input and package/input directories.\nInstead rename the type from Input to something more specific to your function. For example Function Patch and Transform names its input type Resources. Rename the API version too by updating the // +groupName comment at the top of input.go.\nWhen you edit files under the input directory you must update some generated files by running go generate. See input/generate.go for details.\n1go generate ./... Edit the template to add the function\u0026rsquo;s logic You add your function\u0026rsquo;s logic to the RunFunction method in fn.go. When you first open the file it contains a \u0026ldquo;hello world\u0026rdquo; function.\n1func (f *Function) RunFunction(_ context.Context, req *fnv1beta1.RunFunctionRequest) (*fnv1beta1.RunFunctionResponse, error) { 2\tf.log.Info(\u0026#34;Running Function\u0026#34;, \u0026#34;tag\u0026#34;, req.GetMeta().GetTag()) 3 4\trsp := response.To(req, response.DefaultTTL) 5 6\tin := \u0026amp;v1beta1.Input{} 7\tif err := request.GetInput(req, in); err != nil { 8\tresponse.Fatal(rsp, errors.Wrapf(err, \u0026#34;cannot get Function input from %T\u0026#34;, req)) 9\treturn rsp, nil 10\t} 11 12\tresponse.Normalf(rsp, \u0026#34;I was run with input %q\u0026#34;, in.Example) 13\treturn rsp, nil 14} All Go composition functions have a RunFunction method. Crossplane passes everything the function needs to run in a RunFunctionRequest struct. The function tells Crossplane what resources it should compose by returning a RunFunctionResponse struct.\nTip Crossplane generates the RunFunctionRequest and RunFunctionResponse structs using Protocol Buffers. You can find detailed schemas for RunFunctionRequest and RunFunctionResponse in the Buf Schema Registry. Edit the RunFunction method to replace it with this code.\n1func (f *Function) RunFunction(_ context.Context, req *fnv1beta1.RunFunctionRequest) (*fnv1beta1.RunFunctionResponse, error) { 2\trsp := response.To(req, response.DefaultTTL) 3 4\txr, err := request.GetObservedCompositeResource(req) 5\tif err != nil { 6\tresponse.Fatal(rsp, errors.Wrapf(err, \u0026#34;cannot get observed composite resource from %T\u0026#34;, req)) 7\treturn rsp, nil 8\t} 9 10\tregion, err := xr.Resource.GetString(\u0026#34;spec.region\u0026#34;) 11\tif err != nil { 12\tresponse.Fatal(rsp, errors.Wrapf(err, \u0026#34;cannot read spec.region field of %s\u0026#34;, xr.Resource.GetKind())) 13\treturn rsp, nil 14\t} 15 16\tnames, err := xr.Resource.GetStringArray(\u0026#34;spec.names\u0026#34;) 17\tif err != nil { 18\tresponse.Fatal(rsp, errors.Wrapf(err, \u0026#34;cannot read spec.names field of %s\u0026#34;, xr.Resource.GetKind())) 19\treturn rsp, nil 20\t} 21 22\tdesired, err := request.GetDesiredComposedResources(req) 23\tif err != nil { 24\tresponse.Fatal(rsp, errors.Wrapf(err, \u0026#34;cannot get desired resources from %T\u0026#34;, req)) 25\treturn rsp, nil 26\t} 27 28\t_ = v1beta1.AddToScheme(composed.Scheme) 29 30\tfor _, name := range names { 31\tb := \u0026amp;v1beta1.Bucket{ 32\tObjectMeta: metav1.ObjectMeta{ 33\tAnnotations: map[string]string{ 34\t\u0026#34;crossplane.io/external-name\u0026#34;: name, 35\t}, 36\t}, 37\tSpec: v1beta1.BucketSpec{ 38\tForProvider: v1beta1.BucketParameters{ 39\tRegion: ptr.To[string](region), 40\t}, 41\t}, 42\t} 43 44\tcd, err := composed.From(b) 45\tif err != nil { 46\tresponse.Fatal(rsp, errors.Wrapf(err, \u0026#34;cannot convert %T to %T\u0026#34;, b, \u0026amp;composed.Unstructured{})) 47\treturn rsp, nil 48\t} 49 50\tdesired[resource.Name(\u0026#34;xbuckets-\u0026#34;+name)] = \u0026amp;resource.DesiredComposed{Resource: cd} 51\t} 52 53\tif err := response.SetDesiredComposedResources(rsp, desired); err != nil { 54\tresponse.Fatal(rsp, errors.Wrapf(err, \u0026#34;cannot set desired composed resources in %T\u0026#34;, rsp)) 55\treturn rsp, nil 56\t} 57 58\treturn rsp, nil 59} Expand the below block to view the full fn.go, including imports and commentary explaining the function\u0026rsquo;s logic.\nThe full fn.go file 1package main 2 3import ( 4\t\u0026#34;context\u0026#34; 5 6\tmetav1 \u0026#34;k8s.io/apimachinery/pkg/apis/meta/v1\u0026#34; 7\t\u0026#34;k8s.io/utils/ptr\u0026#34; 8 9\t\u0026#34;github.com/upbound/provider-aws/apis/s3/v1beta1\u0026#34; 10 11\t\u0026#34;github.com/crossplane/function-sdk-go/errors\u0026#34; 12\t\u0026#34;github.com/crossplane/function-sdk-go/logging\u0026#34; 13\tfnv1beta1 \u0026#34;github.com/crossplane/function-sdk-go/proto/v1beta1\u0026#34; 14\t\u0026#34;github.com/crossplane/function-sdk-go/request\u0026#34; 15\t\u0026#34;github.com/crossplane/function-sdk-go/resource\u0026#34; 16\t\u0026#34;github.com/crossplane/function-sdk-go/resource/composed\u0026#34; 17\t\u0026#34;github.com/crossplane/function-sdk-go/response\u0026#34; 18) 19 20// Function returns whatever response you ask it to. 21type Function struct { 22\tfnv1beta1.UnimplementedFunctionRunnerServiceServer 23 24\tlog logging.Logger 25} 26 27// RunFunction observes an XBuckets composite resource (XR). It adds an S3 28// bucket to the desired state for every entry in the XR\u0026#39;s spec.names array. 29func (f *Function) RunFunction(_ context.Context, req *fnv1beta1.RunFunctionRequest) (*fnv1beta1.RunFunctionResponse, error) { 30\tf.log.Info(\u0026#34;Running Function\u0026#34;, \u0026#34;tag\u0026#34;, req.GetMeta().GetTag()) 31 32\t// Create a response to the request. This copies the desired state and 33\t// pipeline context from the request to the response. 34\trsp := response.To(req, response.DefaultTTL) 35 36\t// Read the observed XR from the request. Most functions use the observed XR 37\t// to add desired managed resources. 38\txr, err := request.GetObservedCompositeResource(req) 39\tif err != nil { 40\t// If the function can\u0026#39;t read the XR, the request is malformed. This 41\t// should never happen. The function returns a fatal result. This tells 42\t// Crossplane to stop running functions and return an error. 43\tresponse.Fatal(rsp, errors.Wrapf(err, \u0026#34;cannot get observed composite resource from %T\u0026#34;, req)) 44\treturn rsp, nil 45\t} 46 47\t// Create an updated logger with useful information about the XR. 48\tlog := f.log.WithValues( 49\t\u0026#34;xr-version\u0026#34;, xr.Resource.GetAPIVersion(), 50\t\u0026#34;xr-kind\u0026#34;, xr.Resource.GetKind(), 51\t\u0026#34;xr-name\u0026#34;, xr.Resource.GetName(), 52\t) 53 54\t// Get the region from the XR. The XR has getter methods like GetString, 55\t// GetBool, etc. You can use them to get values by their field path. 56\tregion, err := xr.Resource.GetString(\u0026#34;spec.region\u0026#34;) 57\tif err != nil { 58\tresponse.Fatal(rsp, errors.Wrapf(err, \u0026#34;cannot read spec.region field of %s\u0026#34;, xr.Resource.GetKind())) 59\treturn rsp, nil 60\t} 61 62\t// Get the array of bucket names from the XR. 63\tnames, err := xr.Resource.GetStringArray(\u0026#34;spec.names\u0026#34;) 64\tif err != nil { 65\tresponse.Fatal(rsp, errors.Wrapf(err, \u0026#34;cannot read spec.names field of %s\u0026#34;, xr.Resource.GetKind())) 66\treturn rsp, nil 67\t} 68 69\t// Get all desired composed resources from the request. The function will 70\t// update this map of resources, then save it. This get, update, set pattern 71\t// ensures the function keeps any resources added by other functions. 72\tdesired, err := request.GetDesiredComposedResources(req) 73\tif err != nil { 74\tresponse.Fatal(rsp, errors.Wrapf(err, \u0026#34;cannot get desired resources from %T\u0026#34;, req)) 75\treturn rsp, nil 76\t} 77 78\t// Add v1beta1 types (including Bucket) to the composed resource scheme. 79\t// composed.From uses this to automatically set apiVersion and kind. 80\t_ = v1beta1.AddToScheme(composed.Scheme) 81 82\t// Add a desired S3 bucket for each name. 83\tfor _, name := range names { 84\t// One advantage of writing a function in Go is strong typing. The 85\t// function can import and use managed resource types from the provider. 86\tb := \u0026amp;v1beta1.Bucket{ 87\tObjectMeta: metav1.ObjectMeta{ 88\t// Set the external name annotation to the desired bucket name. 89\t// This controls what the bucket will be named in AWS. 90\tAnnotations: map[string]string{ 91\t\u0026#34;crossplane.io/external-name\u0026#34;: name, 92\t}, 93\t}, 94\tSpec: v1beta1.BucketSpec{ 95\tForProvider: v1beta1.BucketParameters{ 96\t// Set the bucket\u0026#39;s region to the value read from the XR. 97\tRegion: ptr.To[string](region), 98\t}, 99\t}, 100\t} 101 102\t// Convert the bucket to the unstructured resource data format the SDK 103\t// uses to store desired composed resources. 104\tcd, err := composed.From(b) 105\tif err != nil { 106\tresponse.Fatal(rsp, errors.Wrapf(err, \u0026#34;cannot convert %T to %T\u0026#34;, b, \u0026amp;composed.Unstructured{})) 107\treturn rsp, nil 108\t} 109 110\t// Add the bucket to the map of desired composed resources. It\u0026#39;s 111\t// important that the function adds the same bucket every time it\u0026#39;s 112\t// called. It\u0026#39;s also important that the bucket is added with the same 113\t// resource.Name every time it\u0026#39;s called. The function prefixes the name 114\t// with \u0026#34;xbuckets-\u0026#34; to avoid collisions with any other composed 115\t// resources that might be in the desired resources map. 116\tdesired[resource.Name(\u0026#34;xbuckets-\u0026#34;+name)] = \u0026amp;resource.DesiredComposed{Resource: cd} 117\t} 118 119\t// Finally, save the updated desired composed resources to the response. 120\tif err := response.SetDesiredComposedResources(rsp, desired); err != nil { 121\tresponse.Fatal(rsp, errors.Wrapf(err, \u0026#34;cannot set desired composed resources in %T\u0026#34;, rsp)) 122\treturn rsp, nil 123\t} 124 125\t// Log what the function did. This will only appear in the function\u0026#39;s pod 126\t// logs. A function can use response.Normal and response.Warning to emit 127\t// Kubernetes events associated with the XR it\u0026#39;s operating on. 128\tlog.Info(\u0026#34;Added desired buckets\u0026#34;, \u0026#34;region\u0026#34;, region, \u0026#34;count\u0026#34;, len(names)) 129 130\treturn rsp, nil 131} This code:\nGets the observed composite resource from the RunFunctionRequest. Gets the region and bucket names from the observed composite resource. Adds one desired S3 bucket for each bucket name. Returns the desired S3 buckets in a RunFunctionResponse. The code uses the v1beta1.Bucket type from Upbound\u0026rsquo;s AWS S3 provider. One advantage of writing a function in Go is that you can compose resources using the same strongly typed structs Crossplane uses in its providers.\nYou must get the AWS Provider Go module to use this type:\n1go get github.com/upbound/provider-aws@v0.43.0 Crossplane provides a software development kit (SDK) for writing composition functions in Go. This function uses utilities from the SDK. In particular the request and response packages make working with the RunFunctionRequest and RunFunctionResponse types easier.\nTip Read the Go package documentation for the SDK. Test the function end-to-end You can test your function by adding unit tests, and by using the crossplane beta render command. It\u0026rsquo;s a good idea to do both.\nGo has rich support for unit testing. When you initialize a function from the template it adds some unit tests to fn_test.go. These tests follow Go\u0026rsquo;s recommendations. They use only pkg/testing from the Go standard library and google/go-cmp.\nTo add test cases, update the cases map in TestRunFunction. Expand the below block to view the full fn_test.go file for the function.\nThe full fn_test.go file 1package main 2 3import ( 4\t\u0026#34;context\u0026#34; 5\t\u0026#34;testing\u0026#34; 6\t\u0026#34;time\u0026#34; 7 8\t\u0026#34;github.com/google/go-cmp/cmp\u0026#34; 9\t\u0026#34;github.com/google/go-cmp/cmp/cmpopts\u0026#34; 10\t\u0026#34;google.golang.org/protobuf/testing/protocmp\u0026#34; 11\t\u0026#34;google.golang.org/protobuf/types/known/durationpb\u0026#34; 12 13\t\u0026#34;github.com/crossplane/crossplane-runtime/pkg/logging\u0026#34; 14 15\tfnv1beta1 \u0026#34;github.com/crossplane/function-sdk-go/proto/v1beta1\u0026#34; 16\t\u0026#34;github.com/crossplane/function-sdk-go/resource\u0026#34; 17) 18 19func TestRunFunction(t *testing.T) { 20\ttype args struct { 21\tctx context.Context 22\treq *fnv1beta1.RunFunctionRequest 23\t} 24\ttype want struct { 25\trsp *fnv1beta1.RunFunctionResponse 26\terr error 27\t} 28 29\tcases := map[string]struct { 30\treason string 31\targs args 32\twant want 33\t}{ 34\t\u0026#34;AddTwoBuckets\u0026#34;: { 35\treason: \u0026#34;The Function should add two buckets to the desired composed resources\u0026#34;, 36\targs: args{ 37\treq: \u0026amp;fnv1beta1.RunFunctionRequest{ 38\tObserved: \u0026amp;fnv1beta1.State{ 39\tComposite: \u0026amp;fnv1beta1.Resource{ 40\t// MustStructJSON is a handy way to provide mock 41\t// resources. 42\tResource: resource.MustStructJSON(`{ 43\t\u0026#34;apiVersion\u0026#34;: \u0026#34;example.crossplane.io/v1alpha1\u0026#34;, 44\t\u0026#34;kind\u0026#34;: \u0026#34;XBuckets\u0026#34;, 45\t\u0026#34;metadata\u0026#34;: { 46\t\u0026#34;name\u0026#34;: \u0026#34;test\u0026#34; 47\t}, 48\t\u0026#34;spec\u0026#34;: { 49\t\u0026#34;region\u0026#34;: \u0026#34;us-east-2\u0026#34;, 50\t\u0026#34;names\u0026#34;: [ 51\t\u0026#34;test-bucket-a\u0026#34;, 52\t\u0026#34;test-bucket-b\u0026#34; 53\t] 54\t} 55\t}`), 56\t}, 57\t}, 58\t}, 59\t}, 60\twant: want{ 61\trsp: \u0026amp;fnv1beta1.RunFunctionResponse{ 62\tMeta: \u0026amp;fnv1beta1.ResponseMeta{Ttl: durationpb.New(60 * time.Second)}, 63\tDesired: \u0026amp;fnv1beta1.State{ 64\tResources: map[string]*fnv1beta1.Resource{ 65\t\u0026#34;xbuckets-test-bucket-a\u0026#34;: {Resource: resource.MustStructJSON(`{ 66\t\u0026#34;apiVersion\u0026#34;: \u0026#34;s3.aws.upbound.io/v1beta1\u0026#34;, 67\t\u0026#34;kind\u0026#34;: \u0026#34;Bucket\u0026#34;, 68\t\u0026#34;metadata\u0026#34;: { 69\t\u0026#34;annotations\u0026#34;: { 70\t\u0026#34;crossplane.io/external-name\u0026#34;: \u0026#34;test-bucket-a\u0026#34; 71\t} 72\t}, 73\t\u0026#34;spec\u0026#34;: { 74\t\u0026#34;forProvider\u0026#34;: { 75\t\u0026#34;region\u0026#34;: \u0026#34;us-east-2\u0026#34; 76\t} 77\t} 78\t}`)}, 79\t\u0026#34;xbuckets-test-bucket-b\u0026#34;: {Resource: resource.MustStructJSON(`{ 80\t\u0026#34;apiVersion\u0026#34;: \u0026#34;s3.aws.upbound.io/v1beta1\u0026#34;, 81\t\u0026#34;kind\u0026#34;: \u0026#34;Bucket\u0026#34;, 82\t\u0026#34;metadata\u0026#34;: { 83\t\u0026#34;annotations\u0026#34;: { 84\t\u0026#34;crossplane.io/external-name\u0026#34;: \u0026#34;test-bucket-b\u0026#34; 85\t} 86\t}, 87\t\u0026#34;spec\u0026#34;: { 88\t\u0026#34;forProvider\u0026#34;: { 89\t\u0026#34;region\u0026#34;: \u0026#34;us-east-2\u0026#34; 90\t} 91\t} 92\t}`)}, 93\t}, 94\t}, 95\t}, 96\t}, 97\t}, 98\t} 99 100\tfor name, tc := range cases { 101\tt.Run(name, func(t *testing.T) { 102\tf := \u0026amp;Function{log: logging.NewNopLogger()} 103\trsp, err := f.RunFunction(tc.args.ctx, tc.args.req) 104 105\tif diff := cmp.Diff(tc.want.rsp, rsp, protocmp.Transform()); diff != \u0026#34;\u0026#34; { 106\tt.Errorf(\u0026#34;%s\\nf.RunFunction(...): -want rsp, +got rsp:\\n%s\u0026#34;, tc.reason, diff) 107\t} 108 109\tif diff := cmp.Diff(tc.want.err, err, cmpopts.EquateErrors()); diff != \u0026#34;\u0026#34; { 110\tt.Errorf(\u0026#34;%s\\nf.RunFunction(...): -want err, +got err:\\n%s\u0026#34;, tc.reason, diff) 111\t} 112\t}) 113\t} 114} Run the unit tests using the go test command:\n1go test -v -cover . 2=== RUN TestRunFunction 3=== RUN TestRunFunction/AddTwoBuckets 4--- PASS: TestRunFunction (0.00s) 5 --- PASS: TestRunFunction/AddTwoBuckets (0.00s) 6PASS 7coverage: 52.6% of statements 8ok github.com/negz/function-xbuckets 0.016s coverage: 52.6% of statements You can preview the output of a Composition that uses this function using the Crossplane CLI. You don\u0026rsquo;t need a Crossplane control plane to do this.\nCreate a directory under function-xbuckets named examples, and add the three files xr.yaml, composition.yaml, and functions.yaml.\nThe xr.yaml, composition.yaml and function.yaml files You can recreate the output below using by running crossplane beta render with these files.\nThe xr.yaml file contains the composite resource to render:\n1apiVersion: example.crossplane.io/v1 2kind: XBuckets 3metadata: 4 name: example-buckets 5spec: 6 region: us-east-2 7 names: 8 - crossplane-functions-example-a 9 - crossplane-functions-example-b 10 - crossplane-functions-example-c The composition.yaml file contains the Composition to use to render the composite resource:\n1apiVersion: apiextensions.crossplane.io/v1 2kind: Composition 3metadata: 4 name: create-buckets 5spec: 6 compositeTypeRef: 7 apiVersion: example.crossplane.io/v1 8 kind: XBuckets 9 mode: Pipeline 10 pipeline: 11 - step: create-buckets 12 functionRef: 13 name: function-xbuckets The functions.yaml file contains the Functions the Composition references in its pipeline steps:\n1apiVersion: pkg.crossplane.io/v1beta1 2kind: Function 3metadata: 4 name: function-xbuckets 5 annotations: 6 render.crossplane.io/runtime: Development 7spec: 8 # The CLI ignores this package when using the Development runtime. 9 # You can set it to any value. 10 package: xpkg.upbound.io/negz/function-xbuckets:v0.1.0 Note that the Function in functions.yaml uses the Development runtime. This tells crossplane beta render that your function is running locally. It connects to your locally running function instead of using Docker to pull and run the function.\n1apiVersion: pkg.crossplane.io/v1beta1 2kind: Function 3metadata: 4 name: function-xbuckets 5 annotations: 6 render.crossplane.io/runtime: Development Use go run to run your function locally. The --insecure flag tells the function to run without encryption or authentication. You should only use it during testing and development. The --debug flag tells the function to print debug log statements.\n1go run . --insecure --debug In a separate terminal, run crossplane beta render.\n1crossplane beta render xr.yaml composition.yaml functions.yaml This command calls your function. In the terminal where your function is running you should now see log output:\n1go run . --insecure --debug 22023-10-31T16:17:32.158-0700 INFO function-xbuckets/fn.go:29 Running Function {\u0026#34;tag\u0026#34;: \u0026#34;\u0026#34;} 32023-10-31T16:17:32.159-0700 INFO function-xbuckets/fn.go:125 Added desired buckets {\u0026#34;xr-version\u0026#34;: \u0026#34;example.crossplane.io/v1\u0026#34;, \u0026#34;xr-kind\u0026#34;: \u0026#34;XBuckets\u0026#34;, \u0026#34;xr-name\u0026#34;: \u0026#34;example-buckets\u0026#34;, \u0026#34;region\u0026#34;: \u0026#34;us-east-2\u0026#34;, \u0026#34;count\u0026#34;: 3} The crossplane beta render command prints the desired resources the function returns.\n1--- 2apiVersion: example.crossplane.io/v1 3kind: XBuckets 4metadata: 5 name: example-buckets 6--- 7apiVersion: s3.aws.upbound.io/v1beta1 8kind: Bucket 9metadata: 10 annotations: 11 crossplane.io/composition-resource-name: xbuckets-crossplane-functions-example-b 12 crossplane.io/external-name: crossplane-functions-example-b 13 generateName: example-buckets- 14 labels: 15 crossplane.io/composite: example-buckets 16 ownerReferences: 17 # Omitted for brevity 18spec: 19 forProvider: 20 region: us-east-2 21--- 22apiVersion: s3.aws.upbound.io/v1beta1 23kind: Bucket 24metadata: 25 annotations: 26 crossplane.io/composition-resource-name: xbuckets-crossplane-functions-example-c 27 crossplane.io/external-name: crossplane-functions-example-c 28 generateName: example-buckets- 29 labels: 30 crossplane.io/composite: example-buckets 31 ownerReferences: 32 # Omitted for brevity 33spec: 34 forProvider: 35 region: us-east-2 36--- 37apiVersion: s3.aws.upbound.io/v1beta1 38kind: Bucket 39metadata: 40 annotations: 41 crossplane.io/composition-resource-name: xbuckets-crossplane-functions-example-a 42 crossplane.io/external-name: crossplane-functions-example-a 43 generateName: example-buckets- 44 labels: 45 crossplane.io/composite: example-buckets 46 ownerReferences: 47 # Omitted for brevity 48spec: 49 forProvider: 50 region: us-east-2 Tip Read the composition functions documentation to learn more about testing composition functions. Build and push the function to a package registry You build a function in two stages. First you build the function\u0026rsquo;s runtime. This is the Open Container Initiative (OCI) image Crossplane uses to run your function. You then embed that runtime in a package, and push it to a package registry. The Crossplane CLI uses xpkg.upbound.io as its default package registry.\nA function supports a single platform, like linux/amd64, by default. You can support multiple platforms by building a runtime and package for each platform, then pushing all the packages to a single tag in the registry.\nPushing your function to a registry allows you to use your function in a Crossplane control plane. See the composition functions documentation. to learn how to use a function in a control plane.\nUse Docker to build a runtime for each platform.\n1docker build . --quiet --platform=linux/amd64 --tag runtime-amd64 2sha256:fdf40374cc6f0b46191499fbc1dbbb05ddb76aca854f69f2912e580cfe624b4b 1docker build . --quiet --platform=linux/arm64 --tag runtime-arm64 2sha256:cb015ceabf46d2a55ccaeebb11db5659a2fb5e93de36713364efcf6d699069af Tip You can use whatever tag you want. There\u0026rsquo;s no need to push the runtime images to a registry. The tag is only used to tell crossplane xpkg build what runtime to embed. Use the Crossplane CLI to build a package for each platform. Each package embeds a runtime image.\nThe --package-root flag specifies the package directory, which contains crossplane.yaml. This includes metadata about the package.\nThe --embed-runtime-image flag specifies the runtime image tag built using Docker.\nThe --package-file flag specifies specifies where to write the package file to disk. Crossplane package files use the extension .xpkg.\n1crossplane xpkg build \\ 2 --package-root=package \\ 3 --embed-runtime-image=runtime-amd64 \\ 4 --package-file=function-amd64.xpkg 1crossplane xpkg build \\ 2 --package-root=package \\ 3 --embed-runtime-image=runtime-arm64 \\ 4 --package-file=function-arm64.xpkg Tip Crossplane packages are special OCI images. Read more about packages in the packages documentation. Push both package files to a registry. Pushing both files to one tag in the registry creates a multi-platform package that runs on both linux/arm64 and linux/amd64 hosts.\n1crossplane xpkg push \\ 2 --package-files=function-amd64.xpkg,function-arm64.xpkg \\ 3 negz/function-xbuckets:v0.1.0 Tip If you push the function to a GitHub repository the template automatically sets up continuous integration (CI) using GitHub Actions. The CI workflow will lint, test, and build your function. You can see how the template configures CI by reading .github/workflows/ci.yaml.\nThe CI workflow can automatically push packages to xpkg.upbound.io. For this to work you must create a repository at https://marketplace.upbound.io. Give the CI workflow access to push to the Marketplace by creating an API token and adding it to your repository. Save your API token access ID as a secret named XPKG_ACCESS_ID and your API token as a secret named XPKG_TOKEN.\n","title":"Write a Composition Function in Go","url":"/knowledge-base/guides/write-a-composition-function-in-go/"},{"content":"A Usage is a Crossplane resource that defines a usage relationship for a Managed Resource or a Composite Resource. Two main use cases for the Usages are as follows:\nProtecting a resource from accidental deletion. Deletion ordering by ensuring that a resource isn\u0026rsquo;t deleted before the deletion of its dependent resources. See the section Usage for Deletion Protection for the first use case and the section Usage for Deletion Ordering for the second one.\nEnable usages Usages are an alpha feature. Alpha features aren\u0026rsquo;t enabled by default.\nEnable Usage support by changing the Crossplane pod setting and enabling\n--enable-usages argument.\n1$ kubectl edit deployment crossplane --namespace crossplane-system 2apiVersion: apps/v1 3kind: Deployment 4spec: 5# Removed for brevity 6 template: 7 spec: 8 containers: 9 - args: 10 - core 11 - start 12 - --enable-usages Tip The Crossplane install guide describes enabling feature flags like --enable-usages with Helm. Create a usage A Usage spec has a mandatory of field for defining the resource in use or protected. The reason field defines the reason for protection and the by field\ndefines the using resource. Both fields are optional, but at least one of them must be provided.\nImportant Usage relationships can be defined between Managed Resources and Composites.\nHowever, a Composite as the using resource (spec.by) would be ineffective unless the compositeDeletePolicy Foreground is used because it wouldn\u0026rsquo;t block deletion of its child resources before its own deletion with the default deletion policy Background.\nUsage for deletion protection The following example prevents the deletion of the my-database resource by rejecting any deletion request with the reason defined.\n1apiVersion: apiextensions.crossplane.io/v1alpha1 2kind: Usage 3metadata: 4 name: protect-production-database 5spec: 6 of: 7 apiVersion: rds.aws.upbound.io/v1beta1 8 kind: Instance 9 resourceRef: 10 name: my-database 11 reason: \u0026#34;Production Database - should never be deleted!\u0026#34; Usage for deletion ordering The following example prevents the deletion of my-cluster resource by rejecting any deletion request before the deletion of my-prometheus-chart resource.\n1apiVersion: apiextensions.crossplane.io/v1alpha1 2kind: Usage 3metadata: 4 name: release-uses-cluster 5spec: 6 of: 7 apiVersion: eks.upbound.io/v1beta1 8 kind: Cluster 9 resourceRef: 10 name: my-cluster 11 by: 12 apiVersion: helm.crossplane.io/v1beta1 13 kind: Release 14 resourceRef: 15 name: my-prometheus-chart Using selectors with usages Usages can use selectors to define the resource in use or the using one. This enables using labels or matching controller references to define resource instead of providing the resource name.\n1apiVersion: apiextensions.crossplane.io/v1alpha1 2kind: Usage 3metadata: 4 name: release-uses-cluster 5spec: 6 of: 7 apiVersion: eks.upbound.io/v1beta1 8 kind: Cluster 9 resourceSelector: 10 matchControllerRef: false # default, and could be omitted 11 matchLabels: 12 foo: bar 13 by: 14 apiVersion: helm.crossplane.io/v1beta1 15 kind: Release 16 resourceSelector: 17 matchLabels: 18 baz: qux After the Usage controller resolves the selectors, it persists the resource name in the resourceRef.name field. The following example shows the Usage resource after the resolution of selectors.\nImportant The selectors are resolved only once. If there are more than one matches, a random resource is selected from the list of matched resources.\n1apiVersion: apiextensions.crossplane.io/v1alpha1 2kind: Usage 3metadata: 4 name: release-uses-cluster 5spec: 6 of: 7 apiVersion: eks.upbound.io/v1beta1 8 kind: Cluster 9 resourceRef: 10 name: my-cluster 11 resourceSelector: 12 matchLabels: 13 foo: bar 14 by: 15 apiVersion: helm.crossplane.io/v1beta1 16 kind: Release 17 resourceRef: 18 name: my-cluster 19 resourceSelector: 20 matchLabels: 21 baz: qux Usage in a Composition A typical use case for Usages is to define a deletion ordering between the resources in a Composition. The Usages support matching controller reference in selectors to ensures that the matching resource is in the same composite resource in the same way as cross-resource referencing.\nThe following example shows a Composition that defines a deletion ordering between a Cluster and a Release resource. The Usage blocks deletion of the Cluster resource until the Release resource is successfully deleted.\n1apiVersion: apiextensions.crossplane.io/v1 2kind: Composition 3spec: 4 resources: 5 - name: cluster 6 base: 7 apiVersion: container.gcp.upbound.io/v1beta1 8 kind: Cluster 9 # Removed for brevity 10 - name: release 11 base: 12 apiVersion: helm.crossplane.io/v1beta1 13 kind: Release 14 # Removed for brevity 15 - name: release-uses-cluster 16 base: 17 apiVersion: apiextensions.crossplane.io/v1alpha1 18 kind: Usage 19 spec: 20 of: 21 apiVersion: container.gcp.upbound.io/v1beta1 22 kind: Cluster 23 resourceSelector: 24 matchControllerRef: true 25 by: 26 apiVersion: helm.crossplane.io/v1beta1 27 kind: Release 28 resourceSelector: 29 matchControllerRef: true Tip When there are multiple resources of same type in a Composition, the Usage resource must uniquely identify the resource in use or the using one. This could be accomplished by using extra labels and combining matchControllerRef with a matchLabels selector. Another alternative is patching resourceRef.name directly with the help of ToCompositeFieldPath and FromCompositeFieldPath or ToEnvironmentFieldPath and FromEnvironmentFieldPath type patches.\n","title":"Usages","url":"/v1.14/concepts/usages/"},{"content":"Connect Crossplane to AWS to create and manage cloud resources from Kubernetes with the Upbound AWS Provider.\nThis guide is in two parts:\nPart 1 walks through installing Crossplane, configuring the provider to authenticate to AWS and creating a Managed Resource in AWS directly from your Kubernetes cluster. This shows Crossplane can communicate with AWS. Part 2 shows how to build and access a custom API with Crossplane. Prerequisites This quickstart requires:\na Kubernetes cluster with at least 2 GB of RAM permissions to create pods and secrets in the Kubernetes cluster Helm version v3.2.0 or later an AWS account with permissions to create an S3 storage bucket AWS access keys Install Crossplane Crossplane installs into an existing Kubernetes cluster.\nTip If you don\u0026rsquo;t have a Kubernetes cluster create one locally with Kind. Install the Crossplane Helm chart Helm enables Crossplane to install all its Kubernetes components through a Helm Chart.\nEnable the Crossplane Helm Chart repository:\n1helm repo add \\ 2crossplane-stable https://charts.crossplane.io/stable 3helm repo update Run the Helm dry-run to see all the Crossplane components Helm installs.\n1helm install crossplane \\ 2crossplane-stable/crossplane \\ 3--dry-run --debug \\ 4--namespace crossplane-system \\ 5--create-namespace View the Helm dry-run 1helm install crossplane \\ 2crossplane-stable/crossplane \\ 3--dry-run --debug \\ 4--namespace crossplane-system \\ 5--create-namespace 6install.go:200: [debug] Original chart version: \u0026#34;\u0026#34; 7install.go:217: [debug] CHART PATH: /home/vagrant/.cache/helm/repository/crossplane-1.13.0.tgz 8 9NAME: crossplane 10LAST DEPLOYED: Fri Jul 28 13:57:41 2023 11NAMESPACE: crossplane-system 12STATUS: pending-install 13REVISION: 1 14TEST SUITE: None 15USER-SUPPLIED VALUES: 16{} 17 18COMPUTED VALUES: 19affinity: {} 20args: [] 21configuration: 22 packages: [] 23customAnnotations: {} 24customLabels: {} 25deploymentStrategy: RollingUpdate 26extraEnvVarsCrossplane: {} 27extraEnvVarsRBACManager: {} 28extraVolumeMountsCrossplane: {} 29extraVolumesCrossplane: {} 30hostNetwork: false 31image: 32 pullPolicy: IfNotPresent 33 repository: crossplane/crossplane 34 tag: \u0026#34;\u0026#34; 35imagePullSecrets: {} 36leaderElection: true 37metrics: 38 enabled: false 39nodeSelector: {} 40packageCache: 41 configMap: \u0026#34;\u0026#34; 42 medium: \u0026#34;\u0026#34; 43 pvc: \u0026#34;\u0026#34; 44 sizeLimit: 20Mi 45podSecurityContextCrossplane: {} 46podSecurityContextRBACManager: {} 47priorityClassName: \u0026#34;\u0026#34; 48provider: 49 packages: [] 50rbacManager: 51 affinity: {} 52 args: [] 53 deploy: true 54 leaderElection: true 55 managementPolicy: Basic 56 nodeSelector: {} 57 replicas: 1 58 skipAggregatedClusterRoles: false 59 tolerations: [] 60registryCaBundleConfig: 61 key: \u0026#34;\u0026#34; 62 name: \u0026#34;\u0026#34; 63replicas: 1 64resourcesCrossplane: 65 limits: 66 cpu: 100m 67 memory: 512Mi 68 requests: 69 cpu: 100m 70 memory: 256Mi 71resourcesRBACManager: 72 limits: 73 cpu: 100m 74 memory: 512Mi 75 requests: 76 cpu: 100m 77 memory: 256Mi 78securityContextCrossplane: 79 allowPrivilegeEscalation: false 80 readOnlyRootFilesystem: true 81 runAsGroup: 65532 82 runAsUser: 65532 83securityContextRBACManager: 84 allowPrivilegeEscalation: false 85 readOnlyRootFilesystem: true 86 runAsGroup: 65532 87 runAsUser: 65532 88serviceAccount: 89 customAnnotations: {} 90tolerations: [] 91webhooks: 92 enabled: true 93 94HOOKS: 95MANIFEST: 96--- 97# Source: crossplane/templates/rbac-manager-serviceaccount.yaml 98apiVersion: v1 99kind: ServiceAccount 100metadata: 101 name: rbac-manager 102 namespace: crossplane-system 103 labels: 104 app: crossplane 105 helm.sh/chart: crossplane-1.13.0 106 app.kubernetes.io/managed-by: Helm 107 app.kubernetes.io/component: cloud-infrastructure-controller 108 app.kubernetes.io/part-of: crossplane 109 app.kubernetes.io/name: crossplane 110 app.kubernetes.io/instance: crossplane 111 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 112--- 113# Source: crossplane/templates/serviceaccount.yaml 114apiVersion: v1 115kind: ServiceAccount 116metadata: 117 name: crossplane 118 namespace: crossplane-system 119 labels: 120 app: crossplane 121 helm.sh/chart: crossplane-1.13.0 122 app.kubernetes.io/managed-by: Helm 123 app.kubernetes.io/component: cloud-infrastructure-controller 124 app.kubernetes.io/part-of: crossplane 125 app.kubernetes.io/name: crossplane 126 app.kubernetes.io/instance: crossplane 127 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 128--- 129# Source: crossplane/templates/secret.yaml 130# The reason this is created empty and filled by the init container is that it\u0026#39;s 131# mounted by the actual container, so if it wasn\u0026#39;t created by Helm, then the 132# deployment wouldn\u0026#39;t be deployed at all with secret to mount not found error. 133# In addition, Helm would delete this secret after uninstallation so the new 134# installation of Crossplane would use its own certificate. 135apiVersion: v1 136kind: Secret 137metadata: 138 name: webhook-tls-secret 139 namespace: crossplane-system 140type: Opaque 141--- 142# Source: crossplane/templates/clusterrole.yaml 143apiVersion: rbac.authorization.k8s.io/v1 144kind: ClusterRole 145metadata: 146 name: crossplane 147 labels: 148 app: crossplane 149 helm.sh/chart: crossplane-1.13.0 150 app.kubernetes.io/managed-by: Helm 151 app.kubernetes.io/component: cloud-infrastructure-controller 152 app.kubernetes.io/part-of: crossplane 153 app.kubernetes.io/name: crossplane 154 app.kubernetes.io/instance: crossplane 155 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 156aggregationRule: 157 clusterRoleSelectors: 158 - matchLabels: 159 rbac.crossplane.io/aggregate-to-crossplane: \u0026#34;true\u0026#34; 160--- 161# Source: crossplane/templates/clusterrole.yaml 162apiVersion: rbac.authorization.k8s.io/v1 163kind: ClusterRole 164metadata: 165 name: crossplane:system:aggregate-to-crossplane 166 labels: 167 app: crossplane 168 helm.sh/chart: crossplane-1.13.0 169 app.kubernetes.io/managed-by: Helm 170 app.kubernetes.io/component: cloud-infrastructure-controller 171 app.kubernetes.io/part-of: crossplane 172 app.kubernetes.io/name: crossplane 173 app.kubernetes.io/instance: crossplane 174 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 175 crossplane.io/scope: \u0026#34;system\u0026#34; 176 rbac.crossplane.io/aggregate-to-crossplane: \u0026#34;true\u0026#34; 177rules: 178- apiGroups: 179 - \u0026#34;\u0026#34; 180 resources: 181 - events 182 verbs: 183 - create 184 - update 185 - patch 186 - delete 187- apiGroups: 188 - apiextensions.k8s.io 189 resources: 190 - customresourcedefinitions 191 verbs: 192 - \u0026#34;*\u0026#34; 193- apiGroups: 194 - \u0026#34;\u0026#34; 195 resources: 196 - secrets 197 verbs: 198 - get 199 - list 200 - watch 201 - create 202 - update 203 - patch 204 - delete 205- apiGroups: 206 - \u0026#34;\u0026#34; 207 resources: 208 - serviceaccounts 209 - services 210 verbs: 211 - \u0026#34;*\u0026#34; 212- apiGroups: 213 - apiextensions.crossplane.io 214 - pkg.crossplane.io 215 - secrets.crossplane.io 216 resources: 217 - \u0026#34;*\u0026#34; 218 verbs: 219 - \u0026#34;*\u0026#34; 220- apiGroups: 221 - extensions 222 - apps 223 resources: 224 - deployments 225 verbs: 226 - get 227 - list 228 - create 229 - update 230 - patch 231 - delete 232 - watch 233- apiGroups: 234 - \u0026#34;\u0026#34; 235 - coordination.k8s.io 236 resources: 237 - configmaps 238 - leases 239 verbs: 240 - get 241 - list 242 - create 243 - update 244 - patch 245 - watch 246 - delete 247- apiGroups: 248 - admissionregistration.k8s.io 249 resources: 250 - validatingwebhookconfigurations 251 - mutatingwebhookconfigurations 252 verbs: 253 - get 254 - list 255 - create 256 - update 257 - patch 258 - watch 259 - delete 260--- 261# Source: crossplane/templates/rbac-manager-allowed-provider-permissions.yaml 262apiVersion: rbac.authorization.k8s.io/v1 263kind: ClusterRole 264metadata: 265 name: crossplane:allowed-provider-permissions 266 labels: 267 app: crossplane 268 helm.sh/chart: crossplane-1.13.0 269 app.kubernetes.io/managed-by: Helm 270 app.kubernetes.io/component: cloud-infrastructure-controller 271 app.kubernetes.io/part-of: crossplane 272 app.kubernetes.io/name: crossplane 273 app.kubernetes.io/instance: crossplane 274 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 275aggregationRule: 276 clusterRoleSelectors: 277 - matchLabels: 278 rbac.crossplane.io/aggregate-to-allowed-provider-permissions: \u0026#34;true\u0026#34; 279--- 280# Source: crossplane/templates/rbac-manager-clusterrole.yaml 281apiVersion: rbac.authorization.k8s.io/v1 282kind: ClusterRole 283metadata: 284 name: crossplane-rbac-manager 285 labels: 286 app: crossplane 287 helm.sh/chart: crossplane-1.13.0 288 app.kubernetes.io/managed-by: Helm 289 app.kubernetes.io/component: cloud-infrastructure-controller 290 app.kubernetes.io/part-of: crossplane 291 app.kubernetes.io/name: crossplane 292 app.kubernetes.io/instance: crossplane 293 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 294rules: 295- apiGroups: 296 - \u0026#34;\u0026#34; 297 resources: 298 - events 299 verbs: 300 - create 301 - update 302 - patch 303 - delete 304- apiGroups: 305 - \u0026#34;\u0026#34; 306 resources: 307 - namespaces 308 - serviceaccounts 309 verbs: 310 - get 311 - list 312 - watch 313# The RBAC manager creates a series of RBAC roles for each namespace it sees. 314# These RBAC roles are controlled (in the owner reference sense) by the namespace. 315# The RBAC manager needs permission to set finalizers on Namespaces in order to 316# create resources that block their deletion when the 317# OwnerReferencesPermissionEnforcement admission controller is enabled. 318# See https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#ownerreferencespermissionenforcement 319- apiGroups: 320 - \u0026#34;\u0026#34; 321 resources: 322 - namespaces/finalizers 323 verbs: 324 - update 325- apiGroups: 326 - apiextensions.crossplane.io 327 resources: 328 - compositeresourcedefinitions 329 verbs: 330 - get 331 - list 332 - watch 333# The RBAC manager creates a series of RBAC cluster roles for each XRD it sees. 334# These cluster roles are controlled (in the owner reference sense) by the XRD. 335# The RBAC manager needs permission to set finalizers on XRDs in order to 336# create resources that block their deletion when the 337# OwnerReferencesPermissionEnforcement admission controller is enabled. 338# See https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#ownerreferencespermissionenforcement 339- apiGroups: 340 - apiextensions.crossplane.io 341 resources: 342 - compositeresourcedefinitions/finalizers 343 verbs: 344 - update 345- apiGroups: 346 - pkg.crossplane.io 347 resources: 348 - providerrevisions 349 verbs: 350 - get 351 - list 352 - watch 353# The RBAC manager creates a series of RBAC cluster roles for each ProviderRevision 354# it sees. These cluster roles are controlled (in the owner reference sense) by the 355# ProviderRevision. The RBAC manager needs permission to set finalizers on 356# ProviderRevisions in order to create resources that block their deletion when the 357# OwnerReferencesPermissionEnforcement admission controller is enabled. 358# See https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#ownerreferencespermissionenforcement 359- apiGroups: 360 - pkg.crossplane.io 361 resources: 362 - providerrevisions/finalizers 363 verbs: 364 - update 365- apiGroups: 366 - apiextensions.k8s.io 367 resources: 368 - customresourcedefinitions 369 verbs: 370 - get 371 - list 372 - watch 373- apiGroups: 374 - rbac.authorization.k8s.io 375 resources: 376 - clusterroles 377 - roles 378 verbs: 379 - get 380 - list 381 - watch 382 - create 383 - update 384 - patch 385 # The RBAC manager may grant access it does not have. 386 - escalate 387- apiGroups: 388 - rbac.authorization.k8s.io 389 resources: 390 - clusterroles 391 verbs: 392 - bind 393- apiGroups: 394 - rbac.authorization.k8s.io 395 resources: 396 - clusterrolebindings 397 verbs: 398 - \u0026#34;*\u0026#34; 399- apiGroups: 400 - \u0026#34;\u0026#34; 401 - coordination.k8s.io 402 resources: 403 - configmaps 404 - leases 405 verbs: 406 - get 407 - list 408 - create 409 - update 410 - patch 411 - watch 412 - delete 413--- 414# Source: crossplane/templates/rbac-manager-managed-clusterroles.yaml 415apiVersion: rbac.authorization.k8s.io/v1 416kind: ClusterRole 417metadata: 418 name: crossplane-admin 419 labels: 420 app: crossplane 421 helm.sh/chart: crossplane-1.13.0 422 app.kubernetes.io/managed-by: Helm 423 app.kubernetes.io/component: cloud-infrastructure-controller 424 app.kubernetes.io/part-of: crossplane 425 app.kubernetes.io/name: crossplane 426 app.kubernetes.io/instance: crossplane 427 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 428aggregationRule: 429 clusterRoleSelectors: 430 - matchLabels: 431 rbac.crossplane.io/aggregate-to-admin: \u0026#34;true\u0026#34; 432--- 433# Source: crossplane/templates/rbac-manager-managed-clusterroles.yaml 434apiVersion: rbac.authorization.k8s.io/v1 435kind: ClusterRole 436metadata: 437 name: crossplane-edit 438 labels: 439 app: crossplane 440 helm.sh/chart: crossplane-1.13.0 441 app.kubernetes.io/managed-by: Helm 442 app.kubernetes.io/component: cloud-infrastructure-controller 443 app.kubernetes.io/part-of: crossplane 444 app.kubernetes.io/name: crossplane 445 app.kubernetes.io/instance: crossplane 446 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 447aggregationRule: 448 clusterRoleSelectors: 449 - matchLabels: 450 rbac.crossplane.io/aggregate-to-edit: \u0026#34;true\u0026#34; 451--- 452# Source: crossplane/templates/rbac-manager-managed-clusterroles.yaml 453apiVersion: rbac.authorization.k8s.io/v1 454kind: ClusterRole 455metadata: 456 name: crossplane-view 457 labels: 458 app: crossplane 459 helm.sh/chart: crossplane-1.13.0 460 app.kubernetes.io/managed-by: Helm 461 app.kubernetes.io/component: cloud-infrastructure-controller 462 app.kubernetes.io/part-of: crossplane 463 app.kubernetes.io/name: crossplane 464 app.kubernetes.io/instance: crossplane 465 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 466aggregationRule: 467 clusterRoleSelectors: 468 - matchLabels: 469 rbac.crossplane.io/aggregate-to-view: \u0026#34;true\u0026#34; 470--- 471# Source: crossplane/templates/rbac-manager-managed-clusterroles.yaml 472apiVersion: rbac.authorization.k8s.io/v1 473kind: ClusterRole 474metadata: 475 name: crossplane-browse 476 labels: 477 app: crossplane 478 helm.sh/chart: crossplane-1.13.0 479 app.kubernetes.io/managed-by: Helm 480 app.kubernetes.io/component: cloud-infrastructure-controller 481 app.kubernetes.io/part-of: crossplane 482 app.kubernetes.io/name: crossplane 483 app.kubernetes.io/instance: crossplane 484 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 485aggregationRule: 486 clusterRoleSelectors: 487 - matchLabels: 488 rbac.crossplane.io/aggregate-to-browse: \u0026#34;true\u0026#34; 489--- 490# Source: crossplane/templates/rbac-manager-managed-clusterroles.yaml 491apiVersion: rbac.authorization.k8s.io/v1 492kind: ClusterRole 493metadata: 494 name: crossplane:aggregate-to-admin 495 labels: 496 rbac.crossplane.io/aggregate-to-admin: \u0026#34;true\u0026#34; 497 app: crossplane 498 helm.sh/chart: crossplane-1.13.0 499 app.kubernetes.io/managed-by: Helm 500 app.kubernetes.io/component: cloud-infrastructure-controller 501 app.kubernetes.io/part-of: crossplane 502 app.kubernetes.io/name: crossplane 503 app.kubernetes.io/instance: crossplane 504 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 505rules: 506# Crossplane administrators have access to view events. 507- apiGroups: [\u0026#34;\u0026#34;] 508 resources: [events] 509 verbs: [get, list, watch] 510# Crossplane administrators must create provider credential secrets, and may 511# need to read or otherwise interact with connection secrets. They may also need 512# to create or annotate namespaces. 513- apiGroups: [\u0026#34;\u0026#34;] 514 resources: [secrets, namespaces] 515 verbs: [\u0026#34;*\u0026#34;] 516# Crossplane administrators have access to view the roles that they may be able 517# to grant to other subjects. 518- apiGroups: [rbac.authorization.k8s.io] 519 resources: [clusterroles, roles] 520 verbs: [get, list, watch] 521# Crossplane administrators have access to grant the access they have to other 522# subjects. 523- apiGroups: [rbac.authorization.k8s.io] 524 resources: [clusterrolebindings, rolebindings] 525 verbs: [\u0026#34;*\u0026#34;] 526# Crossplane administrators have full access to built in Crossplane types. 527- apiGroups: 528 - apiextensions.crossplane.io 529 resources: [\u0026#34;*\u0026#34;] 530 verbs: [\u0026#34;*\u0026#34;] 531- apiGroups: 532 - pkg.crossplane.io 533 resources: [locks, providers, configurations, providerrevisions, configurationrevisions] 534 verbs: [\u0026#34;*\u0026#34;] 535# Crossplane administrators have access to view CRDs in order to debug XRDs. 536- apiGroups: [apiextensions.k8s.io] 537 resources: [customresourcedefinitions] 538 verbs: [get, list, watch] 539--- 540# Source: crossplane/templates/rbac-manager-managed-clusterroles.yaml 541apiVersion: rbac.authorization.k8s.io/v1 542kind: ClusterRole 543metadata: 544 name: crossplane:aggregate-to-edit 545 labels: 546 rbac.crossplane.io/aggregate-to-edit: \u0026#34;true\u0026#34; 547 app: crossplane 548 helm.sh/chart: crossplane-1.13.0 549 app.kubernetes.io/managed-by: Helm 550 app.kubernetes.io/component: cloud-infrastructure-controller 551 app.kubernetes.io/part-of: crossplane 552 app.kubernetes.io/name: crossplane 553 app.kubernetes.io/instance: crossplane 554 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 555rules: 556# Crossplane editors have access to view events. 557- apiGroups: [\u0026#34;\u0026#34;] 558 resources: [events] 559 verbs: [get, list, watch] 560# Crossplane editors must create provider credential secrets, and may need to 561# read or otherwise interact with connection secrets. 562- apiGroups: [\u0026#34;\u0026#34;] 563 resources: [secrets] 564 verbs: [\u0026#34;*\u0026#34;] 565# Crossplane editors may see which namespaces exist, but not edit them. 566- apiGroups: [\u0026#34;\u0026#34;] 567 resources: [namespaces] 568 verbs: [get, list, watch] 569# Crossplane editors have full access to built in Crossplane types. 570- apiGroups: 571 - apiextensions.crossplane.io 572 resources: [\u0026#34;*\u0026#34;] 573 verbs: [\u0026#34;*\u0026#34;] 574- apiGroups: 575 - pkg.crossplane.io 576 resources: [locks, providers, configurations, providerrevisions, configurationrevisions] 577 verbs: [\u0026#34;*\u0026#34;] 578--- 579# Source: crossplane/templates/rbac-manager-managed-clusterroles.yaml 580apiVersion: rbac.authorization.k8s.io/v1 581kind: ClusterRole 582metadata: 583 name: crossplane:aggregate-to-view 584 labels: 585 rbac.crossplane.io/aggregate-to-view: \u0026#34;true\u0026#34; 586 app: crossplane 587 helm.sh/chart: crossplane-1.13.0 588 app.kubernetes.io/managed-by: Helm 589 app.kubernetes.io/component: cloud-infrastructure-controller 590 app.kubernetes.io/part-of: crossplane 591 app.kubernetes.io/name: crossplane 592 app.kubernetes.io/instance: crossplane 593 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 594rules: 595# Crossplane viewers have access to view events. 596- apiGroups: [\u0026#34;\u0026#34;] 597 resources: [events] 598 verbs: [get, list, watch] 599# Crossplane viewers may see which namespaces exist. 600- apiGroups: [\u0026#34;\u0026#34;] 601 resources: [namespaces] 602 verbs: [get, list, watch] 603# Crossplane viewers have read-only access to built in Crossplane types. 604- apiGroups: 605 - apiextensions.crossplane.io 606 resources: [\u0026#34;*\u0026#34;] 607 verbs: [get, list, watch] 608- apiGroups: 609 - pkg.crossplane.io 610 resources: [locks, providers, configurations, providerrevisions, configurationrevisions] 611 verbs: [get, list, watch] 612--- 613# Source: crossplane/templates/rbac-manager-managed-clusterroles.yaml 614apiVersion: rbac.authorization.k8s.io/v1 615kind: ClusterRole 616metadata: 617 name: crossplane:aggregate-to-browse 618 labels: 619 rbac.crossplane.io/aggregate-to-browse: \u0026#34;true\u0026#34; 620 app: crossplane 621 helm.sh/chart: crossplane-1.13.0 622 app.kubernetes.io/managed-by: Helm 623 app.kubernetes.io/component: cloud-infrastructure-controller 624 app.kubernetes.io/part-of: crossplane 625 app.kubernetes.io/name: crossplane 626 app.kubernetes.io/instance: crossplane 627 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 628rules: 629# Crossplane browsers have access to view events. 630- apiGroups: [\u0026#34;\u0026#34;] 631 resources: [events] 632 verbs: [get, list, watch] 633# Crossplane browsers have read-only access to compositions and XRDs. This 634# allows them to discover and select an appropriate composition when creating a 635# resource claim. 636- apiGroups: 637 - apiextensions.crossplane.io 638 resources: [\u0026#34;*\u0026#34;] 639 verbs: [get, list, watch] 640--- 641# Source: crossplane/templates/rbac-manager-managed-clusterroles.yaml 642# The below ClusterRoles are aggregated to the namespaced RBAC roles created by 643# the Crossplane RBAC manager when it is running in --manage=All mode. 644apiVersion: rbac.authorization.k8s.io/v1 645kind: ClusterRole 646metadata: 647 name: crossplane:aggregate-to-ns-admin 648 labels: 649 rbac.crossplane.io/aggregate-to-ns-admin: \u0026#34;true\u0026#34; 650 rbac.crossplane.io/base-of-ns-admin: \u0026#34;true\u0026#34; 651 app: crossplane 652 helm.sh/chart: crossplane-1.13.0 653 app.kubernetes.io/managed-by: Helm 654 app.kubernetes.io/component: cloud-infrastructure-controller 655 app.kubernetes.io/part-of: crossplane 656 app.kubernetes.io/name: crossplane 657 app.kubernetes.io/instance: crossplane 658 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 659rules: 660# Crossplane namespace admins have access to view events. 661- apiGroups: [\u0026#34;\u0026#34;] 662 resources: [events] 663 verbs: [get, list, watch] 664# Crossplane namespace admins may need to read or otherwise interact with 665# resource claim connection secrets. 666- apiGroups: [\u0026#34;\u0026#34;] 667 resources: [secrets] 668 verbs: [\u0026#34;*\u0026#34;] 669# Crossplane namespace admins have access to view the roles that they may be 670# able to grant to other subjects. 671- apiGroups: [rbac.authorization.k8s.io] 672 resources: [roles] 673 verbs: [get, list, watch] 674# Crossplane namespace admins have access to grant the access they have to other 675# subjects. 676- apiGroups: [rbac.authorization.k8s.io] 677 resources: [rolebindings] 678 verbs: [\u0026#34;*\u0026#34;] 679--- 680# Source: crossplane/templates/rbac-manager-managed-clusterroles.yaml 681apiVersion: rbac.authorization.k8s.io/v1 682kind: ClusterRole 683metadata: 684 name: crossplane:aggregate-to-ns-edit 685 labels: 686 rbac.crossplane.io/aggregate-to-ns-edit: \u0026#34;true\u0026#34; 687 rbac.crossplane.io/base-of-ns-edit: \u0026#34;true\u0026#34; 688 app: crossplane 689 helm.sh/chart: crossplane-1.13.0 690 app.kubernetes.io/managed-by: Helm 691 app.kubernetes.io/component: cloud-infrastructure-controller 692 app.kubernetes.io/part-of: crossplane 693 app.kubernetes.io/name: crossplane 694 app.kubernetes.io/instance: crossplane 695 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 696rules: 697# Crossplane namespace editors have access to view events. 698- apiGroups: [\u0026#34;\u0026#34;] 699 resources: [events] 700 verbs: [get, list, watch] 701# Crossplane namespace editors may need to read or otherwise interact with 702# resource claim connection secrets. 703- apiGroups: [\u0026#34;\u0026#34;] 704 resources: [secrets] 705 verbs: [\u0026#34;*\u0026#34;] 706--- 707# Source: crossplane/templates/rbac-manager-managed-clusterroles.yaml 708apiVersion: rbac.authorization.k8s.io/v1 709kind: ClusterRole 710metadata: 711 name: crossplane:aggregate-to-ns-view 712 labels: 713 rbac.crossplane.io/aggregate-to-ns-view: \u0026#34;true\u0026#34; 714 rbac.crossplane.io/base-of-ns-view: \u0026#34;true\u0026#34; 715 app: crossplane 716 helm.sh/chart: crossplane-1.13.0 717 app.kubernetes.io/managed-by: Helm 718 app.kubernetes.io/component: cloud-infrastructure-controller 719 app.kubernetes.io/part-of: crossplane 720 app.kubernetes.io/name: crossplane 721 app.kubernetes.io/instance: crossplane 722 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 723rules: 724# Crossplane namespace viewers have access to view events. 725- apiGroups: [\u0026#34;\u0026#34;] 726 resources: [events] 727 verbs: [get, list, watch] 728--- 729# Source: crossplane/templates/clusterrolebinding.yaml 730apiVersion: rbac.authorization.k8s.io/v1 731kind: ClusterRoleBinding 732metadata: 733 name: crossplane 734 labels: 735 app: crossplane 736 helm.sh/chart: crossplane-1.13.0 737 app.kubernetes.io/managed-by: Helm 738 app.kubernetes.io/component: cloud-infrastructure-controller 739 app.kubernetes.io/part-of: crossplane 740 app.kubernetes.io/name: crossplane 741 app.kubernetes.io/instance: crossplane 742 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 743roleRef: 744 apiGroup: rbac.authorization.k8s.io 745 kind: ClusterRole 746 name: crossplane 747subjects: 748- kind: ServiceAccount 749 name: crossplane 750 namespace: crossplane-system 751--- 752# Source: crossplane/templates/rbac-manager-clusterrolebinding.yaml 753apiVersion: rbac.authorization.k8s.io/v1 754kind: ClusterRoleBinding 755metadata: 756 name: crossplane-rbac-manager 757 labels: 758 app: crossplane 759 helm.sh/chart: crossplane-1.13.0 760 app.kubernetes.io/managed-by: Helm 761 app.kubernetes.io/component: cloud-infrastructure-controller 762 app.kubernetes.io/part-of: crossplane 763 app.kubernetes.io/name: crossplane 764 app.kubernetes.io/instance: crossplane 765 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 766roleRef: 767 apiGroup: rbac.authorization.k8s.io 768 kind: ClusterRole 769 name: crossplane-rbac-manager 770subjects: 771- kind: ServiceAccount 772 name: rbac-manager 773 namespace: crossplane-system 774--- 775# Source: crossplane/templates/rbac-manager-managed-clusterroles.yaml 776apiVersion: rbac.authorization.k8s.io/v1 777kind: ClusterRoleBinding 778metadata: 779 name: crossplane-admin 780 labels: 781 app: crossplane 782 helm.sh/chart: crossplane-1.13.0 783 app.kubernetes.io/managed-by: Helm 784 app.kubernetes.io/component: cloud-infrastructure-controller 785 app.kubernetes.io/part-of: crossplane 786 app.kubernetes.io/name: crossplane 787 app.kubernetes.io/instance: crossplane 788 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 789roleRef: 790 apiGroup: rbac.authorization.k8s.io 791 kind: ClusterRole 792 name: crossplane-admin 793subjects: 794- apiGroup: rbac.authorization.k8s.io 795 kind: Group 796 name: crossplane:masters 797--- 798# Source: crossplane/templates/service.yaml 799apiVersion: v1 800kind: Service 801metadata: 802 name: crossplane-webhooks 803 namespace: crossplane-system 804 labels: 805 app: crossplane 806 release: crossplane 807 helm.sh/chart: crossplane-1.13.0 808 app.kubernetes.io/managed-by: Helm 809 app.kubernetes.io/component: cloud-infrastructure-controller 810 app.kubernetes.io/part-of: crossplane 811 app.kubernetes.io/name: crossplane 812 app.kubernetes.io/instance: crossplane 813 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 814spec: 815 selector: 816 app: crossplane 817 release: crossplane 818 ports: 819 - protocol: TCP 820 port: 9443 821 targetPort: 9443 822--- 823# Source: crossplane/templates/deployment.yaml 824apiVersion: apps/v1 825kind: Deployment 826metadata: 827 name: crossplane 828 namespace: crossplane-system 829 labels: 830 app: crossplane 831 release: crossplane 832 helm.sh/chart: crossplane-1.13.0 833 app.kubernetes.io/managed-by: Helm 834 app.kubernetes.io/component: cloud-infrastructure-controller 835 app.kubernetes.io/part-of: crossplane 836 app.kubernetes.io/name: crossplane 837 app.kubernetes.io/instance: crossplane 838 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 839spec: 840 replicas: 1 841 selector: 842 matchLabels: 843 app: crossplane 844 release: crossplane 845 strategy: 846 type: RollingUpdate 847 template: 848 metadata: 849 labels: 850 app: crossplane 851 release: crossplane 852 helm.sh/chart: crossplane-1.13.0 853 app.kubernetes.io/managed-by: Helm 854 app.kubernetes.io/component: cloud-infrastructure-controller 855 app.kubernetes.io/part-of: crossplane 856 app.kubernetes.io/name: crossplane 857 app.kubernetes.io/instance: crossplane 858 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 859 spec: 860 securityContext: 861 {} 862 serviceAccountName: crossplane 863 hostNetwork: false 864 initContainers: 865 - image: \u0026#34;crossplane/crossplane:v1.13.0\u0026#34; 866 args: 867 - core 868 - init 869 imagePullPolicy: IfNotPresent 870 name: crossplane-init 871 resources: 872 limits: 873 cpu: 100m 874 memory: 512Mi 875 requests: 876 cpu: 100m 877 memory: 256Mi 878 securityContext: 879 allowPrivilegeEscalation: false 880 readOnlyRootFilesystem: true 881 runAsGroup: 65532 882 runAsUser: 65532 883 env: 884 - name: GOMAXPROCS 885 valueFrom: 886 resourceFieldRef: 887 containerName: crossplane-init 888 resource: limits.cpu 889 - name: GOMEMLIMIT 890 valueFrom: 891 resourceFieldRef: 892 containerName: crossplane-init 893 resource: limits.memory 894 - name: POD_NAMESPACE 895 valueFrom: 896 fieldRef: 897 fieldPath: metadata.namespace 898 - name: POD_SERVICE_ACCOUNT 899 valueFrom: 900 fieldRef: 901 fieldPath: spec.serviceAccountName 902 - name: \u0026#34;WEBHOOK_TLS_SECRET_NAME\u0026#34; 903 value: webhook-tls-secret 904 - name: \u0026#34;WEBHOOK_SERVICE_NAME\u0026#34; 905 value: crossplane-webhooks 906 - name: \u0026#34;WEBHOOK_SERVICE_NAMESPACE\u0026#34; 907 valueFrom: 908 fieldRef: 909 fieldPath: metadata.namespace 910 - name: \u0026#34;WEBHOOK_SERVICE_PORT\u0026#34; 911 value: \u0026#34;9443\u0026#34; 912 containers: 913 - image: \u0026#34;crossplane/crossplane:v1.13.0\u0026#34; 914 args: 915 - core 916 - start 917 imagePullPolicy: IfNotPresent 918 name: crossplane 919 resources: 920 limits: 921 cpu: 100m 922 memory: 512Mi 923 requests: 924 cpu: 100m 925 memory: 256Mi 926 ports: 927 - name: webhooks 928 containerPort: 9443 929 securityContext: 930 allowPrivilegeEscalation: false 931 readOnlyRootFilesystem: true 932 runAsGroup: 65532 933 runAsUser: 65532 934 env: 935 - name: GOMAXPROCS 936 valueFrom: 937 resourceFieldRef: 938 containerName: crossplane 939 resource: limits.cpu 940 - name: GOMEMLIMIT 941 valueFrom: 942 resourceFieldRef: 943 containerName: crossplane 944 resource: limits.memory 945 - name: POD_NAMESPACE 946 valueFrom: 947 fieldRef: 948 fieldPath: metadata.namespace 949 - name: POD_SERVICE_ACCOUNT 950 valueFrom: 951 fieldRef: 952 fieldPath: spec.serviceAccountName 953 - name: LEADER_ELECTION 954 value: \u0026#34;true\u0026#34; 955 - name: \u0026#34;WEBHOOK_TLS_SECRET_NAME\u0026#34; 956 value: webhook-tls-secret 957 - name: \u0026#34;WEBHOOK_TLS_CERT_DIR\u0026#34; 958 value: /webhook/tls 959 volumeMounts: 960 - mountPath: /cache 961 name: package-cache 962 - mountPath: /webhook/tls 963 name: webhook-tls-secret 964 volumes: 965 - name: package-cache 966 emptyDir: 967 medium: 968 sizeLimit: 20Mi 969 - name: webhook-tls-secret 970 secret: 971 # NOTE(muvaf): The tls.crt is used both by the server (requires it to 972 # be a single cert) and the caBundle fields of webhook configs and CRDs 973 # which can accept a whole bundle of certificates. In order to meet 974 # the requirements of both, we require a single certificate instead of 975 # a bundle. 976 # It\u0026#39;s assumed that initializer generates this anyway, so it should be 977 # fine. 978 secretName: webhook-tls-secret 979--- 980# Source: crossplane/templates/rbac-manager-deployment.yaml 981apiVersion: apps/v1 982kind: Deployment 983metadata: 984 name: crossplane-rbac-manager 985 namespace: crossplane-system 986 labels: 987 app: crossplane-rbac-manager 988 release: crossplane 989 helm.sh/chart: crossplane-1.13.0 990 app.kubernetes.io/managed-by: Helm 991 app.kubernetes.io/component: cloud-infrastructure-controller 992 app.kubernetes.io/part-of: crossplane 993 app.kubernetes.io/name: crossplane 994 app.kubernetes.io/instance: crossplane 995 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 996spec: 997 replicas: 1 998 selector: 999 matchLabels: 1000 app: crossplane-rbac-manager 1001 release: crossplane 1002 strategy: 1003 type: RollingUpdate 1004 template: 1005 metadata: 1006 labels: 1007 app: crossplane-rbac-manager 1008 release: crossplane 1009 helm.sh/chart: crossplane-1.13.0 1010 app.kubernetes.io/managed-by: Helm 1011 app.kubernetes.io/component: cloud-infrastructure-controller 1012 app.kubernetes.io/part-of: crossplane 1013 app.kubernetes.io/name: crossplane 1014 app.kubernetes.io/instance: crossplane 1015 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 1016 spec: 1017 securityContext: 1018 {} 1019 serviceAccountName: rbac-manager 1020 initContainers: 1021 - image: \u0026#34;crossplane/crossplane:v1.13.0\u0026#34; 1022 args: 1023 - rbac 1024 - init 1025 imagePullPolicy: IfNotPresent 1026 name: crossplane-init 1027 resources: 1028 limits: 1029 cpu: 100m 1030 memory: 512Mi 1031 requests: 1032 cpu: 100m 1033 memory: 256Mi 1034 securityContext: 1035 allowPrivilegeEscalation: false 1036 readOnlyRootFilesystem: true 1037 runAsGroup: 65532 1038 runAsUser: 65532 1039 env: 1040 - name: GOMAXPROCS 1041 valueFrom: 1042 resourceFieldRef: 1043 containerName: crossplane-init 1044 resource: limits.cpu 1045 - name: GOMEMLIMIT 1046 valueFrom: 1047 resourceFieldRef: 1048 containerName: crossplane-init 1049 resource: limits.memory 1050 containers: 1051 - image: \u0026#34;crossplane/crossplane:v1.13.0\u0026#34; 1052 args: 1053 - rbac 1054 - start 1055 - --manage=Basic 1056 - --provider-clusterrole=crossplane:allowed-provider-permissions 1057 imagePullPolicy: IfNotPresent 1058 name: crossplane 1059 resources: 1060 limits: 1061 cpu: 100m 1062 memory: 512Mi 1063 requests: 1064 cpu: 100m 1065 memory: 256Mi 1066 securityContext: 1067 allowPrivilegeEscalation: false 1068 readOnlyRootFilesystem: true 1069 runAsGroup: 65532 1070 runAsUser: 65532 1071 env: 1072 - name: GOMAXPROCS 1073 valueFrom: 1074 resourceFieldRef: 1075 containerName: crossplane 1076 resource: limits.cpu 1077 - name: GOMEMLIMIT 1078 valueFrom: 1079 resourceFieldRef: 1080 containerName: crossplane 1081 resource: limits.memory 1082 - name: LEADER_ELECTION 1083 value: \u0026#34;true\u0026#34; 1084 1085NOTES: 1086Release: crossplane 1087 1088Chart Name: crossplane 1089Chart Description: Crossplane is an open source Kubernetes add-on that enables platform teams to assemble infrastructure from multiple vendors, and expose higher level self-service APIs for application teams to consume. 1090Chart Version: 1.13.0 1091Chart Application Version: 1.13.0 1092 1093Kube Version: v1.27.4 Install the Crossplane components using helm install.\n1helm install crossplane \\ 2crossplane-stable/crossplane \\ 3--namespace crossplane-system \\ 4--create-namespace Verify Crossplane installed with kubectl get pods.\n1kubectl get pods -n crossplane-system 2NAME READY STATUS RESTARTS AGE 3crossplane-d4cd8d784-ldcgb 1/1 Running 0 54s 4crossplane-rbac-manager-84769b574-6mw6f 1/1 Running 0 54s Installing Crossplane creates new Kubernetes API end-points.\nLook at the new API end-points with kubectl api-resources | grep crossplane.\n1kubectl api-resources | grep crossplane 2compositeresourcedefinitions xrd,xrds apiextensions.crossplane.io/v1 false CompositeResourceDefinition 3compositionrevisions comprev apiextensions.crossplane.io/v1 false CompositionRevision 4compositions comp apiextensions.crossplane.io/v1 false Composition 5environmentconfigs envcfg apiextensions.crossplane.io/v1alpha1 false EnvironmentConfig 6configurationrevisions pkg.crossplane.io/v1 false ConfigurationRevision 7configurations pkg.crossplane.io/v1 false Configuration 8controllerconfigs pkg.crossplane.io/v1alpha1 false ControllerConfig 9locks pkg.crossplane.io/v1beta1 false Lock 10providerrevisions pkg.crossplane.io/v1 false ProviderRevision 11providers pkg.crossplane.io/v1 false Provider 12storeconfigs secrets.crossplane.io/v1alpha1 false StoreConfig Install the AWS provider Install the AWS S3 provider into the Kubernetes cluster with a Kubernetes configuration file.\n1cat \u0026lt;\u0026lt;EOF | kubectl apply -f - 2apiVersion: pkg.crossplane.io/v1 3kind: Provider 4metadata: 5 name: provider-aws-s3 6spec: 7 package: xpkg.upbound.io/upbound/provider-aws-s3:v0.37.0 8EOF The Crossplane Provider installs the Kubernetes Custom Resource Definitions (CRDs) representing AWS S3 services. These CRDs allow you to create AWS resources directly inside Kubernetes.\nVerify the provider installed with kubectl get providers.\n1kubectl get providers 2NAME INSTALLED HEALTHY PACKAGE AGE 3provider-aws-s3 True True xpkg.upbound.io/upbound/provider-aws-s3:v0.37.0 2m53s 4upbound-provider-family-aws True True xpkg.upbound.io/upbound/provider-family-aws:v0.37.0 2m48s The S3 Provider installs a second Provider, the upbound-provider-family-aws.\nThe family provider manages authentication to AWS across all AWS family Providers.\nYou can view the new CRDs with kubectl get crds.\nEvery CRD maps to a unique AWS service Crossplane can provision and manage.\nTip See details about all the supported CRDs in the Upbound Marketplace. Create a Kubernetes secret for AWS The provider requires credentials to create and manage AWS resources.\nProviders use a Kubernetes Secret to connect the credentials to the provider.\nGenerate a Kubernetes Secret from your AWS key-pair and then configure the Provider to use it.\nGenerate an AWS key-pair file For basic user authentication, use an AWS Access keys key-pair file.\nTip The AWS documentation provides information on how to generate AWS Access keys. Create a text file containing the AWS account aws_access_key_id and aws_secret_access_key.\n1[default] 2aws_access_key_id = 3aws_secret_access_key = Save this text file as aws-credentials.txt.\nTip The Authentication section of the AWS Provider documentation describes other authentication methods. Create a Kubernetes secret with the AWS credentials A Kubernetes generic secret has a name and contents.\nUse kubectl create secret\nto generate the secret object named aws-secret\nin the crossplane-system namespace.\nUse the --from-file= argument to set the value to the contents of the aws-credentials.txt file.\n1kubectl create secret \\ 2generic aws-secret \\ 3-n crossplane-system \\ 4--from-file=creds=./aws-credentials.txt View the secret with kubectl describe secret\nTip The size may be larger if there are extra blank spaces in your text file. 1kubectl describe secret aws-secret -n crossplane-system 2Name: aws-secret 3Namespace: crossplane-system 4Labels: \u0026lt;none\u0026gt; 5Annotations: \u0026lt;none\u0026gt; 6 7Type: Opaque 8 9Data 10==== 11creds: 114 bytes Create a ProviderConfig A ProviderConfig customizes the settings of the AWS Provider.\nApply the ProviderConfig with the this Kubernetes configuration file:\n1cat \u0026lt;\u0026lt;EOF | kubectl apply -f - 2apiVersion: aws.upbound.io/v1beta1 3kind: ProviderConfig 4metadata: 5 name: default 6spec: 7 credentials: 8 source: Secret 9 secretRef: 10 namespace: crossplane-system 11 name: aws-secret 12 key: creds 13EOF This attaches the AWS credentials, saved as a Kubernetes secret, as a secretRef.\nThe spec.credentials.secretRef.name value is the name of the Kubernetes secret containing the AWS credentials in the spec.credentials.secretRef.namespace.\nCreate a managed resource A managed resource is anything Crossplane creates and manages outside of the Kubernetes cluster.\nThis guide creates an AWS S3 bucket with Crossplane.\nThe S3 bucket is a managed resource.\nTip AWS S3 bucket names must be globally unique. To generate a unique name the example uses a random hash. Any unique name is acceptable. 1bucket=$(echo \u0026#34;crossplane-bucket-\u0026#34;$(head -n 4096 /dev/urandom | openssl sha1 | tail -c 10)) 2cat \u0026lt;\u0026lt;EOF | kubectl apply -f - 3apiVersion: s3.aws.upbound.io/v1beta1 4kind: Bucket 5metadata: 6 name: $bucket 7spec: 8 forProvider: 9 region: us-east-2 10 providerConfigRef: 11 name: default 12EOF The apiVersion and kind are from the provider\u0026rsquo;s CRDs.\nThe metadata.name value is the name of the created S3 bucket in AWS.\nThis example uses the generated name crossplane-bucket-\u0026lt;hash\u0026gt; in the $bucket variable.\nThe spec.forProvider.region tells AWS which AWS region to use when deploying resources.\nThe region can be any AWS Regional endpoint code.\nUse kubectl get buckets to verify Crossplane created the bucket.\nTip Crossplane created the bucket when the values READY and SYNCED are True.\nThis may take up to 5 minutes. 1kubectl get buckets 2NAME READY SYNCED EXTERNAL-NAME AGE 3crossplane-bucket-45eed4ae0 True True crossplane-bucket-45eed4ae0 61s Delete the managed resource Before shutting down your Kubernetes cluster, delete the S3 bucket just created.\nUse kubectl delete bucket \u0026lt;bucketname\u0026gt; to remove the bucket.\n1kubectl delete bucket $bucket 2bucket.s3.aws.upbound.io \u0026#34;crossplane-bucket-45eed4ae0\u0026#34; deleted Next steps Continue to part 2 to create and use a custom API with Crossplane. Explore AWS resources that Crossplane can configure in the Provider CRD reference. Join the Crossplane Slack and connect with Crossplane users and contributors. ","title":"AWS Quickstart","url":"/v1.14/getting-started/provider-aws/"},{"content":"Crossplane installs into an existing Kubernetes cluster, creating the Crossplane pod, enabling the installation of Crossplane Provider resources.\nTip If you don\u0026rsquo;t have a Kubernetes cluster create one locally with Kind. Prerequisites An actively supported Kubernetes version Helm version v3.2.0 or later Install Crossplane Install Crossplane using the Crossplane published Helm chart.\nAdd the Crossplane Helm repository Add the Crossplane repository with the helm repo add command.\n1helm repo add crossplane-stable https://charts.crossplane.io/stable Update the local Helm chart cache with helm repo update.\n1helm repo update Install the Crossplane Helm chart Install the Crossplane Helm chart with helm install.\nTip View the changes Crossplane makes to your cluster with the helm install --dry-run --debug options. Helm shows what configurations it applies without making changes to the Kubernetes cluster. Crossplane creates and installs into the crossplane-system namespace.\n1helm install crossplane \\ 2--namespace crossplane-system \\ 3--create-namespace crossplane-stable/crossplane View the installed Crossplane pods with kubectl get pods -n crossplane-system.\n1kubectl get pods -n crossplane-system 2NAME READY STATUS RESTARTS AGE 3crossplane-6d67f8cd9d-g2gjw 1/1 Running 0 26m 4crossplane-rbac-manager-86d9b5cf9f-2vc4s 1/1 Running 0 26m Tip Install a specific version of Crossplane with the --version \u0026lt;version\u0026gt; option. For example, to install version 1.10.0:\n1helm install crossplane \\ 2--namespace crossplane-system \\ 3--create-namespace crossplane-stable/crossplane \\ 4--version 1.10.0 Installed deployments Crossplane creates two Kubernetes deployments in the crossplane-system namespace to deploy the Crossplane pods.\n1kubectl get deployments -n crossplane-system 2NAME READY UP-TO-DATE AVAILABLE AGE 3crossplane 1/1 1 1 8m13s 4crossplane-rbac-manager 1/1 1 1 8m13s Crossplane deployment The Crossplane deployment starts with the crossplane-init container. The init container installs the Crossplane Custom Resource Definitions into the Kubernetes cluster.\nAfter the init container finishes, the crossplane pod manages two Kubernetes controllers.\nThe Package Manager controller installs the provider and configuration packages. The Composition controller installs and manages the Crossplane Composite Resource Definitions, Compositions and Claims. Crossplane RBAC manager deployment The crossplane-rbac-manager creates and manages Kubernetes ClusterRoles for installed Crossplane Provider and their Custom Resource Definitions.\nThe Crossplane RBAC Manager design document has more information on the installed ClusterRoles.\nInstallation options Customize the Crossplane Helm chart Crossplane supports customizations at install time by configuring the Helm chart.\nApply customizations with the command line or with a Helm values file.\nAll Crossplane customization options Parameter Description Default affinity Add affinities to the Crossplane pod deployment. {} args Add custom arguments to the Crossplane pod. [] configuration.packages A list of Configuration packages to install. [] customAnnotations Add custom annotations to the Crossplane pod deployment. {} customLabels Add custom labels to the Crossplane pod deployment. {} deploymentStrategy The deployment strategy for the Crossplane and RBAC Manager pods. \u0026quot;RollingUpdate\u0026quot; extraEnvVarsCrossplane Add custom environmental variables to the Crossplane pod deployment. Replaces any . in a variable name with _. For example, SAMPLE.KEY=value1 becomes SAMPLE_KEY=value1. {} extraEnvVarsRBACManager Add custom environmental variables to the RBAC Manager pod deployment. Replaces any . in a variable name with _. For example, SAMPLE.KEY=value1 becomes SAMPLE_KEY=value1. {} extraObjects To add arbitrary Kubernetes Objects during a Helm Install [] extraVolumeMountsCrossplane Add custom volumeMounts to the Crossplane pod. {} extraVolumesCrossplane Add custom volumes to the Crossplane pod. {} hostNetwork Enable hostNetwork for the Crossplane deployment. Caution: enabling hostNetwork grants the Crossplane Pod access to the host network namespace. false image.pullPolicy The image pull policy used for Crossplane and RBAC Manager pods. \u0026quot;IfNotPresent\u0026quot; image.repository Repository for the Crossplane pod image. \u0026quot;xpkg.upbound.io/crossplane/crossplane\u0026quot; image.tag The Crossplane image tag. Defaults to the value of appVersion in Chart.yaml. \u0026quot;\u0026quot; imagePullSecrets The imagePullSecret names to add to the Crossplane ServiceAccount. {} leaderElection Enable leader election for the Crossplane pod. true metrics.enabled Enable Prometheus path, port and scrape annotations and expose port 8080 for both the Crossplane and RBAC Manager pods. false nodeSelector Add nodeSelectors to the Crossplane pod deployment. {} packageCache.configMap The name of a ConfigMap to use as the package cache. Disables the default package cache emptyDir Volume. \u0026quot;\u0026quot; packageCache.medium Set to Memory to hold the package cache in a RAM backed file system. Useful for Crossplane development. \u0026quot;\u0026quot; packageCache.pvc The name of a PersistentVolumeClaim to use as the package cache. Disables the default package cache emptyDir Volume. \u0026quot;\u0026quot; packageCache.sizeLimit The size limit for the package cache. If medium is Memory the sizeLimit can\u0026rsquo;t exceed Node memory. \u0026quot;20Mi\u0026quot; podSecurityContextCrossplane Add a custom securityContext to the Crossplane pod. {} podSecurityContextRBACManager Add a custom securityContext to the RBAC Manager pod. {} priorityClassName The PriorityClass name to apply to the Crossplane and RBAC Manager pods. \u0026quot;\u0026quot; provider.packages A list of Provider packages to install. [] rbacManager.affinity Add affinities to the RBAC Manager pod deployment. {} rbacManager.args Add custom arguments to the RBAC Manager pod. [] rbacManager.deploy Deploy the RBAC Manager pod and its required roles. true rbacManager.leaderElection Enable leader election for the RBAC Manager pod. true rbacManager.managementPolicy Defines the Roles and ClusterRoles the RBAC Manager creates and manages. - A policy of Basic creates and binds Roles only for the Crossplane ServiceAccount, Provider ServiceAccounts and creates Crossplane ClusterRoles. - A policy of All includes all the Basic settings and also creates Crossplane Roles in all namespaces. - Read the Crossplane docs for more information on the RBAC Roles and ClusterRoles \u0026quot;Basic\u0026quot; rbacManager.nodeSelector Add nodeSelectors to the RBAC Manager pod deployment. {} rbacManager.replicas The number of RBAC Manager pod replicas to deploy. 1 rbacManager.skipAggregatedClusterRoles Don\u0026rsquo;t install aggregated Crossplane ClusterRoles. false rbacManager.tolerations Add tolerations to the RBAC Manager pod deployment. [] registryCaBundleConfig.key The ConfigMap key containing a custom CA bundle to enable fetching packages from registries with unknown or untrusted certificates. \u0026quot;\u0026quot; registryCaBundleConfig.name The ConfigMap name containing a custom CA bundle to enable fetching packages from registries with unknown or untrusted certificates. \u0026quot;\u0026quot; replicas The number of Crossplane pod replicas to deploy. 1 resourcesCrossplane.limits.cpu CPU resource limits for the Crossplane pod. \u0026quot;100m\u0026quot; resourcesCrossplane.limits.memory Memory resource limits for the Crossplane pod. \u0026quot;512Mi\u0026quot; resourcesCrossplane.requests.cpu CPU resource requests for the Crossplane pod. \u0026quot;100m\u0026quot; resourcesCrossplane.requests.memory Memory resource requests for the Crossplane pod. \u0026quot;256Mi\u0026quot; resourcesRBACManager.limits.cpu CPU resource limits for the RBAC Manager pod. \u0026quot;100m\u0026quot; resourcesRBACManager.limits.memory Memory resource limits for the RBAC Manager pod. \u0026quot;512Mi\u0026quot; resourcesRBACManager.requests.cpu CPU resource requests for the RBAC Manager pod. \u0026quot;100m\u0026quot; resourcesRBACManager.requests.memory Memory resource requests for the RBAC Manager pod. \u0026quot;256Mi\u0026quot; securityContextCrossplane.allowPrivilegeEscalation Enable allowPrivilegeEscalation for the Crossplane pod. false securityContextCrossplane.readOnlyRootFilesystem Set the Crossplane pod root file system as read-only. true securityContextCrossplane.runAsGroup The group ID used by the Crossplane pod. 65532 securityContextCrossplane.runAsUser The user ID used by the Crossplane pod. 65532 securityContextRBACManager.allowPrivilegeEscalation Enable allowPrivilegeEscalation for the RBAC Manager pod. false securityContextRBACManager.readOnlyRootFilesystem Set the RBAC Manager pod root file system as read-only. true securityContextRBACManager.runAsGroup The group ID used by the RBAC Manager pod. 65532 securityContextRBACManager.runAsUser The user ID used by the RBAC Manager pod. 65532 serviceAccount.customAnnotations Add custom annotations to the Crossplane ServiceAccount. {} tolerations Add tolerations to the Crossplane pod deployment. [] webhooks.enabled Enable webhooks for Crossplane and installed Provider packages. true Command line customization Apply custom settings at the command line with helm install crossplane --set \u0026lt;setting\u0026gt;=\u0026lt;value\u0026gt;.\nFor example, to change the image pull policy:\n1helm install crossplane \\ 2--namespace crossplane-system \\ 3--create-namespace \\ 4crossplane-stable/crossplane \\ 5--set image.pullPolicy=Always Helm supports comma-separated arguments.\nFor example, to change the image pull policy and number of replicas:\n1helm install crossplane \\ 2--namespace crossplane-system \\ 3--create-namespace \\ 4crossplane-stable/crossplane \\ 5--set image.pullPolicy=Always,replicas=2 Helm values file Apply custom settings in a Helm values file with helm install crossplane -f \u0026lt;filename\u0026gt;.\nA YAML file defines the customized settings.\nFor example, to change the image pull policy and number of replicas:\nCreate a YAML with the customized settings.\n1replicas: 2 2 3image: 4 pullPolicy: Always Apply the file with helm install:\n1helm install crossplane \\ 2--namespace crossplane-system \\ 3--create-namespace \\ 4crossplane-stable/crossplane \\ 5-f settings.yaml Feature flags Crossplane introduces new features behind feature flags. By default alpha features are off. Crossplane enables beta features by default. To enable a feature flag, set the args value in the Helm chart. Available feature flags can be directly found by running crossplane core start --help, or by looking at the table below.\nFeature flags Status Flag Description Beta --enable-composition-revisions Enable support for CompositionRevisions. Beta --enable-composition-webhook-schema-validation Enable Composition validation using schemas. Alpha --enable-composition-functions Enable support for Composition Functions. Alpha --enable-environment-configs Enable support for EnvironmentConfigs. Alpha --enable-external-secret-stores Enable support for External Secret Stores. Alpha --enable-usages Enable support for Usages. Alpha --enable-realtime-compositions Enable support for real time compositions. Set these flags either in the values.yaml file or at install time using the --set flag, for example: --set args='{\u0026quot;--enable-composition-functions\u0026quot;,\u0026quot;--enable-composition-webhook-schema-validation\u0026quot;}'.\nInstall pre-release Crossplane versions Install a pre-release versions of Crossplane from the master Crossplane Helm channel.\nVersions in the master channel are under active development and may be unstable.\nWarning Don\u0026rsquo;t use Crossplane master releases in production. Only use stable channel.\nOnly use master for testing and development. Add the Crossplane master Helm repository Add the Crossplane repository with the helm repo add command.\n1helm repo add crossplane-master https://charts.crossplane.io/master/ Update the local Helm chart cache with helm repo update.\n1helm repo update Install the Crossplane master Helm chart Install the Crossplane master Helm chart with helm install.\nTip View the changes Crossplane makes to your cluster with the helm install --dry-run --debug options. Helm shows what configurations it applies without making changes to the Kubernetes cluster. Crossplane creates and installs into the crossplane-system namespace.\n1helm install crossplane \\ 2--namespace crossplane-system \\ 3--create-namespace crossplane-master/crossplane \\ 4--devel Crossplane distributions Third-party vendors may maintain their own Crossplane distributions. Vendor supported distribution may have features or tooling that isn\u0026rsquo;t in the Community Crossplane distribution.\nThe CNCF certified third-party distributions as \u0026ldquo;conformant\u0026rdquo; with the Community Crossplane distribution.\nVendors Below are vendors providing conformant Crossplane distributions.\nUpbound Upbound, the founders of Crossplane, maintains a free and open source distribution of Crossplane called Universal Crossplane (UXP).\nFind information on UXP in the Upbound UXP documentation.\n","title":"Install Crossplane","url":"/v1.14/software/install/"},{"content":"Connect Crossplane to Azure to create and manage cloud resources from Kubernetes with the Upbound Azure Provider.\nThis guide is in two parts:\nPart 1 walks through installing Crossplane, configuring the provider to authenticate to Azure and creating a Managed Resource in Azure directly from your Kubernetes cluster. This shows Crossplane can communicate with Azure. Part 2 shows how to build and access a custom API with Crossplane. Prerequisites This quickstart requires:\na Kubernetes cluster with at least 2 GB of RAM permissions to create pods and secrets in the Kubernetes cluster Helm version v3.2.0 or later an Azure account with permissions to create an Azure Virtual Machine and Virtual Network an Azure account with permissions to create an Azure service principal and an Azure resource group Install Crossplane Crossplane installs into an existing Kubernetes cluster.\nTip If you don\u0026rsquo;t have a Kubernetes cluster create one locally with Kind. Install the Crossplane Helm chart Helm enables Crossplane to install all its Kubernetes components through a Helm Chart.\nEnable the Crossplane Helm Chart repository:\n1helm repo add \\ 2crossplane-stable https://charts.crossplane.io/stable 3helm repo update Run the Helm dry-run to see all the Crossplane components Helm installs.\n1helm install crossplane \\ 2crossplane-stable/crossplane \\ 3--dry-run --debug \\ 4--namespace crossplane-system \\ 5--create-namespace View the Helm dry-run 1helm install crossplane \\ 2crossplane-stable/crossplane \\ 3--dry-run --debug \\ 4--namespace crossplane-system \\ 5--create-namespace 6install.go:200: [debug] Original chart version: \u0026#34;\u0026#34; 7install.go:217: [debug] CHART PATH: /home/vagrant/.cache/helm/repository/crossplane-1.13.0.tgz 8 9NAME: crossplane 10LAST DEPLOYED: Fri Jul 28 13:57:41 2023 11NAMESPACE: crossplane-system 12STATUS: pending-install 13REVISION: 1 14TEST SUITE: None 15USER-SUPPLIED VALUES: 16{} 17 18COMPUTED VALUES: 19affinity: {} 20args: [] 21configuration: 22 packages: [] 23customAnnotations: {} 24customLabels: {} 25deploymentStrategy: RollingUpdate 26extraEnvVarsCrossplane: {} 27extraEnvVarsRBACManager: {} 28extraVolumeMountsCrossplane: {} 29extraVolumesCrossplane: {} 30hostNetwork: false 31image: 32 pullPolicy: IfNotPresent 33 repository: crossplane/crossplane 34 tag: \u0026#34;\u0026#34; 35imagePullSecrets: {} 36leaderElection: true 37metrics: 38 enabled: false 39nodeSelector: {} 40packageCache: 41 configMap: \u0026#34;\u0026#34; 42 medium: \u0026#34;\u0026#34; 43 pvc: \u0026#34;\u0026#34; 44 sizeLimit: 20Mi 45podSecurityContextCrossplane: {} 46podSecurityContextRBACManager: {} 47priorityClassName: \u0026#34;\u0026#34; 48provider: 49 packages: [] 50rbacManager: 51 affinity: {} 52 args: [] 53 deploy: true 54 leaderElection: true 55 managementPolicy: Basic 56 nodeSelector: {} 57 replicas: 1 58 skipAggregatedClusterRoles: false 59 tolerations: [] 60registryCaBundleConfig: 61 key: \u0026#34;\u0026#34; 62 name: \u0026#34;\u0026#34; 63replicas: 1 64resourcesCrossplane: 65 limits: 66 cpu: 100m 67 memory: 512Mi 68 requests: 69 cpu: 100m 70 memory: 256Mi 71resourcesRBACManager: 72 limits: 73 cpu: 100m 74 memory: 512Mi 75 requests: 76 cpu: 100m 77 memory: 256Mi 78securityContextCrossplane: 79 allowPrivilegeEscalation: false 80 readOnlyRootFilesystem: true 81 runAsGroup: 65532 82 runAsUser: 65532 83securityContextRBACManager: 84 allowPrivilegeEscalation: false 85 readOnlyRootFilesystem: true 86 runAsGroup: 65532 87 runAsUser: 65532 88serviceAccount: 89 customAnnotations: {} 90tolerations: [] 91webhooks: 92 enabled: true 93 94HOOKS: 95MANIFEST: 96--- 97# Source: crossplane/templates/rbac-manager-serviceaccount.yaml 98apiVersion: v1 99kind: ServiceAccount 100metadata: 101 name: rbac-manager 102 namespace: crossplane-system 103 labels: 104 app: crossplane 105 helm.sh/chart: crossplane-1.13.0 106 app.kubernetes.io/managed-by: Helm 107 app.kubernetes.io/component: cloud-infrastructure-controller 108 app.kubernetes.io/part-of: crossplane 109 app.kubernetes.io/name: crossplane 110 app.kubernetes.io/instance: crossplane 111 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 112--- 113# Source: crossplane/templates/serviceaccount.yaml 114apiVersion: v1 115kind: ServiceAccount 116metadata: 117 name: crossplane 118 namespace: crossplane-system 119 labels: 120 app: crossplane 121 helm.sh/chart: crossplane-1.13.0 122 app.kubernetes.io/managed-by: Helm 123 app.kubernetes.io/component: cloud-infrastructure-controller 124 app.kubernetes.io/part-of: crossplane 125 app.kubernetes.io/name: crossplane 126 app.kubernetes.io/instance: crossplane 127 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 128--- 129# Source: crossplane/templates/secret.yaml 130# The reason this is created empty and filled by the init container is that it\u0026#39;s 131# mounted by the actual container, so if it wasn\u0026#39;t created by Helm, then the 132# deployment wouldn\u0026#39;t be deployed at all with secret to mount not found error. 133# In addition, Helm would delete this secret after uninstallation so the new 134# installation of Crossplane would use its own certificate. 135apiVersion: v1 136kind: Secret 137metadata: 138 name: webhook-tls-secret 139 namespace: crossplane-system 140type: Opaque 141--- 142# Source: crossplane/templates/clusterrole.yaml 143apiVersion: rbac.authorization.k8s.io/v1 144kind: ClusterRole 145metadata: 146 name: crossplane 147 labels: 148 app: crossplane 149 helm.sh/chart: crossplane-1.13.0 150 app.kubernetes.io/managed-by: Helm 151 app.kubernetes.io/component: cloud-infrastructure-controller 152 app.kubernetes.io/part-of: crossplane 153 app.kubernetes.io/name: crossplane 154 app.kubernetes.io/instance: crossplane 155 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 156aggregationRule: 157 clusterRoleSelectors: 158 - matchLabels: 159 rbac.crossplane.io/aggregate-to-crossplane: \u0026#34;true\u0026#34; 160--- 161# Source: crossplane/templates/clusterrole.yaml 162apiVersion: rbac.authorization.k8s.io/v1 163kind: ClusterRole 164metadata: 165 name: crossplane:system:aggregate-to-crossplane 166 labels: 167 app: crossplane 168 helm.sh/chart: crossplane-1.13.0 169 app.kubernetes.io/managed-by: Helm 170 app.kubernetes.io/component: cloud-infrastructure-controller 171 app.kubernetes.io/part-of: crossplane 172 app.kubernetes.io/name: crossplane 173 app.kubernetes.io/instance: crossplane 174 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 175 crossplane.io/scope: \u0026#34;system\u0026#34; 176 rbac.crossplane.io/aggregate-to-crossplane: \u0026#34;true\u0026#34; 177rules: 178- apiGroups: 179 - \u0026#34;\u0026#34; 180 resources: 181 - events 182 verbs: 183 - create 184 - update 185 - patch 186 - delete 187- apiGroups: 188 - apiextensions.k8s.io 189 resources: 190 - customresourcedefinitions 191 verbs: 192 - \u0026#34;*\u0026#34; 193- apiGroups: 194 - \u0026#34;\u0026#34; 195 resources: 196 - secrets 197 verbs: 198 - get 199 - list 200 - watch 201 - create 202 - update 203 - patch 204 - delete 205- apiGroups: 206 - \u0026#34;\u0026#34; 207 resources: 208 - serviceaccounts 209 - services 210 verbs: 211 - \u0026#34;*\u0026#34; 212- apiGroups: 213 - apiextensions.crossplane.io 214 - pkg.crossplane.io 215 - secrets.crossplane.io 216 resources: 217 - \u0026#34;*\u0026#34; 218 verbs: 219 - \u0026#34;*\u0026#34; 220- apiGroups: 221 - extensions 222 - apps 223 resources: 224 - deployments 225 verbs: 226 - get 227 - list 228 - create 229 - update 230 - patch 231 - delete 232 - watch 233- apiGroups: 234 - \u0026#34;\u0026#34; 235 - coordination.k8s.io 236 resources: 237 - configmaps 238 - leases 239 verbs: 240 - get 241 - list 242 - create 243 - update 244 - patch 245 - watch 246 - delete 247- apiGroups: 248 - admissionregistration.k8s.io 249 resources: 250 - validatingwebhookconfigurations 251 - mutatingwebhookconfigurations 252 verbs: 253 - get 254 - list 255 - create 256 - update 257 - patch 258 - watch 259 - delete 260--- 261# Source: crossplane/templates/rbac-manager-allowed-provider-permissions.yaml 262apiVersion: rbac.authorization.k8s.io/v1 263kind: ClusterRole 264metadata: 265 name: crossplane:allowed-provider-permissions 266 labels: 267 app: crossplane 268 helm.sh/chart: crossplane-1.13.0 269 app.kubernetes.io/managed-by: Helm 270 app.kubernetes.io/component: cloud-infrastructure-controller 271 app.kubernetes.io/part-of: crossplane 272 app.kubernetes.io/name: crossplane 273 app.kubernetes.io/instance: crossplane 274 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 275aggregationRule: 276 clusterRoleSelectors: 277 - matchLabels: 278 rbac.crossplane.io/aggregate-to-allowed-provider-permissions: \u0026#34;true\u0026#34; 279--- 280# Source: crossplane/templates/rbac-manager-clusterrole.yaml 281apiVersion: rbac.authorization.k8s.io/v1 282kind: ClusterRole 283metadata: 284 name: crossplane-rbac-manager 285 labels: 286 app: crossplane 287 helm.sh/chart: crossplane-1.13.0 288 app.kubernetes.io/managed-by: Helm 289 app.kubernetes.io/component: cloud-infrastructure-controller 290 app.kubernetes.io/part-of: crossplane 291 app.kubernetes.io/name: crossplane 292 app.kubernetes.io/instance: crossplane 293 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 294rules: 295- apiGroups: 296 - \u0026#34;\u0026#34; 297 resources: 298 - events 299 verbs: 300 - create 301 - update 302 - patch 303 - delete 304- apiGroups: 305 - \u0026#34;\u0026#34; 306 resources: 307 - namespaces 308 - serviceaccounts 309 verbs: 310 - get 311 - list 312 - watch 313# The RBAC manager creates a series of RBAC roles for each namespace it sees. 314# These RBAC roles are controlled (in the owner reference sense) by the namespace. 315# The RBAC manager needs permission to set finalizers on Namespaces in order to 316# create resources that block their deletion when the 317# OwnerReferencesPermissionEnforcement admission controller is enabled. 318# See https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#ownerreferencespermissionenforcement 319- apiGroups: 320 - \u0026#34;\u0026#34; 321 resources: 322 - namespaces/finalizers 323 verbs: 324 - update 325- apiGroups: 326 - apiextensions.crossplane.io 327 resources: 328 - compositeresourcedefinitions 329 verbs: 330 - get 331 - list 332 - watch 333# The RBAC manager creates a series of RBAC cluster roles for each XRD it sees. 334# These cluster roles are controlled (in the owner reference sense) by the XRD. 335# The RBAC manager needs permission to set finalizers on XRDs in order to 336# create resources that block their deletion when the 337# OwnerReferencesPermissionEnforcement admission controller is enabled. 338# See https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#ownerreferencespermissionenforcement 339- apiGroups: 340 - apiextensions.crossplane.io 341 resources: 342 - compositeresourcedefinitions/finalizers 343 verbs: 344 - update 345- apiGroups: 346 - pkg.crossplane.io 347 resources: 348 - providerrevisions 349 verbs: 350 - get 351 - list 352 - watch 353# The RBAC manager creates a series of RBAC cluster roles for each ProviderRevision 354# it sees. These cluster roles are controlled (in the owner reference sense) by the 355# ProviderRevision. The RBAC manager needs permission to set finalizers on 356# ProviderRevisions in order to create resources that block their deletion when the 357# OwnerReferencesPermissionEnforcement admission controller is enabled. 358# See https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#ownerreferencespermissionenforcement 359- apiGroups: 360 - pkg.crossplane.io 361 resources: 362 - providerrevisions/finalizers 363 verbs: 364 - update 365- apiGroups: 366 - apiextensions.k8s.io 367 resources: 368 - customresourcedefinitions 369 verbs: 370 - get 371 - list 372 - watch 373- apiGroups: 374 - rbac.authorization.k8s.io 375 resources: 376 - clusterroles 377 - roles 378 verbs: 379 - get 380 - list 381 - watch 382 - create 383 - update 384 - patch 385 # The RBAC manager may grant access it does not have. 386 - escalate 387- apiGroups: 388 - rbac.authorization.k8s.io 389 resources: 390 - clusterroles 391 verbs: 392 - bind 393- apiGroups: 394 - rbac.authorization.k8s.io 395 resources: 396 - clusterrolebindings 397 verbs: 398 - \u0026#34;*\u0026#34; 399- apiGroups: 400 - \u0026#34;\u0026#34; 401 - coordination.k8s.io 402 resources: 403 - configmaps 404 - leases 405 verbs: 406 - get 407 - list 408 - create 409 - update 410 - patch 411 - watch 412 - delete 413--- 414# Source: crossplane/templates/rbac-manager-managed-clusterroles.yaml 415apiVersion: rbac.authorization.k8s.io/v1 416kind: ClusterRole 417metadata: 418 name: crossplane-admin 419 labels: 420 app: crossplane 421 helm.sh/chart: crossplane-1.13.0 422 app.kubernetes.io/managed-by: Helm 423 app.kubernetes.io/component: cloud-infrastructure-controller 424 app.kubernetes.io/part-of: crossplane 425 app.kubernetes.io/name: crossplane 426 app.kubernetes.io/instance: crossplane 427 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 428aggregationRule: 429 clusterRoleSelectors: 430 - matchLabels: 431 rbac.crossplane.io/aggregate-to-admin: \u0026#34;true\u0026#34; 432--- 433# Source: crossplane/templates/rbac-manager-managed-clusterroles.yaml 434apiVersion: rbac.authorization.k8s.io/v1 435kind: ClusterRole 436metadata: 437 name: crossplane-edit 438 labels: 439 app: crossplane 440 helm.sh/chart: crossplane-1.13.0 441 app.kubernetes.io/managed-by: Helm 442 app.kubernetes.io/component: cloud-infrastructure-controller 443 app.kubernetes.io/part-of: crossplane 444 app.kubernetes.io/name: crossplane 445 app.kubernetes.io/instance: crossplane 446 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 447aggregationRule: 448 clusterRoleSelectors: 449 - matchLabels: 450 rbac.crossplane.io/aggregate-to-edit: \u0026#34;true\u0026#34; 451--- 452# Source: crossplane/templates/rbac-manager-managed-clusterroles.yaml 453apiVersion: rbac.authorization.k8s.io/v1 454kind: ClusterRole 455metadata: 456 name: crossplane-view 457 labels: 458 app: crossplane 459 helm.sh/chart: crossplane-1.13.0 460 app.kubernetes.io/managed-by: Helm 461 app.kubernetes.io/component: cloud-infrastructure-controller 462 app.kubernetes.io/part-of: crossplane 463 app.kubernetes.io/name: crossplane 464 app.kubernetes.io/instance: crossplane 465 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 466aggregationRule: 467 clusterRoleSelectors: 468 - matchLabels: 469 rbac.crossplane.io/aggregate-to-view: \u0026#34;true\u0026#34; 470--- 471# Source: crossplane/templates/rbac-manager-managed-clusterroles.yaml 472apiVersion: rbac.authorization.k8s.io/v1 473kind: ClusterRole 474metadata: 475 name: crossplane-browse 476 labels: 477 app: crossplane 478 helm.sh/chart: crossplane-1.13.0 479 app.kubernetes.io/managed-by: Helm 480 app.kubernetes.io/component: cloud-infrastructure-controller 481 app.kubernetes.io/part-of: crossplane 482 app.kubernetes.io/name: crossplane 483 app.kubernetes.io/instance: crossplane 484 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 485aggregationRule: 486 clusterRoleSelectors: 487 - matchLabels: 488 rbac.crossplane.io/aggregate-to-browse: \u0026#34;true\u0026#34; 489--- 490# Source: crossplane/templates/rbac-manager-managed-clusterroles.yaml 491apiVersion: rbac.authorization.k8s.io/v1 492kind: ClusterRole 493metadata: 494 name: crossplane:aggregate-to-admin 495 labels: 496 rbac.crossplane.io/aggregate-to-admin: \u0026#34;true\u0026#34; 497 app: crossplane 498 helm.sh/chart: crossplane-1.13.0 499 app.kubernetes.io/managed-by: Helm 500 app.kubernetes.io/component: cloud-infrastructure-controller 501 app.kubernetes.io/part-of: crossplane 502 app.kubernetes.io/name: crossplane 503 app.kubernetes.io/instance: crossplane 504 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 505rules: 506# Crossplane administrators have access to view events. 507- apiGroups: [\u0026#34;\u0026#34;] 508 resources: [events] 509 verbs: [get, list, watch] 510# Crossplane administrators must create provider credential secrets, and may 511# need to read or otherwise interact with connection secrets. They may also need 512# to create or annotate namespaces. 513- apiGroups: [\u0026#34;\u0026#34;] 514 resources: [secrets, namespaces] 515 verbs: [\u0026#34;*\u0026#34;] 516# Crossplane administrators have access to view the roles that they may be able 517# to grant to other subjects. 518- apiGroups: [rbac.authorization.k8s.io] 519 resources: [clusterroles, roles] 520 verbs: [get, list, watch] 521# Crossplane administrators have access to grant the access they have to other 522# subjects. 523- apiGroups: [rbac.authorization.k8s.io] 524 resources: [clusterrolebindings, rolebindings] 525 verbs: [\u0026#34;*\u0026#34;] 526# Crossplane administrators have full access to built in Crossplane types. 527- apiGroups: 528 - apiextensions.crossplane.io 529 resources: [\u0026#34;*\u0026#34;] 530 verbs: [\u0026#34;*\u0026#34;] 531- apiGroups: 532 - pkg.crossplane.io 533 resources: [locks, providers, configurations, providerrevisions, configurationrevisions] 534 verbs: [\u0026#34;*\u0026#34;] 535# Crossplane administrators have access to view CRDs in order to debug XRDs. 536- apiGroups: [apiextensions.k8s.io] 537 resources: [customresourcedefinitions] 538 verbs: [get, list, watch] 539--- 540# Source: crossplane/templates/rbac-manager-managed-clusterroles.yaml 541apiVersion: rbac.authorization.k8s.io/v1 542kind: ClusterRole 543metadata: 544 name: crossplane:aggregate-to-edit 545 labels: 546 rbac.crossplane.io/aggregate-to-edit: \u0026#34;true\u0026#34; 547 app: crossplane 548 helm.sh/chart: crossplane-1.13.0 549 app.kubernetes.io/managed-by: Helm 550 app.kubernetes.io/component: cloud-infrastructure-controller 551 app.kubernetes.io/part-of: crossplane 552 app.kubernetes.io/name: crossplane 553 app.kubernetes.io/instance: crossplane 554 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 555rules: 556# Crossplane editors have access to view events. 557- apiGroups: [\u0026#34;\u0026#34;] 558 resources: [events] 559 verbs: [get, list, watch] 560# Crossplane editors must create provider credential secrets, and may need to 561# read or otherwise interact with connection secrets. 562- apiGroups: [\u0026#34;\u0026#34;] 563 resources: [secrets] 564 verbs: [\u0026#34;*\u0026#34;] 565# Crossplane editors may see which namespaces exist, but not edit them. 566- apiGroups: [\u0026#34;\u0026#34;] 567 resources: [namespaces] 568 verbs: [get, list, watch] 569# Crossplane editors have full access to built in Crossplane types. 570- apiGroups: 571 - apiextensions.crossplane.io 572 resources: [\u0026#34;*\u0026#34;] 573 verbs: [\u0026#34;*\u0026#34;] 574- apiGroups: 575 - pkg.crossplane.io 576 resources: [locks, providers, configurations, providerrevisions, configurationrevisions] 577 verbs: [\u0026#34;*\u0026#34;] 578--- 579# Source: crossplane/templates/rbac-manager-managed-clusterroles.yaml 580apiVersion: rbac.authorization.k8s.io/v1 581kind: ClusterRole 582metadata: 583 name: crossplane:aggregate-to-view 584 labels: 585 rbac.crossplane.io/aggregate-to-view: \u0026#34;true\u0026#34; 586 app: crossplane 587 helm.sh/chart: crossplane-1.13.0 588 app.kubernetes.io/managed-by: Helm 589 app.kubernetes.io/component: cloud-infrastructure-controller 590 app.kubernetes.io/part-of: crossplane 591 app.kubernetes.io/name: crossplane 592 app.kubernetes.io/instance: crossplane 593 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 594rules: 595# Crossplane viewers have access to view events. 596- apiGroups: [\u0026#34;\u0026#34;] 597 resources: [events] 598 verbs: [get, list, watch] 599# Crossplane viewers may see which namespaces exist. 600- apiGroups: [\u0026#34;\u0026#34;] 601 resources: [namespaces] 602 verbs: [get, list, watch] 603# Crossplane viewers have read-only access to built in Crossplane types. 604- apiGroups: 605 - apiextensions.crossplane.io 606 resources: [\u0026#34;*\u0026#34;] 607 verbs: [get, list, watch] 608- apiGroups: 609 - pkg.crossplane.io 610 resources: [locks, providers, configurations, providerrevisions, configurationrevisions] 611 verbs: [get, list, watch] 612--- 613# Source: crossplane/templates/rbac-manager-managed-clusterroles.yaml 614apiVersion: rbac.authorization.k8s.io/v1 615kind: ClusterRole 616metadata: 617 name: crossplane:aggregate-to-browse 618 labels: 619 rbac.crossplane.io/aggregate-to-browse: \u0026#34;true\u0026#34; 620 app: crossplane 621 helm.sh/chart: crossplane-1.13.0 622 app.kubernetes.io/managed-by: Helm 623 app.kubernetes.io/component: cloud-infrastructure-controller 624 app.kubernetes.io/part-of: crossplane 625 app.kubernetes.io/name: crossplane 626 app.kubernetes.io/instance: crossplane 627 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 628rules: 629# Crossplane browsers have access to view events. 630- apiGroups: [\u0026#34;\u0026#34;] 631 resources: [events] 632 verbs: [get, list, watch] 633# Crossplane browsers have read-only access to compositions and XRDs. This 634# allows them to discover and select an appropriate composition when creating a 635# resource claim. 636- apiGroups: 637 - apiextensions.crossplane.io 638 resources: [\u0026#34;*\u0026#34;] 639 verbs: [get, list, watch] 640--- 641# Source: crossplane/templates/rbac-manager-managed-clusterroles.yaml 642# The below ClusterRoles are aggregated to the namespaced RBAC roles created by 643# the Crossplane RBAC manager when it is running in --manage=All mode. 644apiVersion: rbac.authorization.k8s.io/v1 645kind: ClusterRole 646metadata: 647 name: crossplane:aggregate-to-ns-admin 648 labels: 649 rbac.crossplane.io/aggregate-to-ns-admin: \u0026#34;true\u0026#34; 650 rbac.crossplane.io/base-of-ns-admin: \u0026#34;true\u0026#34; 651 app: crossplane 652 helm.sh/chart: crossplane-1.13.0 653 app.kubernetes.io/managed-by: Helm 654 app.kubernetes.io/component: cloud-infrastructure-controller 655 app.kubernetes.io/part-of: crossplane 656 app.kubernetes.io/name: crossplane 657 app.kubernetes.io/instance: crossplane 658 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 659rules: 660# Crossplane namespace admins have access to view events. 661- apiGroups: [\u0026#34;\u0026#34;] 662 resources: [events] 663 verbs: [get, list, watch] 664# Crossplane namespace admins may need to read or otherwise interact with 665# resource claim connection secrets. 666- apiGroups: [\u0026#34;\u0026#34;] 667 resources: [secrets] 668 verbs: [\u0026#34;*\u0026#34;] 669# Crossplane namespace admins have access to view the roles that they may be 670# able to grant to other subjects. 671- apiGroups: [rbac.authorization.k8s.io] 672 resources: [roles] 673 verbs: [get, list, watch] 674# Crossplane namespace admins have access to grant the access they have to other 675# subjects. 676- apiGroups: [rbac.authorization.k8s.io] 677 resources: [rolebindings] 678 verbs: [\u0026#34;*\u0026#34;] 679--- 680# Source: crossplane/templates/rbac-manager-managed-clusterroles.yaml 681apiVersion: rbac.authorization.k8s.io/v1 682kind: ClusterRole 683metadata: 684 name: crossplane:aggregate-to-ns-edit 685 labels: 686 rbac.crossplane.io/aggregate-to-ns-edit: \u0026#34;true\u0026#34; 687 rbac.crossplane.io/base-of-ns-edit: \u0026#34;true\u0026#34; 688 app: crossplane 689 helm.sh/chart: crossplane-1.13.0 690 app.kubernetes.io/managed-by: Helm 691 app.kubernetes.io/component: cloud-infrastructure-controller 692 app.kubernetes.io/part-of: crossplane 693 app.kubernetes.io/name: crossplane 694 app.kubernetes.io/instance: crossplane 695 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 696rules: 697# Crossplane namespace editors have access to view events. 698- apiGroups: [\u0026#34;\u0026#34;] 699 resources: [events] 700 verbs: [get, list, watch] 701# Crossplane namespace editors may need to read or otherwise interact with 702# resource claim connection secrets. 703- apiGroups: [\u0026#34;\u0026#34;] 704 resources: [secrets] 705 verbs: [\u0026#34;*\u0026#34;] 706--- 707# Source: crossplane/templates/rbac-manager-managed-clusterroles.yaml 708apiVersion: rbac.authorization.k8s.io/v1 709kind: ClusterRole 710metadata: 711 name: crossplane:aggregate-to-ns-view 712 labels: 713 rbac.crossplane.io/aggregate-to-ns-view: \u0026#34;true\u0026#34; 714 rbac.crossplane.io/base-of-ns-view: \u0026#34;true\u0026#34; 715 app: crossplane 716 helm.sh/chart: crossplane-1.13.0 717 app.kubernetes.io/managed-by: Helm 718 app.kubernetes.io/component: cloud-infrastructure-controller 719 app.kubernetes.io/part-of: crossplane 720 app.kubernetes.io/name: crossplane 721 app.kubernetes.io/instance: crossplane 722 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 723rules: 724# Crossplane namespace viewers have access to view events. 725- apiGroups: [\u0026#34;\u0026#34;] 726 resources: [events] 727 verbs: [get, list, watch] 728--- 729# Source: crossplane/templates/clusterrolebinding.yaml 730apiVersion: rbac.authorization.k8s.io/v1 731kind: ClusterRoleBinding 732metadata: 733 name: crossplane 734 labels: 735 app: crossplane 736 helm.sh/chart: crossplane-1.13.0 737 app.kubernetes.io/managed-by: Helm 738 app.kubernetes.io/component: cloud-infrastructure-controller 739 app.kubernetes.io/part-of: crossplane 740 app.kubernetes.io/name: crossplane 741 app.kubernetes.io/instance: crossplane 742 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 743roleRef: 744 apiGroup: rbac.authorization.k8s.io 745 kind: ClusterRole 746 name: crossplane 747subjects: 748- kind: ServiceAccount 749 name: crossplane 750 namespace: crossplane-system 751--- 752# Source: crossplane/templates/rbac-manager-clusterrolebinding.yaml 753apiVersion: rbac.authorization.k8s.io/v1 754kind: ClusterRoleBinding 755metadata: 756 name: crossplane-rbac-manager 757 labels: 758 app: crossplane 759 helm.sh/chart: crossplane-1.13.0 760 app.kubernetes.io/managed-by: Helm 761 app.kubernetes.io/component: cloud-infrastructure-controller 762 app.kubernetes.io/part-of: crossplane 763 app.kubernetes.io/name: crossplane 764 app.kubernetes.io/instance: crossplane 765 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 766roleRef: 767 apiGroup: rbac.authorization.k8s.io 768 kind: ClusterRole 769 name: crossplane-rbac-manager 770subjects: 771- kind: ServiceAccount 772 name: rbac-manager 773 namespace: crossplane-system 774--- 775# Source: crossplane/templates/rbac-manager-managed-clusterroles.yaml 776apiVersion: rbac.authorization.k8s.io/v1 777kind: ClusterRoleBinding 778metadata: 779 name: crossplane-admin 780 labels: 781 app: crossplane 782 helm.sh/chart: crossplane-1.13.0 783 app.kubernetes.io/managed-by: Helm 784 app.kubernetes.io/component: cloud-infrastructure-controller 785 app.kubernetes.io/part-of: crossplane 786 app.kubernetes.io/name: crossplane 787 app.kubernetes.io/instance: crossplane 788 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 789roleRef: 790 apiGroup: rbac.authorization.k8s.io 791 kind: ClusterRole 792 name: crossplane-admin 793subjects: 794- apiGroup: rbac.authorization.k8s.io 795 kind: Group 796 name: crossplane:masters 797--- 798# Source: crossplane/templates/service.yaml 799apiVersion: v1 800kind: Service 801metadata: 802 name: crossplane-webhooks 803 namespace: crossplane-system 804 labels: 805 app: crossplane 806 release: crossplane 807 helm.sh/chart: crossplane-1.13.0 808 app.kubernetes.io/managed-by: Helm 809 app.kubernetes.io/component: cloud-infrastructure-controller 810 app.kubernetes.io/part-of: crossplane 811 app.kubernetes.io/name: crossplane 812 app.kubernetes.io/instance: crossplane 813 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 814spec: 815 selector: 816 app: crossplane 817 release: crossplane 818 ports: 819 - protocol: TCP 820 port: 9443 821 targetPort: 9443 822--- 823# Source: crossplane/templates/deployment.yaml 824apiVersion: apps/v1 825kind: Deployment 826metadata: 827 name: crossplane 828 namespace: crossplane-system 829 labels: 830 app: crossplane 831 release: crossplane 832 helm.sh/chart: crossplane-1.13.0 833 app.kubernetes.io/managed-by: Helm 834 app.kubernetes.io/component: cloud-infrastructure-controller 835 app.kubernetes.io/part-of: crossplane 836 app.kubernetes.io/name: crossplane 837 app.kubernetes.io/instance: crossplane 838 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 839spec: 840 replicas: 1 841 selector: 842 matchLabels: 843 app: crossplane 844 release: crossplane 845 strategy: 846 type: RollingUpdate 847 template: 848 metadata: 849 labels: 850 app: crossplane 851 release: crossplane 852 helm.sh/chart: crossplane-1.13.0 853 app.kubernetes.io/managed-by: Helm 854 app.kubernetes.io/component: cloud-infrastructure-controller 855 app.kubernetes.io/part-of: crossplane 856 app.kubernetes.io/name: crossplane 857 app.kubernetes.io/instance: crossplane 858 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 859 spec: 860 securityContext: 861 {} 862 serviceAccountName: crossplane 863 hostNetwork: false 864 initContainers: 865 - image: \u0026#34;crossplane/crossplane:v1.13.0\u0026#34; 866 args: 867 - core 868 - init 869 imagePullPolicy: IfNotPresent 870 name: crossplane-init 871 resources: 872 limits: 873 cpu: 100m 874 memory: 512Mi 875 requests: 876 cpu: 100m 877 memory: 256Mi 878 securityContext: 879 allowPrivilegeEscalation: false 880 readOnlyRootFilesystem: true 881 runAsGroup: 65532 882 runAsUser: 65532 883 env: 884 - name: GOMAXPROCS 885 valueFrom: 886 resourceFieldRef: 887 containerName: crossplane-init 888 resource: limits.cpu 889 - name: GOMEMLIMIT 890 valueFrom: 891 resourceFieldRef: 892 containerName: crossplane-init 893 resource: limits.memory 894 - name: POD_NAMESPACE 895 valueFrom: 896 fieldRef: 897 fieldPath: metadata.namespace 898 - name: POD_SERVICE_ACCOUNT 899 valueFrom: 900 fieldRef: 901 fieldPath: spec.serviceAccountName 902 - name: \u0026#34;WEBHOOK_TLS_SECRET_NAME\u0026#34; 903 value: webhook-tls-secret 904 - name: \u0026#34;WEBHOOK_SERVICE_NAME\u0026#34; 905 value: crossplane-webhooks 906 - name: \u0026#34;WEBHOOK_SERVICE_NAMESPACE\u0026#34; 907 valueFrom: 908 fieldRef: 909 fieldPath: metadata.namespace 910 - name: \u0026#34;WEBHOOK_SERVICE_PORT\u0026#34; 911 value: \u0026#34;9443\u0026#34; 912 containers: 913 - image: \u0026#34;crossplane/crossplane:v1.13.0\u0026#34; 914 args: 915 - core 916 - start 917 imagePullPolicy: IfNotPresent 918 name: crossplane 919 resources: 920 limits: 921 cpu: 100m 922 memory: 512Mi 923 requests: 924 cpu: 100m 925 memory: 256Mi 926 ports: 927 - name: webhooks 928 containerPort: 9443 929 securityContext: 930 allowPrivilegeEscalation: false 931 readOnlyRootFilesystem: true 932 runAsGroup: 65532 933 runAsUser: 65532 934 env: 935 - name: GOMAXPROCS 936 valueFrom: 937 resourceFieldRef: 938 containerName: crossplane 939 resource: limits.cpu 940 - name: GOMEMLIMIT 941 valueFrom: 942 resourceFieldRef: 943 containerName: crossplane 944 resource: limits.memory 945 - name: POD_NAMESPACE 946 valueFrom: 947 fieldRef: 948 fieldPath: metadata.namespace 949 - name: POD_SERVICE_ACCOUNT 950 valueFrom: 951 fieldRef: 952 fieldPath: spec.serviceAccountName 953 - name: LEADER_ELECTION 954 value: \u0026#34;true\u0026#34; 955 - name: \u0026#34;WEBHOOK_TLS_SECRET_NAME\u0026#34; 956 value: webhook-tls-secret 957 - name: \u0026#34;WEBHOOK_TLS_CERT_DIR\u0026#34; 958 value: /webhook/tls 959 volumeMounts: 960 - mountPath: /cache 961 name: package-cache 962 - mountPath: /webhook/tls 963 name: webhook-tls-secret 964 volumes: 965 - name: package-cache 966 emptyDir: 967 medium: 968 sizeLimit: 20Mi 969 - name: webhook-tls-secret 970 secret: 971 # NOTE(muvaf): The tls.crt is used both by the server (requires it to 972 # be a single cert) and the caBundle fields of webhook configs and CRDs 973 # which can accept a whole bundle of certificates. In order to meet 974 # the requirements of both, we require a single certificate instead of 975 # a bundle. 976 # It\u0026#39;s assumed that initializer generates this anyway, so it should be 977 # fine. 978 secretName: webhook-tls-secret 979--- 980# Source: crossplane/templates/rbac-manager-deployment.yaml 981apiVersion: apps/v1 982kind: Deployment 983metadata: 984 name: crossplane-rbac-manager 985 namespace: crossplane-system 986 labels: 987 app: crossplane-rbac-manager 988 release: crossplane 989 helm.sh/chart: crossplane-1.13.0 990 app.kubernetes.io/managed-by: Helm 991 app.kubernetes.io/component: cloud-infrastructure-controller 992 app.kubernetes.io/part-of: crossplane 993 app.kubernetes.io/name: crossplane 994 app.kubernetes.io/instance: crossplane 995 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 996spec: 997 replicas: 1 998 selector: 999 matchLabels: 1000 app: crossplane-rbac-manager 1001 release: crossplane 1002 strategy: 1003 type: RollingUpdate 1004 template: 1005 metadata: 1006 labels: 1007 app: crossplane-rbac-manager 1008 release: crossplane 1009 helm.sh/chart: crossplane-1.13.0 1010 app.kubernetes.io/managed-by: Helm 1011 app.kubernetes.io/component: cloud-infrastructure-controller 1012 app.kubernetes.io/part-of: crossplane 1013 app.kubernetes.io/name: crossplane 1014 app.kubernetes.io/instance: crossplane 1015 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 1016 spec: 1017 securityContext: 1018 {} 1019 serviceAccountName: rbac-manager 1020 initContainers: 1021 - image: \u0026#34;crossplane/crossplane:v1.13.0\u0026#34; 1022 args: 1023 - rbac 1024 - init 1025 imagePullPolicy: IfNotPresent 1026 name: crossplane-init 1027 resources: 1028 limits: 1029 cpu: 100m 1030 memory: 512Mi 1031 requests: 1032 cpu: 100m 1033 memory: 256Mi 1034 securityContext: 1035 allowPrivilegeEscalation: false 1036 readOnlyRootFilesystem: true 1037 runAsGroup: 65532 1038 runAsUser: 65532 1039 env: 1040 - name: GOMAXPROCS 1041 valueFrom: 1042 resourceFieldRef: 1043 containerName: crossplane-init 1044 resource: limits.cpu 1045 - name: GOMEMLIMIT 1046 valueFrom: 1047 resourceFieldRef: 1048 containerName: crossplane-init 1049 resource: limits.memory 1050 containers: 1051 - image: \u0026#34;crossplane/crossplane:v1.13.0\u0026#34; 1052 args: 1053 - rbac 1054 - start 1055 - --manage=Basic 1056 - --provider-clusterrole=crossplane:allowed-provider-permissions 1057 imagePullPolicy: IfNotPresent 1058 name: crossplane 1059 resources: 1060 limits: 1061 cpu: 100m 1062 memory: 512Mi 1063 requests: 1064 cpu: 100m 1065 memory: 256Mi 1066 securityContext: 1067 allowPrivilegeEscalation: false 1068 readOnlyRootFilesystem: true 1069 runAsGroup: 65532 1070 runAsUser: 65532 1071 env: 1072 - name: GOMAXPROCS 1073 valueFrom: 1074 resourceFieldRef: 1075 containerName: crossplane 1076 resource: limits.cpu 1077 - name: GOMEMLIMIT 1078 valueFrom: 1079 resourceFieldRef: 1080 containerName: crossplane 1081 resource: limits.memory 1082 - name: LEADER_ELECTION 1083 value: \u0026#34;true\u0026#34; 1084 1085NOTES: 1086Release: crossplane 1087 1088Chart Name: crossplane 1089Chart Description: Crossplane is an open source Kubernetes add-on that enables platform teams to assemble infrastructure from multiple vendors, and expose higher level self-service APIs for application teams to consume. 1090Chart Version: 1.13.0 1091Chart Application Version: 1.13.0 1092 1093Kube Version: v1.27.4 Install the Crossplane components using helm install.\n1helm install crossplane \\ 2crossplane-stable/crossplane \\ 3--namespace crossplane-system \\ 4--create-namespace Verify Crossplane installed with kubectl get pods.\n1kubectl get pods -n crossplane-system 2NAME READY STATUS RESTARTS AGE 3crossplane-d4cd8d784-ldcgb 1/1 Running 0 54s 4crossplane-rbac-manager-84769b574-6mw6f 1/1 Running 0 54s Installing Crossplane creates new Kubernetes API end-points.\nLook at the new API end-points with kubectl api-resources | grep crossplane.\n1kubectl api-resources | grep crossplane 2compositeresourcedefinitions xrd,xrds apiextensions.crossplane.io/v1 false CompositeResourceDefinition 3compositionrevisions comprev apiextensions.crossplane.io/v1 false CompositionRevision 4compositions comp apiextensions.crossplane.io/v1 false Composition 5environmentconfigs envcfg apiextensions.crossplane.io/v1alpha1 false EnvironmentConfig 6configurationrevisions pkg.crossplane.io/v1 false ConfigurationRevision 7configurations pkg.crossplane.io/v1 false Configuration 8controllerconfigs pkg.crossplane.io/v1alpha1 false ControllerConfig 9locks pkg.crossplane.io/v1beta1 false Lock 10providerrevisions pkg.crossplane.io/v1 false ProviderRevision 11providers pkg.crossplane.io/v1 false Provider 12storeconfigs secrets.crossplane.io/v1alpha1 false StoreConfig Install the Azure provider Install the Azure Network resource provider into the Kubernetes cluster with a Kubernetes configuration file.\n1cat \u0026lt;\u0026lt;EOF | kubectl apply -f - 2apiVersion: pkg.crossplane.io/v1 3kind: Provider 4metadata: 5 name: provider-azure-network 6spec: 7 package: xpkg.upbound.io/upbound/provider-azure-network:v0.34.0 8EOF The Crossplane Provider installs the Kubernetes Custom Resource Definitions (CRDs) representing Azure Networking services. These CRDs allow you to create Azure resources directly inside Kubernetes.\nVerify the provider installed with kubectl get providers.\n1kubectl get providers 2NAME INSTALLED HEALTHY PACKAGE AGE 3provider-azure-network True True xpkg.upbound.io/upbound/provider-azure-network:v0.34.0 38s 4upbound-provider-family-azure True True xpkg.upbound.io/upbound/provider-family-azure:v0.34.0 26s The Network Provider installs a second Provider, the upbound-provider-family-azure provider.\nThe family provider manages authentication to Azure across all Azure family Providers.\nYou can view the new CRDs with kubectl get crds.\nEvery CRD maps to a unique Azure service Crossplane can provision and manage.\nTip See details about all the supported CRDs in the Upbound Marketplace. Create a Kubernetes secret for Azure The provider requires credentials to create and manage Azure resources. Providers use a Kubernetes Secret to connect the credentials to the provider.\nThis guide generates an Azure service principal JSON file and saves it as a Kubernetes Secret.\nInstall the Azure command-line Generating an authentication file requires the Azure command-line.\nFollow the documentation from Microsoft to Download and install the Azure command-line.\nLog in to the Azure command-line.\naz login Create an Azure service principal Follow the Azure documentation to find your Subscription ID from the Azure Portal.\nUsing the Azure command-line and provide your Subscription ID create a service principal and authentication file.\n1az ad sp create-for-rbac \\ 2--sdk-auth \\ 3--role Owner \\ 4--scopes /subscriptions/ Save your Azure JSON output as azure-credentials.json.\nTip The Azure Provider Authentication documentation describes other authentication methods. Create a Kubernetes secret with the Azure credentials A Kubernetes generic secret has a name and contents. Use kubectl create secret to generate the secret object named azure-secret in the crossplane-system namespace.\nUse the --from-file= argument to set the value to the contents of the azure-credentials.json file.\n1kubectl create secret \\ 2generic azure-secret \\ 3-n crossplane-system \\ 4--from-file=creds=./azure-credentials.json View the secret with kubectl describe secret\nTip The size may be larger if there are extra blank spaces in your text file. 1kubectl describe secret azure-secret -n crossplane-system 2Name: azure-secret 3Namespace: crossplane-system 4Labels: \u0026lt;none\u0026gt; 5Annotations: \u0026lt;none\u0026gt; 6 7Type: Opaque 8 9Data 10==== 11creds: 629 bytes Create a ProviderConfig A ProviderConfig customizes the settings of the Azure Provider.\nApply the ProviderConfig with the command:\n1cat \u0026lt;\u0026lt;EOF | kubectl apply -f - 2apiVersion: azure.upbound.io/v1beta1 3metadata: 4 name: default 5kind: ProviderConfig 6spec: 7 credentials: 8 source: Secret 9 secretRef: 10 namespace: crossplane-system 11 name: azure-secret 12 key: creds 13EOF This attaches the Azure credentials, saved as a Kubernetes secret, as a secretRef.\nThe spec.credentials.secretRef.name value is the name of the Kubernetes secret containing the Azure credentials in the spec.credentials.secretRef.namespace.\nCreate a managed resource A managed resource is anything Crossplane creates and manages outside of the Kubernetes cluster. This example creates an Azure Virtual Network with Crossplane. The Virtual Network is a managed resource.\nTip Add your Azure Resource Group name. Follow the Azure documentation to create a resource group if you don\u0026rsquo;t have one. 1cat \u0026lt;\u0026lt;EOF | kubectl create -f - 2apiVersion: network.azure.upbound.io/v1beta1 3kind: VirtualNetwork 4metadata: 5 name: crossplane-quickstart-network 6spec: 7 forProvider: 8 addressSpace: 9 - 10.0.0.0/16 10 location: \u0026#34;Sweden Central\u0026#34; 11 resourceGroupName: docs 12EOF The apiVersion and kind are from the provider\u0026rsquo;s CRDs.\nThe spec.forProvider.location tells Azure which location to use when deploying the resource.\nUse kubectl get virtualnetwork.network to verify Crossplane created the Azure Virtual Network.\nTip Crossplane created the virtual network when the values READY and SYNCED are True.\nThis may take up to 5 minutes. 1kubectl get virtualnetwork.network 2NAME READY SYNCED EXTERNAL-NAME AGE 3crossplane-quickstart-network True True crossplane-quickstart-network 10m Delete the managed resource Before shutting down your Kubernetes cluster, delete the virtual network just created.\nUse kubectl delete virtualnetwork.network to delete the virtual network.\n1kubectl delete virtualnetwork.network crossplane-quickstart-network 2virtualnetwork.network.azure.upbound.io \u0026#34;crossplane-quickstart-network\u0026#34; deleted Next steps Continue to part 2 to create and use a custom API with Crossplane. Explore Azure resources that Crossplane can configure in the Provider CRD reference. Join the Crossplane Slack and connect with Crossplane users and contributors. ","title":"Azure Quickstart","url":"/v1.14/getting-started/provider-azure/"},{"content":" Important This guide is part 2 of a series.\nPart 1 covers to installing Crossplane and connect your Kubernetes cluster to AWS.\nThis guide walks you through building and accessing a custom API with Crossplane.\nPrerequisites Complete quickstart part 1 connecting Kubernetes to AWS. an AWS account with permissions to create an AWS S3 storage bucket and a DynamoDB instance Skip part 1 and just get started Add the Crossplane Helm repository and install Crossplane 1helm repo add \\ 2crossplane-stable https://charts.crossplane.io/stable 3helm repo update 4 5helm install crossplane \\ 6crossplane-stable/crossplane \\ 7--namespace crossplane-system \\ 8--create-namespace When the Crossplane pods finish installing and are ready, apply the AWS Provider 1cat \u0026lt;\u0026lt;EOF | kubectl apply -f - 2apiVersion: pkg.crossplane.io/v1 3kind: Provider 4metadata: 5 name: provider-aws-s3 6spec: 7 package: xpkg.upbound.io/upbound/provider-aws-s3:v0.37.0 8EOF Create a file with your AWS keys 1[default] 2aws_access_key_id = \u0026lt;aws_access_key\u0026gt; 3aws_secret_access_key = \u0026lt;aws_secret_key\u0026gt; Create a Kubernetes secret from the AWS keys 1kubectl create secret \\ 2generic aws-secret \\ 3-n crossplane-system \\ 4--from-file=creds=./aws-credentials.txt Create a ProviderConfig 1cat \u0026lt;\u0026lt;EOF | kubectl apply -f - 2apiVersion: aws.upbound.io/v1beta1 3kind: ProviderConfig 4metadata: 5 name: default 6spec: 7 credentials: 8 source: Secret 9 secretRef: 10 namespace: crossplane-system 11 name: aws-secret 12 key: creds 13EOF Create a custom API Crossplane allows you to build your own custom APIs for your users, abstracting away details about the cloud provider and their resources. You can make your API as complex or simple as you wish.\nThe custom API is a Kubernetes object.\nHere is an example custom API.\n1apiVersion: database.example.com/v1alpha1 2kind: NoSQL 3metadata: 4 name: my-nosql-database 5spec: 6 location: \u0026#34;US\u0026#34; Like any Kubernetes object the API has a version, kind and spec.\nDefine a group and version To create your own API start by defining an API group and version.\nThe group can be any value, but common convention is to map to a fully qualified domain name.\nThe version shows how mature or stable the API is and increments when changing, adding or removing fields in the API.\nCrossplane doesn\u0026rsquo;t require specific versions or a specific version naming convention, but following Kubernetes API versioning guidelines is strongly recommended.\nv1alpha1 - A new API that may change at any time. v1beta1 - An existing API that\u0026rsquo;s considered stable. Breaking changes are strongly discouraged. v1 - A stable API that doesn\u0026rsquo;t have breaking changes. This guide uses the group database.example.com.\nBecause this is the first version of the API, this guide uses the version v1alpha1.\n1apiVersion: database.example.com/v1alpha1 Define a kind The API group is a logical collection of related APIs. In a group are individual kinds representing different resources.\nFor example a database group may have a Relational and NoSQL kinds.\nThe kind can be anything, but it must be UpperCamelCased.\nThis API\u0026rsquo;s kind is NoSQL\n1apiVersion: database.example.com/v1alpha1 2kind: NoSQL Define a spec The most important part of an API is the schema. The schema defines the inputs accepted from users.\nThis API allows users to provide a location of where to run their cloud resources.\nAll other resource settings can\u0026rsquo;t be configurable by the users. This allows Crossplane to enforce any policies and standards without worrying about user errors.\n1apiVersion: database.example.com/v1alpha1 2kind: NoSQL 3spec: 4 location: \u0026#34;US\u0026#34; Apply the API Crossplane uses Composite Resource Definitions (also called an XRD) to install your custom API in Kubernetes.\nThe XRD spec contains all the information about the API including the group, version, kind and schema.\nThe XRD\u0026rsquo;s name must be the combination of the plural and group.\nThe schema uses the OpenAPIv3 specification to define the API spec.\nThe API defines a location that must be oneOf either EU or US.\nApply this XRD to create the custom API in your Kubernetes cluster.\n1cat \u0026lt;\u0026lt;EOF | kubectl apply -f - 2apiVersion: apiextensions.crossplane.io/v1 3kind: CompositeResourceDefinition 4metadata: 5 name: nosqls.database.example.com 6spec: 7 group: database.example.com 8 names: 9 kind: NoSQL 10 plural: nosqls 11 versions: 12 - name: v1alpha1 13 schema: 14 openAPIV3Schema: 15 type: object 16 properties: 17 spec: 18 type: object 19 properties: 20 location: 21 type: string 22 oneOf: 23 - pattern: \u0026#39;^EU$\u0026#39; 24 - pattern: \u0026#39;^US$\u0026#39; 25 required: 26 - location 27 served: true 28 referenceable: true 29 claimNames: 30 kind: NoSQLClaim 31 plural: nosqlclaim 32EOF Adding the claimNames allows users to access this API either at the cluster level with the nosql endpoint or in a namespace with the nosqlclaim endpoint.\nThe namespace scoped API is a Crossplane Claim.\nTip For more details on the fields and options of Composite Resource Definitions read the XRD documentation. View the installed XRD with kubectl get xrd.\n1kubectl get xrd 2NAME ESTABLISHED OFFERED AGE 3nosqls.database.example.com True True 2s View the new custom API endpoints with kubectl api-resources | grep nosql\n1kubectl api-resources | grep nosql 2nosqlclaim database.example.com/v1alpha1 true NoSQLClaim 3nosqls database.example.com/v1alpha1 false NoSQL Create a deployment template When users access the custom API Crossplane takes their inputs and combines them with a template describing what infrastructure to deploy. Crossplane calls this template a Composition.\nThe Composition defines all the cloud resources to deploy. Each entry in the template is a full resource definitions, defining all the resource settings and metadata like labels and annotations.\nThis template creates an AWS S3 Bucket and a DynamoDB Table.\nCrossplane uses patches to apply the user\u0026rsquo;s input to the resource template.\nThis Composition takes the user\u0026rsquo;s location input and uses it as the region used in the individual resource.\nApply this Composition to your cluster.\n1cat \u0026lt;\u0026lt;EOF | kubectl apply -f - 2apiVersion: apiextensions.crossplane.io/v1 3kind: Composition 4metadata: 5 name: dynamo-with-bucket 6spec: 7 resources: 8 - name: s3Bucket 9 base: 10 apiVersion: s3.aws.upbound.io/v1beta1 11 kind: Bucket 12 metadata: 13 name: crossplane-quickstart-bucket 14 spec: 15 forProvider: 16 region: us-east-2 17 providerConfigRef: 18 name: default 19 patches: 20 - type: FromCompositeFieldPath 21 fromFieldPath: \u0026#34;spec.location\u0026#34; 22 toFieldPath: \u0026#34;spec.forProvider.region\u0026#34; 23 transforms: 24 - type: map 25 map: 26 EU: \u0026#34;eu-north-1\u0026#34; 27 US: \u0026#34;us-east-2\u0026#34; 28 - name: dynamoDB 29 base: 30 apiVersion: dynamodb.aws.upbound.io/v1beta1 31 kind: Table 32 metadata: 33 name: crossplane-quickstart-database 34 spec: 35 forProvider: 36 region: \u0026#34;us-east-2\u0026#34; 37 writeCapacity: 1 38 readCapacity: 1 39 attribute: 40 - name: S3ID 41 type: S 42 hashKey: S3ID 43 patches: 44 - type: FromCompositeFieldPath 45 fromFieldPath: \u0026#34;spec.location\u0026#34; 46 toFieldPath: \u0026#34;spec.forProvider.region\u0026#34; 47 transforms: 48 - type: map 49 map: 50 EU: \u0026#34;eu-north-1\u0026#34; 51 US: \u0026#34;us-east-2\u0026#34; 52 compositeTypeRef: 53 apiVersion: database.example.com/v1alpha1 54 kind: NoSQL 55EOF The compositeTypeRef defines which custom APIs can use this template to create resources.\nTip Read the Composition documentation for more information on configuring Compositions and all the available options.\nRead the Patch and Transform documentation for more information on how Crossplane uses patches to map user inputs to Composition resource templates.\nView the Composition with kubectl get composition\n1kubectl get composition 2NAME XR-KIND XR-APIVERSION AGE 3dynamo-with-bucket NoSQL database.example.com/v1alpha1 3s Install the DynamoDB Provider Part 1 only installed the AWS S3 Provider. Deploying a DynamoDB Table requires the DynamoDB Provider as well.\nAdd the new Provider to the cluster.\n1cat \u0026lt;\u0026lt;EOF | kubectl apply -f - 2apiVersion: pkg.crossplane.io/v1 3kind: Provider 4metadata: 5 name: provider-aws-dynamodb 6spec: 7 package: xpkg.upbound.io/upbound/provider-aws-dynamodb:v0.37.0 8EOF View the new DynamoDB provider with kubectl get providers.\n1kubectl get providers 2NAME INSTALLED HEALTHY PACKAGE AGE 3provider-aws-dynamodb True True xpkg.upbound.io/upbound/provider-aws-dynamodb:v0.37.0 13m 4provider-aws-s3 True True xpkg.upbound.io/upbound/provider-aws-s3:v0.37.0 14m 5upbound-provider-family-aws True True xpkg.upbound.io/upbound/provider-family-aws:v0.37.0 14m Access the custom API With the custom API (XRD) installed and associated to a resource template (Composition) users can access the API to create resources.\nCreate a NoSQL object to create the cloud resources.\n1cat \u0026lt;\u0026lt;EOF | kubectl apply -f - 2apiVersion: database.example.com/v1alpha1 3kind: NoSQL 4metadata: 5 name: my-nosql-database 6spec: 7 location: \u0026#34;US\u0026#34; 8EOF View the resource with kubectl get nosql.\n1kubectl get nosql 2NAME SYNCED READY COMPOSITION AGE 3my-nosql-database True True dynamo-with-bucket 3m35s This object is a Crossplane composite resource (also called an XR).\nIt\u0026rsquo;s a single object representing the collection of resources created from the Composition template.\nView the individual resources with kubectl get managed\n1kubectl get managed 2NAME READY SYNCED EXTERNAL-NAME AGE 3table.dynamodb.aws.upbound.io/my-nosql-database-r94gq True True my-nosql-database-r94gq 5m28s 4 5NAME READY SYNCED EXTERNAL-NAME AGE 6bucket.s3.aws.upbound.io/my-nosql-database-2j65t True True my-nosql-database-2j65t 5m28s Delete the resources with kubectl delete nosql.\n1kubectl delete nosql my-nosql-database 2nosql.database.example.com \u0026#34;my-nosql-database\u0026#34; deleted Verify Crossplane deleted the resources with kubectl get managed\nNote It may take up to 5 minutes to delete the resources. 1kubectl get managed 2No resources found Using the API with namespaces Accessing the API nosql happens at the cluster scope.\nMost organizations isolate their users into namespaces.\nA Crossplane Claim is the custom API in a namespace.\nCreating a Claim is just like accessing the custom API endpoint, but with the kind from the custom API\u0026rsquo;s claimNames.\nCreate a new namespace to test create a Claim in.\n1kubectl create namespace crossplane-test Then create a Claim in the crossplane-test namespace.\n1cat \u0026lt;\u0026lt;EOF | kubectl apply -f - 2apiVersion: database.example.com/v1alpha1 3kind: NoSQLClaim 4metadata: 5 name: my-nosql-database 6 namespace: crossplane-test 7spec: 8 location: \u0026#34;US\u0026#34; 9EOF View the Claim with kubectl get claim -n crossplane-test.\n1kubectl get claim -n crossplane-test 2NAME SYNCED READY CONNECTION-SECRET AGE 3my-nosql-database True True 42s The Claim automatically creates a composite resource, which creates the managed resources.\nView the Crossplane created composite resource with kubectl get composite.\n1kubectl get composite 2NAME SYNCED READY COMPOSITION AGE 3my-nosql-database-t9qrw True True dynamo-with-bucket 77s Again, view the managed resources with kubectl get managed.\n1kubectl get managed 2NAME READY SYNCED EXTERNAL-NAME AGE 3table.dynamodb.aws.upbound.io/my-nosql-database-t9qrw-dcpwv True True my-nosql-database-t9qrw-dcpwv 116s 4 5NAME READY SYNCED EXTERNAL-NAME AGE 6bucket.s3.aws.upbound.io/my-nosql-database-t9qrw-g98lv True True my-nosql-database-t9qrw-g98lv 117s Deleting the Claim deletes all the Crossplane generated resources.\nkubectl delete claim -n crossplane-test my-nosql-database\n1kubectl delete claim -n crossplane-test my-nosql-database 2nosqlclaim.database.example.com \u0026#34;my-nosql-database\u0026#34; deleted Note It may take up to 5 minutes to delete the resources. Verify Crossplane deleted the composite resource with kubectl get composite.\n1kubectl get composite 2No resources found Verify Crossplane deleted the managed resources with kubectl get managed.\n1kubectl get managed 2No resources found Next steps Explore AWS resources that Crossplane can configure in the Provider CRD reference. Join the Crossplane Slack and connect with Crossplane users and contributors. Read more about the Crossplane concepts to find out what else you can do with Crossplane. ","title":"AWS Quickstart Part 2","url":"/v1.14/getting-started/provider-aws-part-2/"},{"content":" Important This guide is part 2 of a series.\nPart 1 covers to installing Crossplane and connect your Kubernetes cluster to Azure.\nThis guide walks you through building and accessing a custom API with Crossplane.\nPrerequisites Complete quickstart part 1 connecting Kubernetes to Azure. an Azure account with permissions to create an Azure Virtual Machine, Resource Group and Virtual Networking. Skip part 1 and just get started Add the Crossplane Helm repository and install Crossplane 1helm repo add \\ 2crossplane-stable https://charts.crossplane.io/stable 3helm repo update 4\u0026amp;\u0026amp; 5helm install crossplane \\ 6crossplane-stable/crossplane \\ 7--namespace crossplane-system \\ 8--create-namespace When the Crossplane pods finish installing and are ready, apply the Azure Provider 1cat \u0026lt;\u0026lt;EOF | kubectl apply -f - 2apiVersion: pkg.crossplane.io/v1 3kind: Provider 4metadata: 5 name: provider-azure-network 6spec: 7 package: xpkg.upbound.io/upbound/provider-azure-network:v0.34.0 8EOF Use the Azure CLI to create a service principal and save the JSON output as azure-crednetials.json 1az ad sp create-for-rbac \\ 2--sdk-auth \\ 3--role Owner \\ 4--scopes /subscriptions/ Create a Kubernetes secret from the Azure JSON file. 1kubectl create secret \\ 2generic azure-secret \\ 3-n crossplane-system \\ 4--from-file=creds=./azure-credentials.json Create a ProviderConfig 1cat \u0026lt;\u0026lt;EOF | kubectl apply -f - 2apiVersion: azure.upbound.io/v1beta1 3metadata: 4 name: default 5kind: ProviderConfig 6spec: 7 credentials: 8 source: Secret 9 secretRef: 10 namespace: crossplane-system 11 name: azure-secret 12 key: creds 13EOF Create a custom API Crossplane allows you to build your own custom APIs for your users, abstracting away details about the cloud provider and their resources. You can make your API as complex or simple as you wish.\nThe custom API is a Kubernetes object.\nHere is an example custom API.\n1apiVersion: compute.example.com/v1alpha1 2kind: VirtualMachine 3metadata: 4 name: my-vm 5spec: 6 location: \u0026#34;US\u0026#34; Like any Kubernetes object the API has a version, kind and spec.\nDefine a group and version To create your own API start by defining an API group and version.\nThe group can be any value, but common convention is to map to a fully qualified domain name.\nThe version shows how mature or stable the API is and increments when changing, adding or removing fields in the API.\nCrossplane doesn\u0026rsquo;t require specific versions or a specific version naming convention, but following Kubernetes API versioning guidelines is strongly recommended.\nv1alpha1 - A new API that may change at any time. v1beta1 - An existing API that\u0026rsquo;s considered stable. Breaking changes are strongly discouraged. v1 - A stable API that doesn\u0026rsquo;t have breaking changes. This guide uses the group compute.example.com.\nBecause this is the first version of the API, this guide uses the version v1alpha1.\n1apiVersion: compute.example.com/v1alpha1 Define a kind The API group is a logical collection of related APIs. In a group are individual kinds representing different resources.\nFor example a compute group may have a VirtualMachine and BareMetal kinds.\nThe kind can be anything, but it must be UpperCamelCased.\nThis API\u0026rsquo;s kind is VirtualMachine\n1apiVersion: compute.example.com/v1alpha1 2kind: VirtualMachine Define a spec The most important part of an API is the schema. The schema defines the inputs accepted from users.\nThis API allows users to provide a location of where to run their cloud resources.\nAll other resource settings can\u0026rsquo;t be configurable by the users. This allows Crossplane to enforce any policies and standards without worrying about user errors.\n1apiVersion: compute.example.com/v1alpha1 2kind: VirtualMachine 3spec: 4 location: \u0026#34;US\u0026#34; Apply the API Crossplane uses Composite Resource Definitions (also called an XRD) to install your custom API in Kubernetes.\nThe XRD spec contains all the information about the API including the group, version, kind and schema.\nThe XRD\u0026rsquo;s name must be the combination of the plural and group.\nThe schema uses the OpenAPIv3 specification to define the API spec.\nThe API defines a location that must be oneOf either EU or US.\nApply this XRD to create the custom API in your Kubernetes cluster.\n1cat \u0026lt;\u0026lt;EOF | kubectl apply -f - 2apiVersion: apiextensions.crossplane.io/v1 3kind: CompositeResourceDefinition 4metadata: 5 name: virtualmachines.compute.example.com 6spec: 7 group: compute.example.com 8 names: 9 kind: VirtualMachine 10 plural: virtualmachines 11 versions: 12 - name: v1alpha1 13 schema: 14 openAPIV3Schema: 15 type: object 16 properties: 17 spec: 18 type: object 19 properties: 20 location: 21 type: string 22 oneOf: 23 - pattern: \u0026#39;^EU$\u0026#39; 24 - pattern: \u0026#39;^US$\u0026#39; 25 required: 26 - location 27 served: true 28 referenceable: true 29 claimNames: 30 kind: VirtualMachineClaim 31 plural: virtualmachineclaims 32EOF Adding the claimNames allows users to access this API either at the cluster level with the VirtualMachine endpoint or in a namespace with the VirtualMachineClaim endpoint.\nThe namespace scoped API is a Crossplane Claim.\nTip For more details on the fields and options of Composite Resource Definitions read the XRD documentation. View the installed XRD with kubectl get xrd.\n1kubectl get xrd 2NAME ESTABLISHED OFFERED AGE 3virtualmachines.compute.example.com True True 43s View the new custom API endpoints with kubectl api-resources | grep VirtualMachine\n1kubectl api-resources | grep VirtualMachine 2virtualmachineclaims compute.example.com/v1alpha1 true VirtualMachineClaim 3virtualmachines compute.example.com/v1alpha1 false VirtualMachine Create a deployment template When users access the custom API Crossplane takes their inputs and combines them with a template describing what infrastructure to deploy. Crossplane calls this template a Composition.\nThe Composition defines all the cloud resources to deploy. Each entry in the template is a full resource definitions, defining all the resource settings and metadata like labels and annotations.\nThis template creates an Azure LinuxVirtualMachine NetworkInterface, Subnet VirtualNetwork and ResourceGroup.\nCrossplane uses patches to apply the user\u0026rsquo;s input to the resource template.\nThis Composition takes the user\u0026rsquo;s location input and uses it as the location used in the individual resource.\nApply this Composition to your cluster.\n1cat \u0026lt;\u0026lt;EOF | kubectl apply -f - 2apiVersion: apiextensions.crossplane.io/v1 3kind: Composition 4metadata: 5 name: crossplane-quickstart-vm-with-network 6spec: 7 resources: 8 - name: quickstart-vm 9 base: 10 apiVersion: compute.azure.upbound.io/v1beta1 11 kind: LinuxVirtualMachine 12 spec: 13 forProvider: 14 adminUsername: adminuser 15 adminSshKey: 16 - publicKey: ssh-rsa 17 AAAAB3NzaC1yc2EAAAADAQABAAABAQC+wWK73dCr+jgQOAxNsHAnNNNMEMWOHYEccp6wJm2gotpr9katuF/ZAdou5AaW1C61slRkHRkpRRX9FA9CYBiitZgvCCz+3nWNN7l/Up54Zps/pHWGZLHNJZRYyAB6j5yVLMVHIHriY49d/GZTZVNB8GoJv9Gakwc/fuEZYYl4YDFiGMBP///TzlI4jhiJzjKnEvqPFki5p2ZRJqcbCiF4pJrxUQR/RXqVFQdbRLZgYfJ8xGB878RENq3yQ39d8dVOkq4edbkzwcUmwwwkYVPIoDGsYLaRHnG+To7FvMeyO7xDVQkMKzopTQV8AuKpyvpqu0a9pWOMaiCyDytO7GGN 18 example@docs.crossplane.io 19 username: adminuser 20 location: \u0026#34;Central US\u0026#34; 21 osDisk: 22 - caching: ReadWrite 23 storageAccountType: Standard_LRS 24 resourceGroupNameSelector: 25 matchControllerRef: true 26 size: Standard_B1ms 27 sourceImageReference: 28 - offer: debian-11 29 publisher: Debian 30 sku: 11-backports-gen2 31 version: latest 32 networkInterfaceIdsSelector: 33 matchControllerRef: true 34 patches: 35 - type: FromCompositeFieldPath 36 fromFieldPath: \u0026#34;spec.location\u0026#34; 37 toFieldPath: \u0026#34;spec.forProvider.location\u0026#34; 38 transforms: 39 - type: map 40 map: 41 EU: \u0026#34;Sweden Central\u0026#34; 42 US: \u0026#34;Central US\u0026#34; 43 - name: quickstart-nic 44 base: 45 apiVersion: network.azure.upbound.io/v1beta1 46 kind: NetworkInterface 47 spec: 48 forProvider: 49 ipConfiguration: 50 - name: crossplane-quickstart-configuration 51 privateIpAddressAllocation: Dynamic 52 subnetIdSelector: 53 matchControllerRef: true 54 location: \u0026#34;Central US\u0026#34; 55 resourceGroupNameSelector: 56 matchControllerRef: true 57 patches: 58 - type: FromCompositeFieldPath 59 fromFieldPath: \u0026#34;spec.location\u0026#34; 60 toFieldPath: \u0026#34;spec.forProvider.location\u0026#34; 61 transforms: 62 - type: map 63 map: 64 EU: \u0026#34;Sweden Central\u0026#34; 65 US: \u0026#34;Central US\u0026#34; 66 - name: quickstart-subnet 67 base: 68 apiVersion: network.azure.upbound.io/v1beta1 69 kind: Subnet 70 spec: 71 forProvider: 72 addressPrefixes: 73 - 10.0.1.0/24 74 virtualNetworkNameSelector: 75 matchControllerRef: true 76 resourceGroupNameSelector: 77 matchControllerRef: true 78 patches: 79 - type: FromCompositeFieldPath 80 fromFieldPath: \u0026#34;spec.location\u0026#34; 81 toFieldPath: \u0026#34;spec.forProvider.location\u0026#34; 82 transforms: 83 - type: map 84 map: 85 EU: \u0026#34;Sweden Central\u0026#34; 86 US: \u0026#34;Central US\u0026#34; 87 - name: quickstart-network 88 base: 89 apiVersion: network.azure.upbound.io/v1beta1 90 kind: VirtualNetwork 91 spec: 92 forProvider: 93 addressSpace: 94 - 10.0.0.0/16 95 location: \u0026#34;Central US\u0026#34; 96 resourceGroupNameSelector: 97 matchControllerRef: true 98 patches: 99 - type: FromCompositeFieldPath 100 fromFieldPath: \u0026#34;spec.location\u0026#34; 101 toFieldPath: \u0026#34;spec.forProvider.location\u0026#34; 102 transforms: 103 - type: map 104 map: 105 EU: \u0026#34;Sweden Central\u0026#34; 106 US: \u0026#34;Central US\u0026#34; 107 - name: crossplane-resourcegroup 108 base: 109 apiVersion: azure.upbound.io/v1beta1 110 kind: ResourceGroup 111 spec: 112 forProvider: 113 location: Central US 114 patches: 115 - type: FromCompositeFieldPath 116 fromFieldPath: \u0026#34;spec.location\u0026#34; 117 toFieldPath: \u0026#34;spec.forProvider.location\u0026#34; 118 transforms: 119 - type: map 120 map: 121 EU: \u0026#34;Sweden Central\u0026#34; 122 US: \u0026#34;Central US\u0026#34; 123 compositeTypeRef: 124 apiVersion: compute.example.com/v1alpha1 125 kind: VirtualMachine 126EOF The compositeTypeRef defines which custom APIs can use this template to create resources.\nTip Read the Composition documentation for more information on configuring Compositions and all the available options.\nRead the Patch and Transform documentation for more information on how Crossplane uses patches to map user inputs to Composition resource templates.\nView the Composition with kubectl get composition\n1kubectl get composition 2NAME XR-KIND XR-APIVERSION AGE 3crossplane-quickstart-vm-with-network XVirtualMachine custom-api.example.org/v1alpha1 77s Install the Azure virtual machine provider Part 1 only installed the Azure Virtual Network Provider. To deploying virtual machines requires the Azure Compute provider as well.\nAdd the new Provider to the cluster.\n1cat \u0026lt;\u0026lt;EOF | kubectl apply -f - 2apiVersion: pkg.crossplane.io/v1 3kind: Provider 4metadata: 5 name: provider-azure-compute 6spec: 7 package: xpkg.upbound.io/upbound/provider-azure-compute:v0.34.0 8EOF View the new Compute provider with kubectl get providers.\n1kubectl get providers 2NAME INSTALLED HEALTHY PACKAGE AGE 3provider-azure-compute True True xpkg.upbound.io/upbound/provider-azure-compute:v0.34.0 25s 4provider-azure-network True True xpkg.upbound.io/upbound/provider-azure-network:v0.34.0 3h 5upbound-provider-family-azure True True xpkg.upbound.io/upbound/provider-family-azure:v0.34.0 3h Access the custom API With the custom API (XRD) installed and associated to a resource template (Composition) users can access the API to create resources.\nCreate a VirtualMachine object to create the cloud resources.\n1cat \u0026lt;\u0026lt;EOF | kubectl apply -f - 2apiVersion: compute.example.com/v1alpha1 3kind: VirtualMachine 4metadata: 5 name: my-vm 6spec: 7 location: \u0026#34;EU\u0026#34; 8EOF View the resource with kubectl get VirtualMachine.\nNote It may take up to five minutes for the resources to provision. 1kubectl get VirtualMachine 2NAME SYNCED READY COMPOSITION AGE 3my-vm True True crossplane-quickstart-vm-with-network 3m3s This object is a Crossplane composite resource (also called an XR).\nIt\u0026rsquo;s a single object representing the collection of resources created from the Composition template.\nView the individual resources with kubectl get managed\n1kubectl get managed 2NAME READY SYNCED EXTERNAL-NAME AGE 3resourcegroup.azure.upbound.io/my-vm-7jb4n True True my-vm-7jb4n 3m43s 4 5NAME READY SYNCED EXTERNAL-NAME AGE 6linuxvirtualmachine.compute.azure.upbound.io/my-vm-5h7p4 True True my-vm-5h7p4 3m43s 7 8NAME READY SYNCED EXTERNAL-NAME AGE 9networkinterface.network.azure.upbound.io/my-vm-j7fpx True True my-vm-j7fpx 3m43s 10 11NAME READY SYNCED EXTERNAL-NAME AGE 12subnet.network.azure.upbound.io/my-vm-b2dqt True True my-vm-b2dqt 3m43s 13 14NAME READY SYNCED EXTERNAL-NAME AGE 15virtualnetwork.network.azure.upbound.io/my-vm-pd2sw True True my-vm-pd2sw 3m43s Accessing the API created all five resources defined in the template and linked them together.\nLook at a specific resource to see it\u0026rsquo;s created in the location used in the API.\n1kubectl describe linuxvirtualmachine | grep Location 2 Location: Sweden Central 3 Location: swedencentral Delete the resources with kubectl delete VirtualMachine.\n1kubectl delete VirtualMachine my-vm 2virtualmachine.compute.example.com \u0026#34;my-vm\u0026#34; deleted Verify Crossplane deleted the resources with kubectl get managed\nNote It may take up to 5 minutes to delete the resources. 1kubectl get managed 2No resources found Using the API with namespaces Accessing the API VirtualMachine happens at the cluster scope.\nMost organizations isolate their users into namespaces.\nA Crossplane Claim is the custom API in a namespace.\nCreating a Claim is just like accessing the custom API endpoint, but with the kind from the custom API\u0026rsquo;s claimNames.\nCreate a new namespace to test create a Claim in.\n1kubectl create namespace crossplane-test Then create a Claim in the crossplane-test namespace.\n1cat \u0026lt;\u0026lt;EOF | kubectl apply -f - 2apiVersion: compute.example.com/v1alpha1 3kind: VirtualMachineClaim 4metadata: 5 name: my-namespaced-vm 6 namespace: crossplane-test 7spec: 8 location: \u0026#34;EU\u0026#34; 9EOF View the Claim with kubectl get claim -n crossplane-test.\n1kubectl get claim -n crossplane-test 2NAME SYNCED READY CONNECTION-SECRET AGE 3my-namespaced-vm True True 5m11s The Claim automatically creates a composite resource, which creates the managed resources.\nView the Crossplane created composite resource with kubectl get composite.\n1kubectl get composite 2NAME SYNCED READY COMPOSITION AGE 3my-namespaced-vm-r7gdr True True crossplane-quickstart-vm-with-network 5m33s Again, view the managed resources with kubectl get managed.\n1NAME READY SYNCED EXTERNAL-NAME AGE 2resourcegroup.azure.upbound.io/my-namespaced-vm-r7gdr-cvzw6 True True my-namespaced-vm-r7gdr-cvzw6 5m51s 3 4NAME READY SYNCED EXTERNAL-NAME AGE 5linuxvirtualmachine.compute.azure.upbound.io/my-namespaced-vm-r7gdr-vrbgb True True my-namespaced-vm-r7gdr-vrbgb 5m51s 6 7NAME READY SYNCED EXTERNAL-NAME AGE 8networkinterface.network.azure.upbound.io/my-namespaced-vm-r7gdr-hwrb8 True True my-namespaced-vm-r7gdr-hwrb8 5m51s 9 10NAME READY SYNCED EXTERNAL-NAME AGE 11subnet.network.azure.upbound.io/my-namespaced-vm-r7gdr-gh468 True True my-namespaced-vm-r7gdr-gh468 5m51s 12 13NAME READY SYNCED EXTERNAL-NAME AGE 14virtualnetwork.network.azure.upbound.io/my-namespaced-vm-r7gdr-5qhz7 True True my-namespaced-vm-r7gdr-5qhz7 5m51s Deleting the Claim deletes all the Crossplane generated resources.\nkubectl delete claim -n crossplane-test my-VirtualMachine-database\n1kubectl delete claim -n crossplane-test my-namespaced-vm 2virtualmachineclaim.compute.example.com \u0026#34;my-namespaced-vm\u0026#34; deleted Note It may take up to 5 minutes to delete the resources. Verify Crossplane deleted the composite resource with kubectl get composite.\n1kubectl get composite 2No resources found Verify Crossplane deleted the managed resources with kubectl get managed.\n1kubectl get managed 2No resources found Next steps Explore Azure resources that Crossplane can configure in the Provider CRD reference. Join the Crossplane Slack and connect with Crossplane users and contributors. Read more about the Crossplane concepts to find out what else you can do with Crossplane. ","title":"Azure Quickstart Part 2","url":"/v1.14/getting-started/provider-azure-part-2/"},{"content":" Important This guide is part 2 of a series.\nPart 1 covers to installing Crossplane and connect your Kubernetes cluster to GCP.\nThis guide walks you through building and accessing a custom API with Crossplane.\nPrerequisites Complete quickstart part 1 connecting Kubernetes to GCP. a GCP account with permissions to create a GCP storage bucket and a Pub/Sub topic. Skip part 1 and just get started Add the Crossplane Helm repository and install Crossplane. 1helm repo add \\ 2crossplane-stable https://charts.crossplane.io/stable 3helm repo update 4\u0026amp;\u0026amp; 5helm install crossplane \\ 6crossplane-stable/crossplane \\ 7--namespace crossplane-system \\ 8--create-namespace When the Crossplane pods finish installing and are ready, apply the GCP Provider. 1cat \u0026lt;\u0026lt;EOF | kubectl apply -f - 2apiVersion: pkg.crossplane.io/v1 3kind: Provider 4metadata: 5 name: provider-gcp-storage 6spec: 7 package: xpkg.upbound.io/upbound/provider-gcp-storage:v0.35.0 8EOF Create a file called gcp-credentials.json with your GCP service account JSON file. Tip The GCP documentation provides information on how to generate a service account JSON file. Create a Kubernetes secret from the GCP JSON file 1kubectl create secret \\ 2generic gcp-secret \\ 3-n crossplane-system \\ 4--from-file=creds=./gcp-credentials.json Create a ProviderConfig Include your GCP project ID in the ProviderConfig settings. Tip Find your GCP project ID from the project_id field of the gcp-credentials.json file. 1cat \u0026lt;\u0026lt;EOF | kubectl apply -f - 2apiVersion: gcp.upbound.io/v1beta1 3kind: ProviderConfig 4metadata: 5 name: default 6spec: 7 projectID: 8 credentials: 9 source: Secret 10 secretRef: 11 namespace: crossplane-system 12 name: gcp-secret 13 key: creds 14EOF Create a custom API Crossplane allows you to build your own custom APIs for your users, abstracting away details about the cloud provider and their resources. You can make your API as complex or simple as you wish.\nThe custom API is a Kubernetes object.\nHere is an example custom API.\n1apiVersion: database.example.com/v1alpha1 2kind: NoSQL 3metadata: 4 name: my-nosql-database 5spec: 6 location: \u0026#34;US\u0026#34; Like any Kubernetes object the API has a version, kind and spec.\nDefine a group and version To create your own API start by defining an API group and version.\nThe group can be any value, but common convention is to map to a fully qualified domain name.\nThe version shows how mature or stable the API is and increments when changing, adding or removing fields in the API.\nCrossplane doesn\u0026rsquo;t require specific versions or a specific version naming convention, but following Kubernetes API versioning guidelines is strongly recommended.\nv1alpha1 - A new API that may change at any time. v1beta1 - An existing API that\u0026rsquo;s considered stable. Breaking changes are strongly discouraged. v1 - A stable API that doesn\u0026rsquo;t have breaking changes. This guide uses the group database.example.com.\nBecause this is the first version of the API, this guide uses the version v1alpha1.\n1apiVersion: database.example.com/v1alpha1 Define a kind The API group is a logical collection of related APIs. In a group are individual kinds representing different resources.\nFor example a queue group may have a PubSub and CloudTask kinds.\nThe kind can be anything, but it must be UpperCamelCased.\nThis API\u0026rsquo;s kind is PubSub\n1apiVersion: queue.example.com/v1alpha1 2kind: PubSub Define a spec The most important part of an API is the schema. The schema defines the inputs accepted from users.\nThis API allows users to provide a location of where to run their cloud resources.\nAll other resource settings can\u0026rsquo;t be configurable by the users. This allows Crossplane to enforce any policies and standards without worrying about user errors.\n1apiVersion: queue.example.com/v1alpha1 2kind: PubSub 3spec: 4 location: \u0026#34;US\u0026#34; Apply the API Crossplane uses Composite Resource Definitions (also called an XRD) to install your custom API in Kubernetes.\nThe XRD spec contains all the information about the API including the group, version, kind and schema.\nThe XRD\u0026rsquo;s name must be the combination of the plural and group.\nThe schema uses the OpenAPIv3 specification to define the API spec.\nThe API defines a location that must be oneOf either EU or US.\nApply this XRD to create the custom API in your Kubernetes cluster.\n1cat \u0026lt;\u0026lt;EOF | kubectl apply -f - 2apiVersion: apiextensions.crossplane.io/v1 3kind: CompositeResourceDefinition 4metadata: 5 name: pubsubs.queue.example.com 6spec: 7 group: queue.example.com 8 names: 9 kind: PubSub 10 plural: pubsubs 11 versions: 12 - name: v1alpha1 13 schema: 14 openAPIV3Schema: 15 type: object 16 properties: 17 spec: 18 type: object 19 properties: 20 location: 21 type: string 22 oneOf: 23 - pattern: \u0026#39;^EU$\u0026#39; 24 - pattern: \u0026#39;^US$\u0026#39; 25 required: 26 - location 27 served: true 28 referenceable: true 29 claimNames: 30 kind: PubSubClaim 31 plural: pubsubclaims 32EOF Adding the claimNames allows users to access this API either at the cluster level with the pubsub endpoint or in a namespace with the pubsubclaim endpoint.\nThe namespace scoped API is a Crossplane Claim.\nTip For more details on the fields and options of Composite Resource Definitions read the XRD documentation. View the installed XRD with kubectl get xrd.\n1kubectl get xrd 2NAME ESTABLISHED OFFERED AGE 3pubsubs.queue.example.com True True 7s View the new custom API endpoints with kubectl api-resources | grep pubsub\n1kubectl api-resources | grep pubsub 2pubsubclaims queue.example.com/v1alpha1 true PubSubClaim 3pubsubs queue.example.com/v1alpha1 false PubSub Create a deployment template When users access the custom API Crossplane takes their inputs and combines them with a template describing what infrastructure to deploy. Crossplane calls this template a Composition.\nThe Composition defines all the cloud resources to deploy. Each entry in the template is a full resource definitions, defining all the resource settings and metadata like labels and annotations.\nThis template creates a GCP Storage Bucket and a PubSub Topic.\nCrossplane uses patches to apply the user\u0026rsquo;s input to the resource template.\nThis Composition takes the user\u0026rsquo;s location input and uses it as the location used in the individual resource.\nApply this Composition to your cluster.\n1cat \u0026lt;\u0026lt;EOF | kubectl apply -f - 2apiVersion: apiextensions.crossplane.io/v1 3kind: Composition 4metadata: 5 name: topic-with-bucket 6spec: 7 resources: 8 - name: crossplane-quickstart-bucket 9 base: 10 apiVersion: storage.gcp.upbound.io/v1beta1 11 kind: Bucket 12 spec: 13 forProvider: 14 location: \u0026#34;US\u0026#34; 15 patches: 16 - fromFieldPath: \u0026#34;spec.location\u0026#34; 17 toFieldPath: \u0026#34;spec.forProvider.location\u0026#34; 18 transforms: 19 - type: map 20 map: 21 EU: \u0026#34;EU\u0026#34; 22 US: \u0026#34;US\u0026#34; 23 - name: crossplane-quickstart-topic 24 base: 25 apiVersion: pubsub.gcp.upbound.io/v1beta1 26 kind: Topic 27 spec: 28 forProvider: 29 messageStoragePolicy: 30 - allowedPersistenceRegions: 31 - \u0026#34;us-central1\u0026#34; 32 patches: 33 - fromFieldPath: \u0026#34;spec.location\u0026#34; 34 toFieldPath: \u0026#34;spec.forProvider.messageStoragePolicy[*].allowedPersistenceRegions[*]\u0026#34; 35 transforms: 36 - type: map 37 map: 38 EU: \u0026#34;europe-central2\u0026#34; 39 US: \u0026#34;us-central1\u0026#34; 40 compositeTypeRef: 41 apiVersion: queue.example.com/v1alpha1 42 kind: PubSub 43EOF The compositeTypeRef defines which custom APIs can use this template to create resources.\nTip Read the Composition documentation for more information on configuring Compositions and all the available options.\nRead the Patch and Transform documentation for more information on how Crossplane uses patches to map user inputs to Composition resource templates.\nView the Composition with kubectl get composition\n1kubectl get composition 2NAME XR-KIND XR-APIVERSION AGE 3topic-with-bucket PubSub queue.example.com 3s Install the PubSub Provider Part 1 only installed the GCP Storage Provider. Deploying a PubSub Topic requires the PubSub Provider as well.\nAdd the new Provider to the cluster.\n1cat \u0026lt;\u0026lt;EOF | kubectl apply -f - 2apiVersion: pkg.crossplane.io/v1 3kind: Provider 4metadata: 5 name: provider-gcp-pubsub 6spec: 7 package: xpkg.upbound.io/upbound/provider-gcp-pubsub:v0.35.0 8EOF View the new PubSub provider with kubectl get providers.\n1kubectl get providers 2NAME INSTALLED HEALTHY PACKAGE AGE 3provider-gcp-pubsub True True xpkg.upbound.io/upbound/provider-gcp-pubsub:v0.35.0 7s 4provider-gcp-storage True True xpkg.upbound.io/upbound/provider-gcp-storage:v0.35.0 4h 5upbound-provider-family-gcp True True xpkg.upbound.io/upbound/provider-family-gcp:v0.35.0 4h Access the custom API With the custom API (XRD) installed and associated to a resource template (Composition) users can access the API to create resources.\nCreate a PubSub object to create the cloud resources.\n1cat \u0026lt;\u0026lt;EOF | kubectl apply -f - 2apiVersion: queue.example.com/v1alpha1 3kind: PubSub 4metadata: 5 name: my-pubsub-queue 6spec: 7 location: \u0026#34;US\u0026#34; 8EOF View the resource with kubectl get pubsub.\n1kubectl get pubsub 2NAME SYNCED READY COMPOSITION AGE 3my-pubsub-queue True True topic-with-bucket 2m12s This object is a Crossplane composite resource (also called an XR).\nIt\u0026rsquo;s a single object representing the collection of resources created from the Composition template.\nView the individual resources with kubectl get managed\n1kubectl get managed 2NAME READY SYNCED EXTERNAL-NAME AGE 3topic.pubsub.gcp.upbound.io/my-pubsub-queue-cjswx True True my-pubsub-queue-cjswx 3m4s 4 5NAME READY SYNCED EXTERNAL-NAME AGE 6bucket.storage.gcp.upbound.io/my-pubsub-queue-vljg9 True True my-pubsub-queue-vljg9 3m4s Delete the resources with kubectl delete pubsub.\n1kubectl delete pubsub my-pubsub-queue 2pubsub.queue.example.com \u0026#34;my-pubsub-queue\u0026#34; deleted Verify Crossplane deleted the resources with kubectl get managed\nNote It may take up to 5 minutes to delete the resources. 1kubectl get managed 2No resources found Using the API with namespaces Accessing the API pubsub happens at the cluster scope.\nMost organizations isolate their users into namespaces.\nA Crossplane Claim is the custom API in a namespace.\nCreating a Claim is just like accessing the custom API endpoint, but with the kind from the custom API\u0026rsquo;s claimNames.\nCreate a new namespace to test create a Claim in.\n1kubectl create namespace crossplane-test Then create a Claim in the crossplane-test namespace.\n1cat \u0026lt;\u0026lt;EOF | kubectl apply -f - 2apiVersion: queue.example.com/v1alpha1 3kind: PubSubClaim 4metadata: 5 name: my-pubsub-queue 6 namespace: crossplane-test 7spec: 8 location: \u0026#34;US\u0026#34; 9EOF View the Claim with kubectl get claim -n crossplane-test.\n1kubectl get claim -n crossplane-test 2NAME SYNCED READY CONNECTION-SECRET AGE 3my-pubsub-queue True True 2m10s The Claim automatically creates a composite resource, which creates the managed resources.\nView the Crossplane created composite resource with kubectl get composite.\n1kubectl get composite 2NAME SYNCED READY COMPOSITION AGE 3my-pubsub-queue-7bm9n True True topic-with-bucket 3m10s Again, view the managed resources with kubectl get managed.\n1kubectl get managed 2NAME READY SYNCED EXTERNAL-NAME AGE 3topic.pubsub.gcp.upbound.io/my-pubsub-queue-7bm9n-6kdq4 True True my-pubsub-queue-7bm9n-6kdq4 3m22s 4 5NAME READY SYNCED EXTERNAL-NAME AGE 6bucket.storage.gcp.upbound.io/my-pubsub-queue-7bm9n-hhwx8 True True my-pubsub-queue-7bm9n-hhwx8 3m22s Deleting the Claim deletes all the Crossplane generated resources.\nkubectl delete claim -n crossplane-test my-pubsub-queue\n1kubectl delete claim -n crossplane-test my-pubsub-queue 2pubsubclaim.queue.example.com \u0026#34;my-pubsub-queue\u0026#34; deleted Note It may take up to 5 minutes to delete the resources. Verify Crossplane deleted the composite resource with kubectl get composite.\n1kubectl get composite 2No resources found Verify Crossplane deleted the managed resources with kubectl get managed.\n1kubectl get managed 2No resources found Next steps Explore AWS resources that Crossplane can configure in the Provider CRD reference. Join the Crossplane Slack and connect with Crossplane users and contributors. Read more about the Crossplane concepts to find out what else you can do with Crossplane. ","title":"GCP Quickstart Part 2","url":"/v1.14/getting-started/provider-gcp-part-2/"},{"content":"Connect Crossplane to GCP to create and manage cloud resources from Kubernetes with the Upbound GCP Provider.\nThis guide is in two parts:\nPart 1 walks through installing Crossplane, configuring the provider to authenticate to GCP and creating a Managed Resource in GCP directly from your Kubernetes cluster. This shows Crossplane can communicate with GCP. Part 2 shows how to build and access a custom API with Crossplane. Prerequisites This quickstart requires:\na Kubernetes cluster with at least 2 GB of RAM permissions to create pods and secrets in the Kubernetes cluster Helm version v3.2.0 or later a GCP account with permissions to create a storage bucket GCP account keys GCP Project ID Install Crossplane Crossplane installs into an existing Kubernetes cluster.\nTip If you don\u0026rsquo;t have a Kubernetes cluster create one locally with Kind. Install the Crossplane Helm chart Helm enables Crossplane to install all its Kubernetes components through a Helm Chart.\nEnable the Crossplane Helm Chart repository:\n1helm repo add \\ 2crossplane-stable https://charts.crossplane.io/stable 3helm repo update Run the Helm dry-run to see all the Crossplane components Helm installs.\n1helm install crossplane \\ 2crossplane-stable/crossplane \\ 3--dry-run --debug \\ 4--namespace crossplane-system \\ 5--create-namespace View the Helm dry-run 1helm install crossplane \\ 2crossplane-stable/crossplane \\ 3--dry-run --debug \\ 4--namespace crossplane-system \\ 5--create-namespace 6install.go:200: [debug] Original chart version: \u0026#34;\u0026#34; 7install.go:217: [debug] CHART PATH: /home/vagrant/.cache/helm/repository/crossplane-1.13.0.tgz 8 9NAME: crossplane 10LAST DEPLOYED: Fri Jul 28 13:57:41 2023 11NAMESPACE: crossplane-system 12STATUS: pending-install 13REVISION: 1 14TEST SUITE: None 15USER-SUPPLIED VALUES: 16{} 17 18COMPUTED VALUES: 19affinity: {} 20args: [] 21configuration: 22 packages: [] 23customAnnotations: {} 24customLabels: {} 25deploymentStrategy: RollingUpdate 26extraEnvVarsCrossplane: {} 27extraEnvVarsRBACManager: {} 28extraVolumeMountsCrossplane: {} 29extraVolumesCrossplane: {} 30hostNetwork: false 31image: 32 pullPolicy: IfNotPresent 33 repository: crossplane/crossplane 34 tag: \u0026#34;\u0026#34; 35imagePullSecrets: {} 36leaderElection: true 37metrics: 38 enabled: false 39nodeSelector: {} 40packageCache: 41 configMap: \u0026#34;\u0026#34; 42 medium: \u0026#34;\u0026#34; 43 pvc: \u0026#34;\u0026#34; 44 sizeLimit: 20Mi 45podSecurityContextCrossplane: {} 46podSecurityContextRBACManager: {} 47priorityClassName: \u0026#34;\u0026#34; 48provider: 49 packages: [] 50rbacManager: 51 affinity: {} 52 args: [] 53 deploy: true 54 leaderElection: true 55 managementPolicy: Basic 56 nodeSelector: {} 57 replicas: 1 58 skipAggregatedClusterRoles: false 59 tolerations: [] 60registryCaBundleConfig: 61 key: \u0026#34;\u0026#34; 62 name: \u0026#34;\u0026#34; 63replicas: 1 64resourcesCrossplane: 65 limits: 66 cpu: 100m 67 memory: 512Mi 68 requests: 69 cpu: 100m 70 memory: 256Mi 71resourcesRBACManager: 72 limits: 73 cpu: 100m 74 memory: 512Mi 75 requests: 76 cpu: 100m 77 memory: 256Mi 78securityContextCrossplane: 79 allowPrivilegeEscalation: false 80 readOnlyRootFilesystem: true 81 runAsGroup: 65532 82 runAsUser: 65532 83securityContextRBACManager: 84 allowPrivilegeEscalation: false 85 readOnlyRootFilesystem: true 86 runAsGroup: 65532 87 runAsUser: 65532 88serviceAccount: 89 customAnnotations: {} 90tolerations: [] 91webhooks: 92 enabled: true 93 94HOOKS: 95MANIFEST: 96--- 97# Source: crossplane/templates/rbac-manager-serviceaccount.yaml 98apiVersion: v1 99kind: ServiceAccount 100metadata: 101 name: rbac-manager 102 namespace: crossplane-system 103 labels: 104 app: crossplane 105 helm.sh/chart: crossplane-1.13.0 106 app.kubernetes.io/managed-by: Helm 107 app.kubernetes.io/component: cloud-infrastructure-controller 108 app.kubernetes.io/part-of: crossplane 109 app.kubernetes.io/name: crossplane 110 app.kubernetes.io/instance: crossplane 111 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 112--- 113# Source: crossplane/templates/serviceaccount.yaml 114apiVersion: v1 115kind: ServiceAccount 116metadata: 117 name: crossplane 118 namespace: crossplane-system 119 labels: 120 app: crossplane 121 helm.sh/chart: crossplane-1.13.0 122 app.kubernetes.io/managed-by: Helm 123 app.kubernetes.io/component: cloud-infrastructure-controller 124 app.kubernetes.io/part-of: crossplane 125 app.kubernetes.io/name: crossplane 126 app.kubernetes.io/instance: crossplane 127 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 128--- 129# Source: crossplane/templates/secret.yaml 130# The reason this is created empty and filled by the init container is that it\u0026#39;s 131# mounted by the actual container, so if it wasn\u0026#39;t created by Helm, then the 132# deployment wouldn\u0026#39;t be deployed at all with secret to mount not found error. 133# In addition, Helm would delete this secret after uninstallation so the new 134# installation of Crossplane would use its own certificate. 135apiVersion: v1 136kind: Secret 137metadata: 138 name: webhook-tls-secret 139 namespace: crossplane-system 140type: Opaque 141--- 142# Source: crossplane/templates/clusterrole.yaml 143apiVersion: rbac.authorization.k8s.io/v1 144kind: ClusterRole 145metadata: 146 name: crossplane 147 labels: 148 app: crossplane 149 helm.sh/chart: crossplane-1.13.0 150 app.kubernetes.io/managed-by: Helm 151 app.kubernetes.io/component: cloud-infrastructure-controller 152 app.kubernetes.io/part-of: crossplane 153 app.kubernetes.io/name: crossplane 154 app.kubernetes.io/instance: crossplane 155 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 156aggregationRule: 157 clusterRoleSelectors: 158 - matchLabels: 159 rbac.crossplane.io/aggregate-to-crossplane: \u0026#34;true\u0026#34; 160--- 161# Source: crossplane/templates/clusterrole.yaml 162apiVersion: rbac.authorization.k8s.io/v1 163kind: ClusterRole 164metadata: 165 name: crossplane:system:aggregate-to-crossplane 166 labels: 167 app: crossplane 168 helm.sh/chart: crossplane-1.13.0 169 app.kubernetes.io/managed-by: Helm 170 app.kubernetes.io/component: cloud-infrastructure-controller 171 app.kubernetes.io/part-of: crossplane 172 app.kubernetes.io/name: crossplane 173 app.kubernetes.io/instance: crossplane 174 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 175 crossplane.io/scope: \u0026#34;system\u0026#34; 176 rbac.crossplane.io/aggregate-to-crossplane: \u0026#34;true\u0026#34; 177rules: 178- apiGroups: 179 - \u0026#34;\u0026#34; 180 resources: 181 - events 182 verbs: 183 - create 184 - update 185 - patch 186 - delete 187- apiGroups: 188 - apiextensions.k8s.io 189 resources: 190 - customresourcedefinitions 191 verbs: 192 - \u0026#34;*\u0026#34; 193- apiGroups: 194 - \u0026#34;\u0026#34; 195 resources: 196 - secrets 197 verbs: 198 - get 199 - list 200 - watch 201 - create 202 - update 203 - patch 204 - delete 205- apiGroups: 206 - \u0026#34;\u0026#34; 207 resources: 208 - serviceaccounts 209 - services 210 verbs: 211 - \u0026#34;*\u0026#34; 212- apiGroups: 213 - apiextensions.crossplane.io 214 - pkg.crossplane.io 215 - secrets.crossplane.io 216 resources: 217 - \u0026#34;*\u0026#34; 218 verbs: 219 - \u0026#34;*\u0026#34; 220- apiGroups: 221 - extensions 222 - apps 223 resources: 224 - deployments 225 verbs: 226 - get 227 - list 228 - create 229 - update 230 - patch 231 - delete 232 - watch 233- apiGroups: 234 - \u0026#34;\u0026#34; 235 - coordination.k8s.io 236 resources: 237 - configmaps 238 - leases 239 verbs: 240 - get 241 - list 242 - create 243 - update 244 - patch 245 - watch 246 - delete 247- apiGroups: 248 - admissionregistration.k8s.io 249 resources: 250 - validatingwebhookconfigurations 251 - mutatingwebhookconfigurations 252 verbs: 253 - get 254 - list 255 - create 256 - update 257 - patch 258 - watch 259 - delete 260--- 261# Source: crossplane/templates/rbac-manager-allowed-provider-permissions.yaml 262apiVersion: rbac.authorization.k8s.io/v1 263kind: ClusterRole 264metadata: 265 name: crossplane:allowed-provider-permissions 266 labels: 267 app: crossplane 268 helm.sh/chart: crossplane-1.13.0 269 app.kubernetes.io/managed-by: Helm 270 app.kubernetes.io/component: cloud-infrastructure-controller 271 app.kubernetes.io/part-of: crossplane 272 app.kubernetes.io/name: crossplane 273 app.kubernetes.io/instance: crossplane 274 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 275aggregationRule: 276 clusterRoleSelectors: 277 - matchLabels: 278 rbac.crossplane.io/aggregate-to-allowed-provider-permissions: \u0026#34;true\u0026#34; 279--- 280# Source: crossplane/templates/rbac-manager-clusterrole.yaml 281apiVersion: rbac.authorization.k8s.io/v1 282kind: ClusterRole 283metadata: 284 name: crossplane-rbac-manager 285 labels: 286 app: crossplane 287 helm.sh/chart: crossplane-1.13.0 288 app.kubernetes.io/managed-by: Helm 289 app.kubernetes.io/component: cloud-infrastructure-controller 290 app.kubernetes.io/part-of: crossplane 291 app.kubernetes.io/name: crossplane 292 app.kubernetes.io/instance: crossplane 293 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 294rules: 295- apiGroups: 296 - \u0026#34;\u0026#34; 297 resources: 298 - events 299 verbs: 300 - create 301 - update 302 - patch 303 - delete 304- apiGroups: 305 - \u0026#34;\u0026#34; 306 resources: 307 - namespaces 308 - serviceaccounts 309 verbs: 310 - get 311 - list 312 - watch 313# The RBAC manager creates a series of RBAC roles for each namespace it sees. 314# These RBAC roles are controlled (in the owner reference sense) by the namespace. 315# The RBAC manager needs permission to set finalizers on Namespaces in order to 316# create resources that block their deletion when the 317# OwnerReferencesPermissionEnforcement admission controller is enabled. 318# See https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#ownerreferencespermissionenforcement 319- apiGroups: 320 - \u0026#34;\u0026#34; 321 resources: 322 - namespaces/finalizers 323 verbs: 324 - update 325- apiGroups: 326 - apiextensions.crossplane.io 327 resources: 328 - compositeresourcedefinitions 329 verbs: 330 - get 331 - list 332 - watch 333# The RBAC manager creates a series of RBAC cluster roles for each XRD it sees. 334# These cluster roles are controlled (in the owner reference sense) by the XRD. 335# The RBAC manager needs permission to set finalizers on XRDs in order to 336# create resources that block their deletion when the 337# OwnerReferencesPermissionEnforcement admission controller is enabled. 338# See https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#ownerreferencespermissionenforcement 339- apiGroups: 340 - apiextensions.crossplane.io 341 resources: 342 - compositeresourcedefinitions/finalizers 343 verbs: 344 - update 345- apiGroups: 346 - pkg.crossplane.io 347 resources: 348 - providerrevisions 349 verbs: 350 - get 351 - list 352 - watch 353# The RBAC manager creates a series of RBAC cluster roles for each ProviderRevision 354# it sees. These cluster roles are controlled (in the owner reference sense) by the 355# ProviderRevision. The RBAC manager needs permission to set finalizers on 356# ProviderRevisions in order to create resources that block their deletion when the 357# OwnerReferencesPermissionEnforcement admission controller is enabled. 358# See https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#ownerreferencespermissionenforcement 359- apiGroups: 360 - pkg.crossplane.io 361 resources: 362 - providerrevisions/finalizers 363 verbs: 364 - update 365- apiGroups: 366 - apiextensions.k8s.io 367 resources: 368 - customresourcedefinitions 369 verbs: 370 - get 371 - list 372 - watch 373- apiGroups: 374 - rbac.authorization.k8s.io 375 resources: 376 - clusterroles 377 - roles 378 verbs: 379 - get 380 - list 381 - watch 382 - create 383 - update 384 - patch 385 # The RBAC manager may grant access it does not have. 386 - escalate 387- apiGroups: 388 - rbac.authorization.k8s.io 389 resources: 390 - clusterroles 391 verbs: 392 - bind 393- apiGroups: 394 - rbac.authorization.k8s.io 395 resources: 396 - clusterrolebindings 397 verbs: 398 - \u0026#34;*\u0026#34; 399- apiGroups: 400 - \u0026#34;\u0026#34; 401 - coordination.k8s.io 402 resources: 403 - configmaps 404 - leases 405 verbs: 406 - get 407 - list 408 - create 409 - update 410 - patch 411 - watch 412 - delete 413--- 414# Source: crossplane/templates/rbac-manager-managed-clusterroles.yaml 415apiVersion: rbac.authorization.k8s.io/v1 416kind: ClusterRole 417metadata: 418 name: crossplane-admin 419 labels: 420 app: crossplane 421 helm.sh/chart: crossplane-1.13.0 422 app.kubernetes.io/managed-by: Helm 423 app.kubernetes.io/component: cloud-infrastructure-controller 424 app.kubernetes.io/part-of: crossplane 425 app.kubernetes.io/name: crossplane 426 app.kubernetes.io/instance: crossplane 427 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 428aggregationRule: 429 clusterRoleSelectors: 430 - matchLabels: 431 rbac.crossplane.io/aggregate-to-admin: \u0026#34;true\u0026#34; 432--- 433# Source: crossplane/templates/rbac-manager-managed-clusterroles.yaml 434apiVersion: rbac.authorization.k8s.io/v1 435kind: ClusterRole 436metadata: 437 name: crossplane-edit 438 labels: 439 app: crossplane 440 helm.sh/chart: crossplane-1.13.0 441 app.kubernetes.io/managed-by: Helm 442 app.kubernetes.io/component: cloud-infrastructure-controller 443 app.kubernetes.io/part-of: crossplane 444 app.kubernetes.io/name: crossplane 445 app.kubernetes.io/instance: crossplane 446 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 447aggregationRule: 448 clusterRoleSelectors: 449 - matchLabels: 450 rbac.crossplane.io/aggregate-to-edit: \u0026#34;true\u0026#34; 451--- 452# Source: crossplane/templates/rbac-manager-managed-clusterroles.yaml 453apiVersion: rbac.authorization.k8s.io/v1 454kind: ClusterRole 455metadata: 456 name: crossplane-view 457 labels: 458 app: crossplane 459 helm.sh/chart: crossplane-1.13.0 460 app.kubernetes.io/managed-by: Helm 461 app.kubernetes.io/component: cloud-infrastructure-controller 462 app.kubernetes.io/part-of: crossplane 463 app.kubernetes.io/name: crossplane 464 app.kubernetes.io/instance: crossplane 465 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 466aggregationRule: 467 clusterRoleSelectors: 468 - matchLabels: 469 rbac.crossplane.io/aggregate-to-view: \u0026#34;true\u0026#34; 470--- 471# Source: crossplane/templates/rbac-manager-managed-clusterroles.yaml 472apiVersion: rbac.authorization.k8s.io/v1 473kind: ClusterRole 474metadata: 475 name: crossplane-browse 476 labels: 477 app: crossplane 478 helm.sh/chart: crossplane-1.13.0 479 app.kubernetes.io/managed-by: Helm 480 app.kubernetes.io/component: cloud-infrastructure-controller 481 app.kubernetes.io/part-of: crossplane 482 app.kubernetes.io/name: crossplane 483 app.kubernetes.io/instance: crossplane 484 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 485aggregationRule: 486 clusterRoleSelectors: 487 - matchLabels: 488 rbac.crossplane.io/aggregate-to-browse: \u0026#34;true\u0026#34; 489--- 490# Source: crossplane/templates/rbac-manager-managed-clusterroles.yaml 491apiVersion: rbac.authorization.k8s.io/v1 492kind: ClusterRole 493metadata: 494 name: crossplane:aggregate-to-admin 495 labels: 496 rbac.crossplane.io/aggregate-to-admin: \u0026#34;true\u0026#34; 497 app: crossplane 498 helm.sh/chart: crossplane-1.13.0 499 app.kubernetes.io/managed-by: Helm 500 app.kubernetes.io/component: cloud-infrastructure-controller 501 app.kubernetes.io/part-of: crossplane 502 app.kubernetes.io/name: crossplane 503 app.kubernetes.io/instance: crossplane 504 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 505rules: 506# Crossplane administrators have access to view events. 507- apiGroups: [\u0026#34;\u0026#34;] 508 resources: [events] 509 verbs: [get, list, watch] 510# Crossplane administrators must create provider credential secrets, and may 511# need to read or otherwise interact with connection secrets. They may also need 512# to create or annotate namespaces. 513- apiGroups: [\u0026#34;\u0026#34;] 514 resources: [secrets, namespaces] 515 verbs: [\u0026#34;*\u0026#34;] 516# Crossplane administrators have access to view the roles that they may be able 517# to grant to other subjects. 518- apiGroups: [rbac.authorization.k8s.io] 519 resources: [clusterroles, roles] 520 verbs: [get, list, watch] 521# Crossplane administrators have access to grant the access they have to other 522# subjects. 523- apiGroups: [rbac.authorization.k8s.io] 524 resources: [clusterrolebindings, rolebindings] 525 verbs: [\u0026#34;*\u0026#34;] 526# Crossplane administrators have full access to built in Crossplane types. 527- apiGroups: 528 - apiextensions.crossplane.io 529 resources: [\u0026#34;*\u0026#34;] 530 verbs: [\u0026#34;*\u0026#34;] 531- apiGroups: 532 - pkg.crossplane.io 533 resources: [locks, providers, configurations, providerrevisions, configurationrevisions] 534 verbs: [\u0026#34;*\u0026#34;] 535# Crossplane administrators have access to view CRDs in order to debug XRDs. 536- apiGroups: [apiextensions.k8s.io] 537 resources: [customresourcedefinitions] 538 verbs: [get, list, watch] 539--- 540# Source: crossplane/templates/rbac-manager-managed-clusterroles.yaml 541apiVersion: rbac.authorization.k8s.io/v1 542kind: ClusterRole 543metadata: 544 name: crossplane:aggregate-to-edit 545 labels: 546 rbac.crossplane.io/aggregate-to-edit: \u0026#34;true\u0026#34; 547 app: crossplane 548 helm.sh/chart: crossplane-1.13.0 549 app.kubernetes.io/managed-by: Helm 550 app.kubernetes.io/component: cloud-infrastructure-controller 551 app.kubernetes.io/part-of: crossplane 552 app.kubernetes.io/name: crossplane 553 app.kubernetes.io/instance: crossplane 554 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 555rules: 556# Crossplane editors have access to view events. 557- apiGroups: [\u0026#34;\u0026#34;] 558 resources: [events] 559 verbs: [get, list, watch] 560# Crossplane editors must create provider credential secrets, and may need to 561# read or otherwise interact with connection secrets. 562- apiGroups: [\u0026#34;\u0026#34;] 563 resources: [secrets] 564 verbs: [\u0026#34;*\u0026#34;] 565# Crossplane editors may see which namespaces exist, but not edit them. 566- apiGroups: [\u0026#34;\u0026#34;] 567 resources: [namespaces] 568 verbs: [get, list, watch] 569# Crossplane editors have full access to built in Crossplane types. 570- apiGroups: 571 - apiextensions.crossplane.io 572 resources: [\u0026#34;*\u0026#34;] 573 verbs: [\u0026#34;*\u0026#34;] 574- apiGroups: 575 - pkg.crossplane.io 576 resources: [locks, providers, configurations, providerrevisions, configurationrevisions] 577 verbs: [\u0026#34;*\u0026#34;] 578--- 579# Source: crossplane/templates/rbac-manager-managed-clusterroles.yaml 580apiVersion: rbac.authorization.k8s.io/v1 581kind: ClusterRole 582metadata: 583 name: crossplane:aggregate-to-view 584 labels: 585 rbac.crossplane.io/aggregate-to-view: \u0026#34;true\u0026#34; 586 app: crossplane 587 helm.sh/chart: crossplane-1.13.0 588 app.kubernetes.io/managed-by: Helm 589 app.kubernetes.io/component: cloud-infrastructure-controller 590 app.kubernetes.io/part-of: crossplane 591 app.kubernetes.io/name: crossplane 592 app.kubernetes.io/instance: crossplane 593 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 594rules: 595# Crossplane viewers have access to view events. 596- apiGroups: [\u0026#34;\u0026#34;] 597 resources: [events] 598 verbs: [get, list, watch] 599# Crossplane viewers may see which namespaces exist. 600- apiGroups: [\u0026#34;\u0026#34;] 601 resources: [namespaces] 602 verbs: [get, list, watch] 603# Crossplane viewers have read-only access to built in Crossplane types. 604- apiGroups: 605 - apiextensions.crossplane.io 606 resources: [\u0026#34;*\u0026#34;] 607 verbs: [get, list, watch] 608- apiGroups: 609 - pkg.crossplane.io 610 resources: [locks, providers, configurations, providerrevisions, configurationrevisions] 611 verbs: [get, list, watch] 612--- 613# Source: crossplane/templates/rbac-manager-managed-clusterroles.yaml 614apiVersion: rbac.authorization.k8s.io/v1 615kind: ClusterRole 616metadata: 617 name: crossplane:aggregate-to-browse 618 labels: 619 rbac.crossplane.io/aggregate-to-browse: \u0026#34;true\u0026#34; 620 app: crossplane 621 helm.sh/chart: crossplane-1.13.0 622 app.kubernetes.io/managed-by: Helm 623 app.kubernetes.io/component: cloud-infrastructure-controller 624 app.kubernetes.io/part-of: crossplane 625 app.kubernetes.io/name: crossplane 626 app.kubernetes.io/instance: crossplane 627 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 628rules: 629# Crossplane browsers have access to view events. 630- apiGroups: [\u0026#34;\u0026#34;] 631 resources: [events] 632 verbs: [get, list, watch] 633# Crossplane browsers have read-only access to compositions and XRDs. This 634# allows them to discover and select an appropriate composition when creating a 635# resource claim. 636- apiGroups: 637 - apiextensions.crossplane.io 638 resources: [\u0026#34;*\u0026#34;] 639 verbs: [get, list, watch] 640--- 641# Source: crossplane/templates/rbac-manager-managed-clusterroles.yaml 642# The below ClusterRoles are aggregated to the namespaced RBAC roles created by 643# the Crossplane RBAC manager when it is running in --manage=All mode. 644apiVersion: rbac.authorization.k8s.io/v1 645kind: ClusterRole 646metadata: 647 name: crossplane:aggregate-to-ns-admin 648 labels: 649 rbac.crossplane.io/aggregate-to-ns-admin: \u0026#34;true\u0026#34; 650 rbac.crossplane.io/base-of-ns-admin: \u0026#34;true\u0026#34; 651 app: crossplane 652 helm.sh/chart: crossplane-1.13.0 653 app.kubernetes.io/managed-by: Helm 654 app.kubernetes.io/component: cloud-infrastructure-controller 655 app.kubernetes.io/part-of: crossplane 656 app.kubernetes.io/name: crossplane 657 app.kubernetes.io/instance: crossplane 658 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 659rules: 660# Crossplane namespace admins have access to view events. 661- apiGroups: [\u0026#34;\u0026#34;] 662 resources: [events] 663 verbs: [get, list, watch] 664# Crossplane namespace admins may need to read or otherwise interact with 665# resource claim connection secrets. 666- apiGroups: [\u0026#34;\u0026#34;] 667 resources: [secrets] 668 verbs: [\u0026#34;*\u0026#34;] 669# Crossplane namespace admins have access to view the roles that they may be 670# able to grant to other subjects. 671- apiGroups: [rbac.authorization.k8s.io] 672 resources: [roles] 673 verbs: [get, list, watch] 674# Crossplane namespace admins have access to grant the access they have to other 675# subjects. 676- apiGroups: [rbac.authorization.k8s.io] 677 resources: [rolebindings] 678 verbs: [\u0026#34;*\u0026#34;] 679--- 680# Source: crossplane/templates/rbac-manager-managed-clusterroles.yaml 681apiVersion: rbac.authorization.k8s.io/v1 682kind: ClusterRole 683metadata: 684 name: crossplane:aggregate-to-ns-edit 685 labels: 686 rbac.crossplane.io/aggregate-to-ns-edit: \u0026#34;true\u0026#34; 687 rbac.crossplane.io/base-of-ns-edit: \u0026#34;true\u0026#34; 688 app: crossplane 689 helm.sh/chart: crossplane-1.13.0 690 app.kubernetes.io/managed-by: Helm 691 app.kubernetes.io/component: cloud-infrastructure-controller 692 app.kubernetes.io/part-of: crossplane 693 app.kubernetes.io/name: crossplane 694 app.kubernetes.io/instance: crossplane 695 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 696rules: 697# Crossplane namespace editors have access to view events. 698- apiGroups: [\u0026#34;\u0026#34;] 699 resources: [events] 700 verbs: [get, list, watch] 701# Crossplane namespace editors may need to read or otherwise interact with 702# resource claim connection secrets. 703- apiGroups: [\u0026#34;\u0026#34;] 704 resources: [secrets] 705 verbs: [\u0026#34;*\u0026#34;] 706--- 707# Source: crossplane/templates/rbac-manager-managed-clusterroles.yaml 708apiVersion: rbac.authorization.k8s.io/v1 709kind: ClusterRole 710metadata: 711 name: crossplane:aggregate-to-ns-view 712 labels: 713 rbac.crossplane.io/aggregate-to-ns-view: \u0026#34;true\u0026#34; 714 rbac.crossplane.io/base-of-ns-view: \u0026#34;true\u0026#34; 715 app: crossplane 716 helm.sh/chart: crossplane-1.13.0 717 app.kubernetes.io/managed-by: Helm 718 app.kubernetes.io/component: cloud-infrastructure-controller 719 app.kubernetes.io/part-of: crossplane 720 app.kubernetes.io/name: crossplane 721 app.kubernetes.io/instance: crossplane 722 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 723rules: 724# Crossplane namespace viewers have access to view events. 725- apiGroups: [\u0026#34;\u0026#34;] 726 resources: [events] 727 verbs: [get, list, watch] 728--- 729# Source: crossplane/templates/clusterrolebinding.yaml 730apiVersion: rbac.authorization.k8s.io/v1 731kind: ClusterRoleBinding 732metadata: 733 name: crossplane 734 labels: 735 app: crossplane 736 helm.sh/chart: crossplane-1.13.0 737 app.kubernetes.io/managed-by: Helm 738 app.kubernetes.io/component: cloud-infrastructure-controller 739 app.kubernetes.io/part-of: crossplane 740 app.kubernetes.io/name: crossplane 741 app.kubernetes.io/instance: crossplane 742 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 743roleRef: 744 apiGroup: rbac.authorization.k8s.io 745 kind: ClusterRole 746 name: crossplane 747subjects: 748- kind: ServiceAccount 749 name: crossplane 750 namespace: crossplane-system 751--- 752# Source: crossplane/templates/rbac-manager-clusterrolebinding.yaml 753apiVersion: rbac.authorization.k8s.io/v1 754kind: ClusterRoleBinding 755metadata: 756 name: crossplane-rbac-manager 757 labels: 758 app: crossplane 759 helm.sh/chart: crossplane-1.13.0 760 app.kubernetes.io/managed-by: Helm 761 app.kubernetes.io/component: cloud-infrastructure-controller 762 app.kubernetes.io/part-of: crossplane 763 app.kubernetes.io/name: crossplane 764 app.kubernetes.io/instance: crossplane 765 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 766roleRef: 767 apiGroup: rbac.authorization.k8s.io 768 kind: ClusterRole 769 name: crossplane-rbac-manager 770subjects: 771- kind: ServiceAccount 772 name: rbac-manager 773 namespace: crossplane-system 774--- 775# Source: crossplane/templates/rbac-manager-managed-clusterroles.yaml 776apiVersion: rbac.authorization.k8s.io/v1 777kind: ClusterRoleBinding 778metadata: 779 name: crossplane-admin 780 labels: 781 app: crossplane 782 helm.sh/chart: crossplane-1.13.0 783 app.kubernetes.io/managed-by: Helm 784 app.kubernetes.io/component: cloud-infrastructure-controller 785 app.kubernetes.io/part-of: crossplane 786 app.kubernetes.io/name: crossplane 787 app.kubernetes.io/instance: crossplane 788 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 789roleRef: 790 apiGroup: rbac.authorization.k8s.io 791 kind: ClusterRole 792 name: crossplane-admin 793subjects: 794- apiGroup: rbac.authorization.k8s.io 795 kind: Group 796 name: crossplane:masters 797--- 798# Source: crossplane/templates/service.yaml 799apiVersion: v1 800kind: Service 801metadata: 802 name: crossplane-webhooks 803 namespace: crossplane-system 804 labels: 805 app: crossplane 806 release: crossplane 807 helm.sh/chart: crossplane-1.13.0 808 app.kubernetes.io/managed-by: Helm 809 app.kubernetes.io/component: cloud-infrastructure-controller 810 app.kubernetes.io/part-of: crossplane 811 app.kubernetes.io/name: crossplane 812 app.kubernetes.io/instance: crossplane 813 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 814spec: 815 selector: 816 app: crossplane 817 release: crossplane 818 ports: 819 - protocol: TCP 820 port: 9443 821 targetPort: 9443 822--- 823# Source: crossplane/templates/deployment.yaml 824apiVersion: apps/v1 825kind: Deployment 826metadata: 827 name: crossplane 828 namespace: crossplane-system 829 labels: 830 app: crossplane 831 release: crossplane 832 helm.sh/chart: crossplane-1.13.0 833 app.kubernetes.io/managed-by: Helm 834 app.kubernetes.io/component: cloud-infrastructure-controller 835 app.kubernetes.io/part-of: crossplane 836 app.kubernetes.io/name: crossplane 837 app.kubernetes.io/instance: crossplane 838 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 839spec: 840 replicas: 1 841 selector: 842 matchLabels: 843 app: crossplane 844 release: crossplane 845 strategy: 846 type: RollingUpdate 847 template: 848 metadata: 849 labels: 850 app: crossplane 851 release: crossplane 852 helm.sh/chart: crossplane-1.13.0 853 app.kubernetes.io/managed-by: Helm 854 app.kubernetes.io/component: cloud-infrastructure-controller 855 app.kubernetes.io/part-of: crossplane 856 app.kubernetes.io/name: crossplane 857 app.kubernetes.io/instance: crossplane 858 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 859 spec: 860 securityContext: 861 {} 862 serviceAccountName: crossplane 863 hostNetwork: false 864 initContainers: 865 - image: \u0026#34;crossplane/crossplane:v1.13.0\u0026#34; 866 args: 867 - core 868 - init 869 imagePullPolicy: IfNotPresent 870 name: crossplane-init 871 resources: 872 limits: 873 cpu: 100m 874 memory: 512Mi 875 requests: 876 cpu: 100m 877 memory: 256Mi 878 securityContext: 879 allowPrivilegeEscalation: false 880 readOnlyRootFilesystem: true 881 runAsGroup: 65532 882 runAsUser: 65532 883 env: 884 - name: GOMAXPROCS 885 valueFrom: 886 resourceFieldRef: 887 containerName: crossplane-init 888 resource: limits.cpu 889 - name: GOMEMLIMIT 890 valueFrom: 891 resourceFieldRef: 892 containerName: crossplane-init 893 resource: limits.memory 894 - name: POD_NAMESPACE 895 valueFrom: 896 fieldRef: 897 fieldPath: metadata.namespace 898 - name: POD_SERVICE_ACCOUNT 899 valueFrom: 900 fieldRef: 901 fieldPath: spec.serviceAccountName 902 - name: \u0026#34;WEBHOOK_TLS_SECRET_NAME\u0026#34; 903 value: webhook-tls-secret 904 - name: \u0026#34;WEBHOOK_SERVICE_NAME\u0026#34; 905 value: crossplane-webhooks 906 - name: \u0026#34;WEBHOOK_SERVICE_NAMESPACE\u0026#34; 907 valueFrom: 908 fieldRef: 909 fieldPath: metadata.namespace 910 - name: \u0026#34;WEBHOOK_SERVICE_PORT\u0026#34; 911 value: \u0026#34;9443\u0026#34; 912 containers: 913 - image: \u0026#34;crossplane/crossplane:v1.13.0\u0026#34; 914 args: 915 - core 916 - start 917 imagePullPolicy: IfNotPresent 918 name: crossplane 919 resources: 920 limits: 921 cpu: 100m 922 memory: 512Mi 923 requests: 924 cpu: 100m 925 memory: 256Mi 926 ports: 927 - name: webhooks 928 containerPort: 9443 929 securityContext: 930 allowPrivilegeEscalation: false 931 readOnlyRootFilesystem: true 932 runAsGroup: 65532 933 runAsUser: 65532 934 env: 935 - name: GOMAXPROCS 936 valueFrom: 937 resourceFieldRef: 938 containerName: crossplane 939 resource: limits.cpu 940 - name: GOMEMLIMIT 941 valueFrom: 942 resourceFieldRef: 943 containerName: crossplane 944 resource: limits.memory 945 - name: POD_NAMESPACE 946 valueFrom: 947 fieldRef: 948 fieldPath: metadata.namespace 949 - name: POD_SERVICE_ACCOUNT 950 valueFrom: 951 fieldRef: 952 fieldPath: spec.serviceAccountName 953 - name: LEADER_ELECTION 954 value: \u0026#34;true\u0026#34; 955 - name: \u0026#34;WEBHOOK_TLS_SECRET_NAME\u0026#34; 956 value: webhook-tls-secret 957 - name: \u0026#34;WEBHOOK_TLS_CERT_DIR\u0026#34; 958 value: /webhook/tls 959 volumeMounts: 960 - mountPath: /cache 961 name: package-cache 962 - mountPath: /webhook/tls 963 name: webhook-tls-secret 964 volumes: 965 - name: package-cache 966 emptyDir: 967 medium: 968 sizeLimit: 20Mi 969 - name: webhook-tls-secret 970 secret: 971 # NOTE(muvaf): The tls.crt is used both by the server (requires it to 972 # be a single cert) and the caBundle fields of webhook configs and CRDs 973 # which can accept a whole bundle of certificates. In order to meet 974 # the requirements of both, we require a single certificate instead of 975 # a bundle. 976 # It\u0026#39;s assumed that initializer generates this anyway, so it should be 977 # fine. 978 secretName: webhook-tls-secret 979--- 980# Source: crossplane/templates/rbac-manager-deployment.yaml 981apiVersion: apps/v1 982kind: Deployment 983metadata: 984 name: crossplane-rbac-manager 985 namespace: crossplane-system 986 labels: 987 app: crossplane-rbac-manager 988 release: crossplane 989 helm.sh/chart: crossplane-1.13.0 990 app.kubernetes.io/managed-by: Helm 991 app.kubernetes.io/component: cloud-infrastructure-controller 992 app.kubernetes.io/part-of: crossplane 993 app.kubernetes.io/name: crossplane 994 app.kubernetes.io/instance: crossplane 995 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 996spec: 997 replicas: 1 998 selector: 999 matchLabels: 1000 app: crossplane-rbac-manager 1001 release: crossplane 1002 strategy: 1003 type: RollingUpdate 1004 template: 1005 metadata: 1006 labels: 1007 app: crossplane-rbac-manager 1008 release: crossplane 1009 helm.sh/chart: crossplane-1.13.0 1010 app.kubernetes.io/managed-by: Helm 1011 app.kubernetes.io/component: cloud-infrastructure-controller 1012 app.kubernetes.io/part-of: crossplane 1013 app.kubernetes.io/name: crossplane 1014 app.kubernetes.io/instance: crossplane 1015 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 1016 spec: 1017 securityContext: 1018 {} 1019 serviceAccountName: rbac-manager 1020 initContainers: 1021 - image: \u0026#34;crossplane/crossplane:v1.13.0\u0026#34; 1022 args: 1023 - rbac 1024 - init 1025 imagePullPolicy: IfNotPresent 1026 name: crossplane-init 1027 resources: 1028 limits: 1029 cpu: 100m 1030 memory: 512Mi 1031 requests: 1032 cpu: 100m 1033 memory: 256Mi 1034 securityContext: 1035 allowPrivilegeEscalation: false 1036 readOnlyRootFilesystem: true 1037 runAsGroup: 65532 1038 runAsUser: 65532 1039 env: 1040 - name: GOMAXPROCS 1041 valueFrom: 1042 resourceFieldRef: 1043 containerName: crossplane-init 1044 resource: limits.cpu 1045 - name: GOMEMLIMIT 1046 valueFrom: 1047 resourceFieldRef: 1048 containerName: crossplane-init 1049 resource: limits.memory 1050 containers: 1051 - image: \u0026#34;crossplane/crossplane:v1.13.0\u0026#34; 1052 args: 1053 - rbac 1054 - start 1055 - --manage=Basic 1056 - --provider-clusterrole=crossplane:allowed-provider-permissions 1057 imagePullPolicy: IfNotPresent 1058 name: crossplane 1059 resources: 1060 limits: 1061 cpu: 100m 1062 memory: 512Mi 1063 requests: 1064 cpu: 100m 1065 memory: 256Mi 1066 securityContext: 1067 allowPrivilegeEscalation: false 1068 readOnlyRootFilesystem: true 1069 runAsGroup: 65532 1070 runAsUser: 65532 1071 env: 1072 - name: GOMAXPROCS 1073 valueFrom: 1074 resourceFieldRef: 1075 containerName: crossplane 1076 resource: limits.cpu 1077 - name: GOMEMLIMIT 1078 valueFrom: 1079 resourceFieldRef: 1080 containerName: crossplane 1081 resource: limits.memory 1082 - name: LEADER_ELECTION 1083 value: \u0026#34;true\u0026#34; 1084 1085NOTES: 1086Release: crossplane 1087 1088Chart Name: crossplane 1089Chart Description: Crossplane is an open source Kubernetes add-on that enables platform teams to assemble infrastructure from multiple vendors, and expose higher level self-service APIs for application teams to consume. 1090Chart Version: 1.13.0 1091Chart Application Version: 1.13.0 1092 1093Kube Version: v1.27.4 Install the Crossplane components using helm install.\n1helm install crossplane \\ 2crossplane-stable/crossplane \\ 3--namespace crossplane-system \\ 4--create-namespace Verify Crossplane installed with kubectl get pods.\n1kubectl get pods -n crossplane-system 2NAME READY STATUS RESTARTS AGE 3crossplane-d4cd8d784-ldcgb 1/1 Running 0 54s 4crossplane-rbac-manager-84769b574-6mw6f 1/1 Running 0 54s Installing Crossplane creates new Kubernetes API end-points.\nLook at the new API end-points with kubectl api-resources | grep crossplane.\n1kubectl api-resources | grep crossplane 2compositeresourcedefinitions xrd,xrds apiextensions.crossplane.io/v1 false CompositeResourceDefinition 3compositionrevisions comprev apiextensions.crossplane.io/v1 false CompositionRevision 4compositions comp apiextensions.crossplane.io/v1 false Composition 5environmentconfigs envcfg apiextensions.crossplane.io/v1alpha1 false EnvironmentConfig 6configurationrevisions pkg.crossplane.io/v1 false ConfigurationRevision 7configurations pkg.crossplane.io/v1 false Configuration 8controllerconfigs pkg.crossplane.io/v1alpha1 false ControllerConfig 9locks pkg.crossplane.io/v1beta1 false Lock 10providerrevisions pkg.crossplane.io/v1 false ProviderRevision 11providers pkg.crossplane.io/v1 false Provider 12storeconfigs secrets.crossplane.io/v1alpha1 false StoreConfig Install the GCP provider Install the provider into the Kubernetes cluster with a Kubernetes configuration file.\n1cat \u0026lt;\u0026lt;EOF | kubectl apply -f - 2apiVersion: pkg.crossplane.io/v1 3kind: Provider 4metadata: 5 name: provider-gcp-storage 6spec: 7 package: xpkg.upbound.io/upbound/provider-gcp-storage:v0.35.0 8EOF The Crossplane Provider installs the Kubernetes Custom Resource Definitions (CRDs) representing GCP storage services. These CRDs allow you to create GCP resources directly inside Kubernetes.\nVerify the provider installed with kubectl get providers.\n1kubectl get providers 2NAME INSTALLED HEALTHY PACKAGE AGE 3provider-gcp-storage True True xpkg.upbound.io/upbound/provider-gcp-storage:v0.35.0 14m 4upbound-provider-family-gcp True True xpkg.upbound.io/upbound/provider-family-gcp:v0.35.0 14m The Storage Provider installs a second Provider, the upbound-provider-family-gcp provider.\nThe family provider manages authentication to GCP across all GCP family Providers.\nYou can view the new CRDs with kubectl get crds.\nEvery CRD maps to a unique GCP service Crossplane can provision and manage.\nTip See details about all the supported CRDs in the Upbound Marketplace. Create a Kubernetes secret for GCP The provider requires credentials to create and manage GCP resources. Providers use a Kubernetes Secret to connect the credentials to the provider.\nFirst generate a Kubernetes Secret from a Google Cloud service account JSON file and then configure the Provider to use it.\nGenerate a GCP service account JSON file For basic user authentication, use a Google Cloud service account JSON file.\nTip The GCP documentation provides information on how to generate a service account JSON file. Save this JSON file as gcp-credentials.json\nCreate a Kubernetes secret with the GCP credentials A Kubernetes generic secret has a name and contents. Use kubectl create secret to generate the secret object named gcp-secret in the crossplane-system namespace.\nUse the --from-file= argument to set the value to the contents of the gcp-credentials.json file.\n1kubectl create secret \\ 2generic gcp-secret \\ 3-n crossplane-system \\ 4--from-file=creds=./gcp-credentials.json View the secret with kubectl describe secret\nNote The file size may be a different depending on the contents. 1kubectl describe secret gcp-secret -n crossplane-system 2Name: gcp-secret 3Namespace: crossplane-system 4Labels: \u0026lt;none\u0026gt; 5Annotations: \u0026lt;none\u0026gt; 6 7Type: Opaque 8 9Data 10==== 11creds: 2330 bytes Create a ProviderConfig A ProviderConfig customizes the settings of the GCP Provider.\nInclude your GCP project ID in the ProviderConfig settings.\nTip Find your GCP project ID from the project_id field of the gcp-credentials.json file. Apply the ProviderConfig with the command:\n1cat \u0026lt;\u0026lt;EOF | kubectl apply -f - 2apiVersion: gcp.upbound.io/v1beta1 3kind: ProviderConfig 4metadata: 5 name: default 6spec: 7 projectID: 8 credentials: 9 source: Secret 10 secretRef: 11 namespace: crossplane-system 12 name: gcp-secret 13 key: creds 14EOF This attaches the GCP credentials, saved as a Kubernetes secret, as a secretRef.\nThe spec.credentials.secretRef.name value is the name of the Kubernetes secret containing the GCP credentials in the spec.credentials.secretRef.namespace.\nCreate a managed resource A managed resource is anything Crossplane creates and manages outside of the Kubernetes cluster. This example creates a GCP storage bucket with Crossplane.\nThe storage bucket is a managed resource.\nNote To generate a unique name use generateName instead of name. Create the Bucket with the following command:\n1cat \u0026lt;\u0026lt;EOF | kubectl create -f - 2apiVersion: storage.gcp.upbound.io/v1beta1 3kind: Bucket 4metadata: 5 generateName: crossplane-bucket- 6 labels: 7 docs.crossplane.io/example: provider-gcp 8spec: 9 forProvider: 10 location: US 11 providerConfigRef: 12 name: default 13EOF The apiVersion and kind are from the provider\u0026rsquo;s CRDs.\nThe spec.forProvider.location tells GCP which GCP region to use when deploying resources.\nFor a bucket the region can be any GCP multi-region location\nUse kubectl get bucket to verify Crossplane created the bucket.\nTip Crossplane created the bucket when the values READY and SYNCED are True.\nThis may take up to 5 minutes. 1kubectl get bucket 2NAME READY SYNCED EXTERNAL-NAME AGE 3crossplane-bucket-8b7gw True True crossplane-bucket-8b7gw 2m2s Delete the managed resource Before shutting down your Kubernetes cluster, delete the GCP bucket just created.\nUse kubectl delete bucket to remove the bucket.\nTip Use the --selector flag to delete by label instead of by name. 1kubectl delete bucket --selector docs.crossplane.io/example=provider-gcp 2bucket.storage.gcp.upbound.io \u0026#34;crossplane-bucket-8b7gw\u0026#34; deleted Next steps Continue to part 2 to create a Crossplane Composite Resource and Claim. Explore GCP resources that can Crossplane can configure in the Provider CRD reference. Join the Crossplane Slack and connect with Crossplane users and contributors. ","title":"GCP Quickstart","url":"/v1.14/getting-started/provider-gcp/"},{"content":"A Configuration package is an OCI container images containing a collection of Compositions, Composite Resource Definitions and any required Providers or Functions.\nConfiguration packages make your Crossplane configuration fully portable.\nImportant Crossplane Providers and Functions are also Crossplane packages.\nThis document describes how to install and manage configuration packages.\nRefer to the Provider and Composition Functions chapters for details on their usage of packages.\nInstall a Configuration Install a Configuration with a Crossplane Configuration object by setting the spec.package value to the location of the configuration package.\nFor example to install the Upbound AWS reference platform,\n1apiVersion: pkg.crossplane.io/v1 2kind: Configuration 3metadata: 4 name: platform-ref-aws 5spec: 6 package: xpkg.upbound.io/upbound/platform-ref-aws:v0.6.0 Crossplane installs the Compositions, Composite Resource Definitions and Providers listed in the Configuration.\nInstall with Helm Crossplane supports installing Configurations during an initial Crossplane installation with the Crossplane Helm chart.\nUse the --set configuration.packages argument with helm install.\nFor example, to install the Upbound AWS reference platform,\n1helm install crossplane \\ 2crossplane-stable/crossplane \\ 3--namespace crossplane-system \\ 4--create-namespace \\ 5--set configuration.packages=\u0026#39;{xpkg.upbound.io/upbound/platform-ref-aws:v0.6.0}\u0026#39; Install offline Crossplane installs packages from a local package cache. By default the Crossplane package cache is an emptyDir volume.\nConfigure Crossplane to use a PersistentVolumeClaim to use a storage location containing the Configuration image. Read more about configuring the Crossplane Pod settings in the Crossplane install documentation.\nProvide the name of the Configuration\u0026rsquo;s .xpkg file and set packagePullPolicy: Never.\nFor example, to install a locally stored version of Upbound AWS reference platform set the package to the local filename and set the Configuration\u0026rsquo;s packagePullPolicy: Never.\n1apiVersion: pkg.crossplane.io/v1 2kind: Configuration 3metadata: 4 name: offline-platform-ref-aws 5spec: 6 package: platform-ref-aws 7 packagePullPolicy: Never Installation options Configurations support multiple options to change configuration package related settings.\nConfiguration revisions When installing a newer version of an existing Configuration Crossplane creates a new configuration revision.\nView the configuration revisions with kubectl get configurationrevisions.\n1kubectl get configurationrevisions 2NAME HEALTHY REVISION IMAGE STATE DEP-FOUND DEP-INSTALLED AGE 3platform-ref-aws-1735d56cd88d True 2 xpkg.upbound.io/upbound/platform-ref-aws:v0.5.0 Active 2 2 46s 4platform-ref-aws-3ac761211893 True 1 xpkg.upbound.io/upbound/platform-ref-aws:v0.4.1 Inactive 5m13s Only a single revision is active at a time. The active revision determines the available resources, including Compositions and Composite Resource Definitions.\nBy default Crossplane keeps only a single Inactive revision.\nChange the number of revisions Crossplane maintains with a Configuration package revisionHistoryLimit.\nThe revisionHistoryLimit field is an integer.\nThe default value is 1.\nDisable storing revisions by setting revisionHistoryLimit to 0.\nFor example, to change the default setting and store 10 revisions use revisionHistoryLimit: 10.\n1apiVersion: pkg.crossplane.io/v1 2kind: Configuration 3metadata: 4 name: platform-ref-aws 5spec: 6 revisionHistoryLimit: 10 7# Removed for brevity Configuration package pull policy Use a packagePullPolicy to define when Crossplane should download the Configuration package to the local Crossplane package cache.\nThe packagePullPolicy options are:\nIfNotPresent - (default) Only download the package if it isn\u0026rsquo;t in the cache. Always - Check for new packages every minute and download any matching package that isn\u0026rsquo;t in the cache. Never - Never download the package. Packages are only installed from the local package cache. Tip The Crossplane packagePullPolicy works like the Kubernetes container image image pull policy.\nCrossplane supports the use of tags and package digest hashes like Kubernetes images.\nFor example, to Always download a given Configuration package use the packagePullPolicy: Always configuration.\n1apiVersion: pkg.crossplane.io/v1 2kind: Configuration 3metadata: 4 name: platform-ref-aws 5spec: 6 packagePullPolicy: Always 7# Removed for brevity Revision activation policy The Active package revision is the package controller actively reconciling resources.\nBy default Crossplane sets the most recently installed package revision as Active.\nControl the Configuration upgrade behavior with a revisionActivationPolicy.\nThe revisionActivationPolicy options are:\nAutomatic - (default) Automatically activate the last installed configuration. Manual - Don\u0026rsquo;t automatically activate a configuration. For example, to change the upgrade behavior to require manual upgrades, set revisionActivationPolicy: Manual.\n1apiVersion: pkg.crossplane.io/v1 2kind: Configuration 3metadata: 4 name: platform-ref-aws 5spec: 6 revisionActivationPolicy: Manual 7# Removed for brevity Install a Configuration from a private registry Like Kubernetes uses imagePullSecrets to install images from private registries, Crossplane uses packagePullSecrets to install Configuration packages from a private registry.\nUse packagePullSecrets to provide a Kubernetes secret to use for authentication when downloading a Configuration package.\nImportant The Kubernetes secret must be in the same namespace as Crossplane. The packagePullSecrets is a list of secrets.\nFor example, to use the secret named example-secret configure a packagePullSecrets.\n1apiVersion: pkg.crossplane.io/v1 2kind: Configuration 3metadata: 4 name: platform-ref-aws 5spec: 6 packagePullSecrets: 7 - name: example-secret 8# Removed for brevity Ignore dependencies By default Crossplane installs any dependencies listed in a Configuration package.\nCrossplane can ignore a Configuration package\u0026rsquo;s dependencies with skipDependencyResolution.\nWarning Most Configurations include dependencies for the required Providers.\nIf a Configuration ignores dependencies, the required Providers must be manually installed.\nFor example, to disable dependency resolution configure skipDependencyResolution: true.\n1apiVersion: pkg.crossplane.io/v1 2kind: Configuration 3metadata: 4 name: platform-ref-aws 5spec: 6 skipDependencyResolution: true 7# Removed for brevity Ignore Crossplane version requirements A Configuration package may require a specific or minimum Crossplane version before installing. By default, Crossplane doesn\u0026rsquo;t install a Configuration if the Crossplane version doesn\u0026rsquo;t meet the required version.\nCrossplane can ignore the required version with ignoreCrossplaneConstraints.\nFor example, to install a Configuration package into an unsupported Crossplane version, configure ignoreCrossplaneConstraints: true.\n1apiVersion: pkg.crossplane.io/v1 2kind: Configuration 3metadata: 4 name: platform-ref-aws 5spec: 6 ignoreCrossplaneConstraints: true 7# Removed for brevity Verify a Configuration Verify a Configuration with kubectl get configuration.\nA working configuration reports Installed and Healthy as True.\n1kubectl get configuration 2NAME INSTALLED HEALTHY PACKAGE AGE 3platform-ref-aws True True xpkg.upbound.io/upbound/platform-ref-aws:v0.6.0 54s Manage dependencies Configuration packages may include dependencies on other packages including Functions, Providers or other Configurations.\nIf Crossplane can\u0026rsquo;t meet the dependencies of a Configuration the Configuration reports HEALTHY as False.\nFor example, this installation of the Upbound AWS reference platform is HEALTHY: False.\n1kubectl get configuration 2NAME INSTALLED HEALTHY PACKAGE AGE 3platform-ref-aws True False xpkg.upbound.io/upbound/platform-ref-aws:v0.6.0 71s To see more information on why the Configuration isn\u0026rsquo;t HEALTHY use kubectl describe configurationrevisions.\n1kubectl describe configurationrevision 2Name: platform-ref-aws-a30ad655c769 3API Version: pkg.crossplane.io/v1 4Kind: ConfigurationRevision 5# Removed for brevity 6Spec: 7 Desired State: Active 8 Image: xpkg.upbound.io/upbound/platform-ref-aws:v0.6.0 9 Revision: 1 10Status: 11 Conditions: 12 Last Transition Time: 2023-10-06T20:08:14Z 13 Reason: UnhealthyPackageRevision 14 Status: False 15 Type: Healthy 16 Controller Ref: 17 Name: 18Events: 19 Type Reason Age From Message 20 ---- ------ ---- ---- ------- 21 Warning LintPackage 29s (x2 over 29s) packages/configurationrevision.pkg.crossplane.io incompatible Crossplane version: package is not compatible with Crossplane version (v1.12.0) The Events show a Warning with a message that the current version of Crossplane doesn\u0026rsquo;t meet the Configuration package requirements.\nCreate a Configuration Crossplane Configuration packages are OCI container images containing one or more YAML files.\nImportant Configuration packages are fully OCI compliant. Any tool that builds OCI images can build Configuration packages.\nIt\u0026rsquo;s strongly recommended to use the Crossplane command-line tool to provide error checking and formatting to Crossplane package builds.\nRead the Crossplane package specification for package requirements when building packages with third-party tools.\nA Configuration package requires a crossplane.yaml file and may include Composition and CompositeResourceDefinition files.\nThe crossplane.yaml file To build a Configuration package using the Crossplane CLI, create a file named crossplane.yaml.\nThe crossplane.yaml file defines the requirements and name of the Configuration.\nImportant The Crossplane CLI only supports a file named crossplane.yaml. Configuration package uses the meta.pkg.crossplane.io Crossplane API group.\nSpecify any other Configurations, Functions or Providers in the dependsOn list.\nOptionally, you can require a specific or minimum package version with the version option.\nYou can also define a specific or minimum version of Crossplane for this Configuration with the crossplane.version option.\nNote Defining the crossplane object or required versions is optional. 1$ cat crossplane.yaml 2apiVersion: meta.pkg.crossplane.io/v1alpha1 3kind: Configuration 4metadata: 5 name: test-configuration 6spec: 7 dependsOn: 8 - provider: xpkg.upbound.io/crossplane-contrib/provider-aws 9 version: \u0026#34;\u0026gt;=v0.36.0\u0026#34; 10 crossplane: 11 version: \u0026#34;\u0026gt;=v1.12.1-0\u0026#34; Build the package Create the package using the Crossplane CLI command crossplane xpkg build -f \u0026lt;directory\u0026gt;.\nWhere the \u0026lt;directory\u0026gt; is the directory containing the crossplane.yaml file and any Composition or CompositeResourceDefinition YAML files.\nThe CLI recursively searches for .yml or .yaml files in the directory to include in the package.\nImportant You must ignore any other YAML files with --ignore=\u0026lt;file_list\u0026gt;.\nFor example, crossplane xpkg build -f test-directory --ignore=\u0026quot;.tmp/*\u0026quot;.\nIncluding YAML files that aren\u0026rsquo;t Compositions or CompositeResourceDefinitions, including Claims isn\u0026rsquo;t supported.\nBy default, Crossplane creates an .xpkg file of the Configuration name and a SHA-256 hash of the package contents.\nFor example, a Configuration named test-configuration.\nThe Crossplane CLI builds a package named test-configuration-e8c244f6bf21.xpkg.\n1apiVersion: meta.pkg.crossplane.io/v1alpha1 2kind: Configuration 3metadata: 4 name: test-configuration 5# Removed for brevity Specify the output file with --name=\u0026lt;filename\u0026gt; option.\nFor example, to build a package from a directory named test-directory and generate a package named test-package.xpkg use the command:\n1crossplane xpkg build -f test-directory --name=test-package Crossplane automatically adds the .xpkg extension.\nCrossplane places the package in the provided directory, in this example, test-directory.\n1ls test-directory 2composition.yml crossplane.yaml compositeresourcedefinition.yml test-package.xpkg ","title":"Configuration Packages","url":"/v1.14/concepts/packages/"},{"content":"If you have resources that are already provisioned in a Provider, you can import them as managed resources and let Crossplane manage them. A managed resource\u0026rsquo;s managementPolicies field enables importing external resources into Crossplane.\nCrossplane can import resources either manually or automatically.\nImport resources manually Crossplane can discover and import existing Provider resources by matching the crossplane.io/external-name annotation in a managed resource.\nTo import an existing external resource in a Provider, create a new managed resource with the crossplane.io/external-name annotation. Set the annotation value to the name of the resource in the Provider.\nFor example, to import an existing GCP Network named my-existing-network, create a new managed resource and use the my-existing-network in the annotation.\n1apiVersion: compute.gcp.crossplane.io/v1beta1 2kind: Network 3metadata: 4 annotations: 5 crossplane.io/external-name: my-existing-network The metadata.name field can be anything you want. For example, imported-network.\nNote This name is the name of the Kubernetes object. It\u0026rsquo;s not related to the resource name inside the Provider. 1apiVersion: compute.gcp.crossplane.io/v1beta1 2kind: Network 3metadata: 4 annotations: 5 name: imported-network 6 crossplane.io/external-name: my-existing-network Leave the spec.forProvider field empty. Crossplane imports the settings and automatically applies them to the managed resource.\nImportant If the managed resource has required fields in the spec.forProvider you must add it to the forProvider field.\nThe values of those fields must match what\u0026rsquo;s inside the Provider or Crossplane overwrites the existing values.\n1apiVersion: compute.gcp.crossplane.io/v1beta1 2kind: Network 3metadata: 4 annotations: 5 name: imported-network 6 crossplane.io/external-name: my-existing-network 7spec: 8 forProvider: {} Crossplane now controls and manages this imported resource. Any changes to the managed resource spec changes the external resource.\nImport resources automatically Automatically import external resources with an Observe management policy.\nCrossplane imports observe only resources but never changes or deletes the resources.\nImportant The managed resource managementPolicies option is a beta feature.\nThe Provider determines support for management policies.\nRefer to the Provider\u0026rsquo;s documentation to see if the Provider supports management policies.\nApply the Observe management policy Create a new managed resource matching the apiVersion and kind of the resource to import and add managementPolicies: [\"Observe\"] to the spec\nFor example, to import a GCP SQL DatabaseInstance, create a new resource with the managementPolicies: [\"Observe\"] set.\n1apiVersion: sql.gcp.upbound.io/v1beta1 2kind: DatabaseInstance 3spec: 4 managementPolicies: [\u0026#34;Observe\u0026#34;] Add the external-name annotation Add the crossplane.io/external-name annotation for the resource. This name must match the name inside the Provider.\nFor example, for a GCP database named my-external-database, apply the crossplane.io/external-name annotation with the value my-external-database.\n1apiVersion: sql.gcp.upbound.io/v1beta1 2kind: DatabaseInstance 3metadata: 4 annotations: 5 crossplane.io/external-name: my-external-database 6spec: 7 managementPolicies: [\u0026#34;Observe\u0026#34;] Create a Kubernetes object name Create a name to use for the Kubernetes object.\nFor example, name the Kubernetes object my-imported-database.\n1apiVersion: sql.gcp.upbound.io/v1beta1 2kind: DatabaseInstance 3metadata: 4 name: my-imported-database 5 annotations: 6 crossplane.io/external-name: my-external-database 7spec: 8 managementPolicies: [\u0026#34;Observe\u0026#34;] Identify a specific external resource If more than one resource inside the Provider shares the same name, identify the specific resource with a unique spec.forProvider field.\nFor example, only import the GCP SQL database in the us-central1 region.\n1apiVersion: sql.gcp.upbound.io/v1beta1 2kind: DatabaseInstance 3metadata: 4 name: my-imported-database 5 annotations: 6 crossplane.io/external-name: my-external-database 7spec: 8 managementPolicies: [\u0026#34;Observe\u0026#34;] 9 forProvider: 10 region: \u0026#34;us-central1\u0026#34; Apply the managed resource Apply the new managed resource. Crossplane syncs the status of the external resource in the cloud with the newly created managed resource.\nView the discovered resource Crossplane discovers the managed resource and populates the status.atProvider fields with the values from the external resource.\n1apiVersion: sql.gcp.upbound.io/v1beta1 2kind: DatabaseInstance 3metadata: 4 annotations: 5 crossplane.io/external-name: existing-database-instance 6 name: existing-database-instance 7spec: 8 managementPolicies: [\u0026#34;Observe\u0026#34;] 9 forProvider: 10 region: us-central1 11status: 12 atProvider: 13 connectionName: crossplane-playground:us-central1:existing-database-instance 14 databaseVersion: POSTGRES_14 15 deletionProtection: true 16 firstIpAddress: 35.184.74.79 17 id: existing-database-instance 18 publicIpAddress: 35.184.74.79 19 region: us-central1 20 # Removed for brevity 21 settings: 22 - activationPolicy: ALWAYS 23 availabilityType: REGIONAL 24 diskSize: 100 25 # Removed for brevity 26 pricingPlan: PER_USE 27 tier: db-custom-4-26624 28 version: 4 29 conditions: 30 - lastTransitionTime: \u0026#34;2023-02-22T07:16:51Z\u0026#34; 31 reason: Available 32 status: \u0026#34;True\u0026#34; 33 type: Ready 34 - lastTransitionTime: \u0026#34;2023-02-22T07:16:51Z\u0026#34; 35 reason: ReconcileSuccess 36 status: \u0026#34;True\u0026#34; 37 type: Synced Control imported ObserveOnly resources Crossplane can take active control of observe only imported resources by changing the managementPolicies after import.\nChange the managementPolicies field of the managed resource to [\"*\"].\nCopy any required parameter values from status.atProvider and provide them in spec.forProvider.\nTip Manually copy the important spec.atProvider values to spec.forProvider. 1apiVersion: sql.gcp.upbound.io/v1beta1 2kind: DatabaseInstance 3metadata: 4 annotations: 5 crossplane.io/external-name: existing-database-instance 6 name: existing-database-instance 7spec: 8 managementPolicies: [\u0026#34;*\u0026#34;] 9 forProvider: 10 databaseVersion: POSTGRES_14 11 region: us-central1 12 settings: 13 - diskSize: 100 14 tier: db-custom-4-26624 15status: 16 atProvider: 17 databaseVersion: POSTGRES_14 18 region: us-central1 19 # Removed for brevity 20 settings: 21 - diskSize: 100 22 tier: db-custom-4-26624 23 # Removed for brevity 24 conditions: 25 - lastTransitionTime: \u0026#34;2023-02-22T07:16:51Z\u0026#34; 26 reason: Available 27 status: \u0026#34;True\u0026#34; 28 type: Ready 29 - lastTransitionTime: \u0026#34;2023-02-22T11:16:45Z\u0026#34; 30 reason: ReconcileSuccess 31 status: \u0026#34;True\u0026#34; 32 type: Synced Crossplane now fully manages the imported resource. Crossplane applies any changes to the managed resource in the Provider\u0026rsquo;s external resource.\n","title":"Import Existing Resources","url":"/knowledge-base/guides/import-existing-resources/"},{"content":"Crossplane made a small handful of breaking changes in v0.14. The most broadly impactful change was updating the CompositeResourceDefinition (XRD) schema to support defining multiple versions of a composite resource (XR) at once. This guide covers how to upgrade from v0.13 of Crossplane to v0.14.\nUpdating CompositeResourceDefinitions Updating Packages Updating CompositeResourceDefinitions In v0.14 the schema of XRD was updated to support defining multiple versions of an XR. This update requires manual update steps. To upgrade from v0.13 to v0.14 you must:\nEnsure you have up-to-date YAML representations of all of your XRDs. helm upgrade your Crossplane release. Update and apply all of your XRDs. Note that Crossplane will not actively reconcile your XRs between steps 2 and 3, and you will see some errors in the events and logs, but your managed resources (and thus infrastructure) will continue to run. Follow the below steps in order to update your XRDs for v0.14:\nRename spec.crdSpecTemplate to spec.versions. Move spec.versions.group to spec.group. Move spec.versions.names to spec.names. Rename spec.versions.version to spec.versions.name Rename spec.versions.validation (if set) to spec.versions.schema. Rename spec.versions.additionalPrinterColumns[].JSONPath (if set) to spec.versions.additionalPrinterColumns[].jsonPath. Set spec.versions.served to true. Set spec.versions.referenceable to true. Make spec.versions a single element array. For example, the below XRD:\n1apiVersion: apiextensions.crossplane.io/v1alpha1 2kind: CompositeResourceDefinition 3metadata: 4 name: xpostgresqlinstances.database.example.org 5spec: 6 claimNames: 7 kind: PostgreSQLInstance 8 plural: postgresqlinstances 9 connectionSecretKeys: 10 - username 11 - password 12 - endpoint 13 - port 14 crdSpecTemplate: 15 group: database.example.org 16 version: v1alpha1 17 names: 18 kind: XPostgreSQLInstance 19 plural: xpostgresqlinstances 20 validation: 21 openAPIV3Schema: 22 type: object 23 properties: 24 spec: 25 type: object 26 properties: 27 parameters: 28 type: object 29 properties: 30 storageGB: 31 type: integer 32 required: 33 - storageGB 34 required: 35 - parameters Would become:\n1apiVersion: apiextensions.crossplane.io/v1alpha1 2kind: CompositeResourceDefinition 3metadata: 4 name: xpostgresqlinstances.database.example.org 5spec: 6 group: database.example.org 7 names: 8 kind: XPostgreSQLInstance 9 plural: xpostgresqlinstances 10 claimNames: 11 kind: PostgreSQLInstance 12 plural: postgresqlinstances 13 connectionSecretKeys: 14 - username 15 - password 16 - endpoint 17 - port 18 versions: 19 - name: v1alpha1 20 served: true 21 referenceable: true 22 schema: 23 openAPIV3Schema: 24 type: object 25 properties: 26 spec: 27 type: object 28 properties: 29 parameters: 30 type: object 31 properties: 32 storageGB: 33 type: integer 34 required: 35 - storageGB 36 required: 37 - parameters Updating Packages A minor breaking change was made to on-disk package types (meta.pkg.crossplane.io). In v0.13, the spec.crossplane field was present to specify a compatible Crossplane version range, but it was not honored by the package manager when packages were installed. The field was refactored to spec.crossplane.version meaning that packages that previously specified spec.crossplane will fail to parse when building with the Crossplane CLI or installing into a Crossplane Kubernetes cluster. If spec.crossplane was not specified, packages compatible with Crossplane v0.13 will continue to be compatible in v0.14. This is true for both Provider and Configuration packages.\nThe following example shows how a Configuration package that specified spec.crossplane can be updated to specify Crossplane version constraints that will be honored by the package manager in v0.14:\n1apiVersion: meta.pkg.crossplane.io/v1alpha1 2kind: Configuration 3metadata: 4 name: my-configuration 5spec: 6 crossplane: \u0026#34;\u0026gt;=v0.13.0\u0026#34; Would become:\n1apiVersion: meta.pkg.crossplane.io/v1alpha1 2kind: Configuration 3metadata: 4 name: my-configuration 5spec: 6 crossplane: 7 version: \u0026#34;\u0026gt;=v0.13.0\u0026#34; Please note that while spec.dependsOn is also a valid field in on-disk package types, it is not yet honored by the package manager and will be ignored at installation time.\n","title":"Upgrading to v0.14","url":"/knowledge-base/install/upgrading-to-v0.14/"},{"content":"Crossplane versions post v1.0 do not introduce any breaking changes, but may make some backward compatible changes to the core Crossplane CRDs. Helm does not currently touch CRDs when a chart is upgraded, so Crossplane has moved to managing its own CRDs as of v1.2.0. However, for versions prior to v1.2.0, you must manually apply the appropriate CRDs before upgrading.\nUpgrading to v1.0.x or v1.1.x To upgrade from the currently installed version, run:\n1# Update to the latest CRDs. 2kubectl apply -k https://github.com/crossplane/crossplane//cluster?ref=\u0026lt;release-branch\u0026gt; 3 4# Update to the latest stable Helm chart for the desired version 5helm --namespace crossplane-system upgrade crossplane crossplane-stable/crossplane --version \u0026lt;version\u0026gt; Upgrading to v1.2.x and Subsequent Versions Since v1.2.0, we do not include any custom resource instances in our Helm chart. This means the Lock object and Providers and Configurations you might have possibly installed via Helm values will get deleted when you upgrade to v1.2.x. The following commands will instruct Helm not to delete any instances of those types:\n1for name in $(kubectl get locks.pkg.crossplane.io -o name); do kubectl annotate $name \u0026#39;helm.sh/resource-policy=keep\u0026#39;; done 2for name in $(kubectl get providers.pkg.crossplane.io -o name); do kubectl annotate $name \u0026#39;helm.sh/resource-policy=keep\u0026#39;; done 3for name in $(kubectl get configurations.pkg.crossplane.io -o name); do kubectl annotate $name \u0026#39;helm.sh/resource-policy=keep\u0026#39;; done After annotations are in place you can upgrade from the currently installed version by running:\n1# Update to the latest stable Helm chart for the desired version 2helm --namespace crossplane-system upgrade crossplane crossplane-stable/crossplane --version \u0026lt;version\u0026gt; ","title":"Upgrading to v1.x","url":"/knowledge-base/install/upgrading-to-v1.x/"},{"content":"This guide walks through the steps required to configure Crossplane and its Providers to use Vault as an External Secret Store (ESS) with ESS Plugin Vault.\nWarning External Secret Stores are an alpha feature.\nThey\u0026rsquo;re not recommended for production use. Crossplane disables External Secret Stores by default.\nCrossplane uses sensitive information including Provider credentials, inputs to managed resources and connection details.\nThe Vault credential injection guide details using Vault and Crossplane for Provider credentials.\nCrossplane doesn\u0026rsquo;t support for using Vault for managed resources input. Crossplane issue #2985 tracks support for this feature.\nSupporting connection details with Vault requires a Crossplane external secret store.\nPrerequisites This guide requires Helm version 3.11 or later.\nInstall Vault Note Detailed instructions on installing Vault are available from the Vault documentation. Add the Vault Helm chart Add the Helm repository for hashicorp.\n1helm repo add hashicorp https://helm.releases.hashicorp.com --force-update Install Vault using Helm.\n1helm -n vault-system upgrade --install vault hashicorp/vault --create-namespace Unseal Vault If Vault is sealed unseal Vault using the unseal keys.\nGet the Vault keys.\n1kubectl -n vault-system exec vault-0 -- vault operator init -key-shares=1 -key-threshold=1 -format=json \u0026gt; cluster-keys.json 2VAULT_UNSEAL_KEY=$(cat cluster-keys.json | jq -r \u0026#34;.unseal_keys_b64[]\u0026#34;) Unseal the vault using the keys.\n1kubectl -n vault-system exec vault-0 -- vault operator unseal $VAULT_UNSEAL_KEY 2Key Value 3--- ----- 4Seal Type shamir 5Initialized true 6Sealed false 7Total Shares 1 8Threshold 1 9Version 1.13.1 10Build Date 2023-03-23T12:51:35Z 11Storage Type file 12Cluster Name vault-cluster-df884357 13Cluster ID b3145d26-2c1a-a7f2-a364-81753033c0d9 14HA Enabled false Configure Vault Kubernetes authentication Enable the Kubernetes auth method for Vault to authenticate requests based on Kubernetes service accounts.\nGet the Vault root token The Vault root token is inside the JSON file created when unsealing Vault.\n1cat cluster-keys.json | jq -r \u0026#34;.root_token\u0026#34; Enable Kubernetes authentication Connect to a shell in the Vault pod.\n1kubectl -n vault-system exec -it vault-0 -- /bin/sh 2/ $ From the Vault shell, login to Vault using the root token.\n1vault login # use the root token from above 2Token (will be hidden): 3Success! You are now authenticated. The token information displayed below 4is already stored in the token helper. You do NOT need to run \u0026#34;vault login\u0026#34; 5again. Future Vault requests will automatically use this token. 6 7Key Value 8--- ----- 9token hvs.TSN4SssfMBM0HAtwGrxgARgn 10token_accessor qodxHrINVlRXKyrGeeDkxnih 11token_duration ∞ 12token_renewable false 13token_policies [\u0026#34;root\u0026#34;] 14identity_policies [] 15policies [\u0026#34;root\u0026#34;] Enable the Kubernetes authentication method in Vault.\n1vault auth enable kubernetes 2Success! Enabled kubernetes auth method at: kubernetes/ Configure Vault to communicate with Kubernetes and exit the Vault shell\n1vault write auth/kubernetes/config \\ 2 token_reviewer_jwt=\u0026#34;$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)\u0026#34; \\ 3 kubernetes_host=\u0026#34;https://$KUBERNETES_PORT_443_TCP_ADDR:443\u0026#34; \\ 4 kubernetes_ca_cert=@/var/run/secrets/kubernetes.io/serviceaccount/ca.crt 5Success! Data written to: auth/kubernetes/config 6/ $ exit Configure Vault for Crossplane integration Crossplane relies on the Vault key-value secrets engine to store information and Vault requires a permissions policy for the Crossplane service account.\nEnable the Vault kv secrets engine Enable the Vault KV Secrets Engine.\nImportant Vault has two versions of the KV Secrets Engine. This example uses version 2. 1kubectl -n vault-system exec -it vault-0 -- vault secrets enable -path=secret kv-v2 2Success! Enabled the kv-v2 secrets engine at: secret/ Create a Vault policy for Crossplane Create the Vault policy to allow Crossplane to read and write data from Vault.\n1kubectl -n vault-system exec -i vault-0 -- vault policy write crossplane - \u0026lt;\u0026lt;EOF 2path \u0026#34;secret/data/*\u0026#34; { 3 capabilities = [\u0026#34;create\u0026#34;, \u0026#34;read\u0026#34;, \u0026#34;update\u0026#34;, \u0026#34;delete\u0026#34;] 4} 5path \u0026#34;secret/metadata/*\u0026#34; { 6 capabilities = [\u0026#34;create\u0026#34;, \u0026#34;read\u0026#34;, \u0026#34;update\u0026#34;, \u0026#34;delete\u0026#34;] 7} 8EOF 9Success! Uploaded policy: crossplane Apply the policy to Vault.\n1kubectl -n vault-system exec -it vault-0 -- vault write auth/kubernetes/role/crossplane \\ 2 bound_service_account_names=\u0026#34;*\u0026#34; \\ 3 bound_service_account_namespaces=crossplane-system \\ 4 policies=crossplane \\ 5 ttl=24h 6Success! Data written to: auth/kubernetes/role/crossplane Install Crossplane Important Crossplane v1.12 introduced the plugin support. Make sure your version of Crossplane supports plugins. Install the Crossplane with the External Secrets Stores feature enabled.\n1helm upgrade --install crossplane crossplane-stable/crossplane --namespace crossplane-system --create-namespace --set args=\u0026#39;{--enable-external-secret-stores}\u0026#39; Install the Crossplane Vault plugin The Crossplane Vault plugin isn\u0026rsquo;t part of the default Crossplane install. The plugin installs as a unique Pod that uses the Vault Agent Sidecar Injection to connect the Vault secret store to Crossplane.\nFirst, configure annotations for the Vault plugin pod.\n1cat \u0026gt; values.yaml \u0026lt;\u0026lt;EOF 2podAnnotations: 3 vault.hashicorp.com/agent-inject: \u0026#34;true\u0026#34; 4 vault.hashicorp.com/agent-inject-token: \u0026#34;true\u0026#34; 5 vault.hashicorp.com/role: crossplane 6 vault.hashicorp.com/agent-run-as-user: \u0026#34;65532\u0026#34; 7EOF Next, install the Crossplane ESS Plugin pod to the crossplane-system namespace and apply the Vault annotations.\n1helm upgrade --install ess-plugin-vault oci://xpkg.upbound.io/crossplane-contrib/ess-plugin-vault --namespace crossplane-system -f values.yaml Configure Crossplane Using the Vault plugin requires configuration to connect to the Vault service. The plugin also requires Providers to enable external secret stores.\nWith the plugin and providers configured, Crossplane requires two StoreConfig objects to describe how Crossplane and the Providers communicate with vault.\nEnable external secret stores in the Provider Note This example uses Provider GCP, but the ControllerConfig is the same for all Providers. Create a ControllerConfig object to enable external secret stores.\n1echo \u0026#34;apiVersion: pkg.crossplane.io/v1alpha1 2kind: ControllerConfig 3metadata: 4 name: vault-config 5spec: 6 args: 7 - --enable-external-secret-stores\u0026#34; | kubectl apply -f - Install the Provider and apply the ControllerConfig.\n1echo \u0026#34;apiVersion: pkg.crossplane.io/v1 2kind: Provider 3metadata: 4 name: provider-gcp 5spec: 6 package: xpkg.upbound.io/crossplane-contrib/provider-gcp:v0.23.0-rc.0.19.ge9b75ee5 7 controllerConfigRef: 8 name: vault-config\u0026#34; | kubectl apply -f - Connect the Crossplane plugin to Vault Create a VaultConfig resource for the plugin to connect to the Vault service:\n1echo \u0026#34;apiVersion: secrets.crossplane.io/v1alpha1 2kind: VaultConfig 3metadata: 4 name: vault-internal 5spec: 6 server: http://vault.vault-system:8200 7 mountPath: secret/ 8 version: v2 9 auth: 10 method: Token 11 token: 12 source: Filesystem 13 fs: 14 path: /vault/secrets/token\u0026#34; | kubectl apply -f - Create a Crossplane StoreConfig Create a StoreConfig object from the secrets.crossplane.io group. Crossplane uses the StoreConfig to connect to the Vault plugin service.\nThe configRef connects the StoreConfig to the specific Vault plugin configuration.\n1echo \u0026#34;apiVersion: secrets.crossplane.io/v1alpha1 2kind: StoreConfig 3metadata: 4 name: vault 5spec: 6 type: Plugin 7 defaultScope: crossplane-system 8 plugin: 9 endpoint: ess-plugin-vault.crossplane-system:4040 10 configRef: 11 apiVersion: secrets.crossplane.io/v1alpha1 12 kind: VaultConfig 13 name: vault-internal\u0026#34; | kubectl apply -f - Create a Provider StoreConfig Create a StoreConfig object from the Provider\u0026rsquo;s API group, gcp.crossplane.io. The Provider uses this StoreConfig to communicate with Vault for Managed Resources.\nThe configRef connects the StoreConfig to the specific Vault plugin configuration.\n1echo \u0026#34;apiVersion: gcp.crossplane.io/v1alpha1 2kind: StoreConfig 3metadata: 4 name: vault 5spec: 6 type: Plugin 7 defaultScope: crossplane-system 8 plugin: 9 endpoint: ess-plugin-vault.crossplane-system:4040 10 configRef: 11 apiVersion: secrets.crossplane.io/v1alpha1 12 kind: VaultConfig 13 name: vault-internal\u0026#34; | kubectl apply -f - Create Provider resources Check that Crossplane installed the Provider and the Provider is healthy.\n1kubectl get providers 2NAME INSTALLED HEALTHY PACKAGE AGE 3provider-gcp True True xpkg.upbound.io/crossplane-contrib/provider-gcp:v0.23.0-rc.0.19.ge9b75ee5 10m Create a CompositeResourceDefinition Create a CompositeResourceDefinition to define a custom API endpoint.\n1echo \u0026#34;apiVersion: apiextensions.crossplane.io/v1 2kind: CompositeResourceDefinition 3metadata: 4 name: compositeessinstances.ess.example.org 5 annotations: 6 feature: ess 7spec: 8 group: ess.example.org 9 names: 10 kind: CompositeESSInstance 11 plural: compositeessinstances 12 claimNames: 13 kind: ESSInstance 14 plural: essinstances 15 connectionSecretKeys: 16 - publicKey 17 - publicKeyType 18 versions: 19 - name: v1alpha1 20 served: true 21 referenceable: true 22 schema: 23 openAPIV3Schema: 24 type: object 25 properties: 26 spec: 27 type: object 28 properties: 29 parameters: 30 type: object 31 properties: 32 serviceAccount: 33 type: string 34 required: 35 - serviceAccount 36 required: 37 - parameters\u0026#34; | kubectl apply -f - Create a Composition Create a Composition to create a Service Account and Service Account Key inside GCP.\nCreating a Service Account Key generates connectionDetails that the Provider stores in Vault using the publishConnectionDetailsTo details.\n1echo \u0026#34;apiVersion: apiextensions.crossplane.io/v1 2kind: Composition 3metadata: 4 name: essinstances.ess.example.org 5 labels: 6 feature: ess 7spec: 8 publishConnectionDetailsWithStoreConfigRef: 9 name: vault 10 compositeTypeRef: 11 apiVersion: ess.example.org/v1alpha1 12 kind: CompositeESSInstance 13 resources: 14 - name: serviceaccount 15 base: 16 apiVersion: iam.gcp.crossplane.io/v1alpha1 17 kind: ServiceAccount 18 metadata: 19 name: ess-test-sa 20 spec: 21 forProvider: 22 displayName: a service account to test ess 23 - name: serviceaccountkey 24 base: 25 apiVersion: iam.gcp.crossplane.io/v1alpha1 26 kind: ServiceAccountKey 27 spec: 28 forProvider: 29 serviceAccountSelector: 30 matchControllerRef: true 31 publishConnectionDetailsTo: 32 name: ess-mr-conn 33 metadata: 34 labels: 35 environment: development 36 team: backend 37 configRef: 38 name: vault 39 connectionDetails: 40 - fromConnectionSecretKey: publicKey 41 - fromConnectionSecretKey: publicKeyType\u0026#34; | kubectl apply -f - Create a Claim Now create a Claim to have Crossplane create the GCP resources and associated secrets.\nLike the Composition, the Claim uses publishConnectionDetailsTo to connect to Vault and store the secrets.\n1echo \u0026#34;apiVersion: ess.example.org/v1alpha1 2kind: ESSInstance 3metadata: 4 name: my-ess 5 namespace: default 6spec: 7 parameters: 8 serviceAccount: ess-test-sa 9 compositionSelector: 10 matchLabels: 11 feature: ess 12 publishConnectionDetailsTo: 13 name: ess-claim-conn 14 metadata: 15 labels: 16 environment: development 17 team: backend 18 configRef: 19 name: vault\u0026#34; | kubectl apply -f - Verify the resources Verify all resources are READY and SYNCED:\n1kubectl get managed 2NAME READY SYNCED DISPLAYNAME EMAIL DISABLED 3serviceaccount.iam.gcp.crossplane.io/my-ess-zvmkz-vhklg True True a service account to test ess my-ess-zvmkz-vhklg@testingforbugbounty.iam.gserviceaccount.com 4 5NAME READY SYNCED KEY_ID CREATED_AT EXPIRES_AT 6serviceaccountkey.iam.gcp.crossplane.io/my-ess-zvmkz-bq8pz True True 5cda49b7c32393254b5abb121b4adc07e140502c 2022-03-23T10:54:50Z View the claims\n1kubectl -n default get claim 2NAME READY CONNECTION-SECRET AGE 3my-ess True 19s View the composite resources.\n1kubectl get composite 2NAME READY COMPOSITION AGE 3my-ess-zvmkz True essinstances.ess.example.org 32s Verify Vault secrets Look inside Vault to view the secrets from the managed resources.\n1kubectl -n vault-system exec -i vault-0 -- vault kv list /secret/default 2Keys 3---- 4ess-claim-conn The key ess-claim-conn is the name of the Claim\u0026rsquo;s publishConnectionDetailsTo configuration.\nCheck connection secrets in the \u0026ldquo;crossplane-system\u0026rdquo; Vault scope.\n1kubectl -n vault-system exec -i vault-0 -- vault kv list /secret/crossplane-system 2Keys 3---- 4d2408335-eb88-4146-927b-8025f405da86 5ess-mr-conn The key d2408335-eb88-4146-927b-8025f405da86 comes from\nand the key ess-mr-conn comes from the Composition\u0026rsquo;s publishConnectionDetailsTo configuration.\nCheck contents of Claim\u0026rsquo;s connection secret ess-claim-conn to see the key created by the managed resource.\n1kubectl -n vault-system exec -i vault-0 -- vault kv get /secret/default/ess-claim-conn 2======= Metadata ======= 3Key Value 4--- ----- 5created_time 2022-03-18T21:24:07.2085726Z 6custom_metadata map[environment:development secret.crossplane.io/ner-uid:881cd9a0-6cc6-418f-8e1d-b36062c1e108 team:backend] 7deletion_time n/a 8destroyed false 9version 1 10 11======== Data ======== 12Key Value 13--- ----- 14publicKey -----BEGIN PUBLIC KEY----- 15MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAzsEYCokmYEsZJCc9QN/8 16Fm1M/kTPp7Gat/MXLTP3zFyCTBFVNLN79MbAKdinWi6ePXEb75vzB79IdZcWj8lo 178trnS64QjNB9Vs4Xk5UvDALwleFN/bZeperxivDPwVPvT9Aqy/U9kohoS/LHyE8w 18uWQb5AuMeVQ1gtCTnCqQZ4d2MSVhQXYVvAWax1spJ9LT7mHub5j95xDdYIcOV3VJ 19l9CIo4VrWIT8THFN2NnjTrGq9+0TzXY0bV674bjJkfBC6v6yXs5HTetG+Uekq/xf 20FCjrrDi1+2UR9Mu2WTuvl8qn50be+mbwdJO5wE32jewxdYrVVmj19+PkaEeAwGTc 21vwIDAQAB 22-----END PUBLIC KEY----- 23publicKeyType TYPE_RAW_PUBLIC_KEY Check contents of managed resource connection secret ess-mr-conn. The public key is identical to the public key in the Claim since the Claim is using this managed resource.\n1kubectl -n vault-system exec -i vault-0 -- vault kv get /secret/crossplane-system/ess-mr-conn 2======= Metadata ======= 3Key Value 4--- ----- 5created_time 2022-03-18T21:21:07.9298076Z 6custom_metadata map[environment:development secret.crossplane.io/ner-uid:4cd973f8-76fc-45d6-ad45-0b27b5e9252a team:backend] 7deletion_time n/a 8destroyed false 9version 2 10 11========= Data ========= 12Key Value 13--- ----- 14privateKey { 15 \u0026#34;type\u0026#34;: \u0026#34;service_account\u0026#34;, 16 \u0026#34;project_id\u0026#34;: \u0026#34;REDACTED\u0026#34;, 17 \u0026#34;private_key_id\u0026#34;: \u0026#34;REDACTED\u0026#34;, 18 \u0026#34;private_key\u0026#34;: \u0026#34;-----BEGIN PRIVATE KEY-----\\nREDACTED\\n-----END PRIVATE KEY-----\\n\u0026#34;, 19 \u0026#34;client_email\u0026#34;: \u0026#34;ess-test-sa@REDACTED.iam.gserviceaccount.com\u0026#34;, 20 \u0026#34;client_id\u0026#34;: \u0026#34;REDACTED\u0026#34;, 21 \u0026#34;auth_uri\u0026#34;: \u0026#34;https://accounts.google.com/o/oauth2/auth\u0026#34;, 22 \u0026#34;token_uri\u0026#34;: \u0026#34;https://oauth2.googleapis.com/token\u0026#34;, 23 \u0026#34;auth_provider_x509_cert_url\u0026#34;: \u0026#34;https://www.googleapis.com/oauth2/v1/certs\u0026#34;, 24 \u0026#34;client_x509_cert_url\u0026#34;: \u0026#34;https://www.googleapis.com/robot/v1/metadata/x509/ess-test-sa%40REDACTED.iam.gserviceaccount.com\u0026#34; 25} 26privateKeyType TYPE_GOOGLE_CREDENTIALS_FILE 27publicKey -----BEGIN PUBLIC KEY----- 28MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAzsEYCokmYEsZJCc9QN/8 29Fm1M/kTPp7Gat/MXLTP3zFyCTBFVNLN79MbAKdinWi6ePXEb75vzB79IdZcWj8lo 308trnS64QjNB9Vs4Xk5UvDALwleFN/bZeperxivDPwVPvT9Aqy/U9kohoS/LHyE8w 31uWQb5AuMeVQ1gtCTnCqQZ4d2MSVhQXYVvAWax1spJ9LT7mHub5j95xDdYIcOV3VJ 32l9CIo4VrWIT8THFN2NnjTrGq9+0TzXY0bV674bjJkfBC6v6yXs5HTetG+Uekq/xf 33FCjrrDi1+2UR9Mu2WTuvl8qn50be+mbwdJO5wE32jewxdYrVVmj19+PkaEeAwGTc 34vwIDAQAB 35-----END PUBLIC KEY----- 36publicKeyType TYPE_RAW_PUBLIC_KEY Remove the resources Deleting the Claim removes the managed resources and associated keys from Vault.\n1kubectl delete claim my-ess ","title":"Vault as an External Secret Store","url":"/knowledge-base/integrations/vault-as-secret-store/"},{"content":" This guide is adapted from the Vault on Minikube and Vault Kubernetes Sidecar guides.\nMost Crossplane providers support supplying credentials from at least the following sources:\nKubernetes Secret Environment Variable Filesystem A provider may optionally support additional credentials sources, but the common sources cover a wide variety of use cases. One specific use case that is popular among organizations that use Vault for secrets management is using a sidecar to inject credentials into the filesystem. This guide will demonstrate how to use the Vault Kubernetes Sidecar to provide credentials for provider-gcp and provider-aws.\nNote: in this guide we will copy GCP credentials and AWS access keys into Vault\u0026rsquo;s KV secrets engine. This is a simple generic approach to managing secrets with Vault, but is not as robust as using Vault\u0026rsquo;s dedicated cloud provider secrets engines for AWS, Azure, and GCP.\nSetup Note: this guide walks through setting up Vault running in the same cluster as Crossplane. You may also choose to use an existing Vault instance that runs outside the cluster but has Kubernetes authentication enabled.\nBefore getting started, you must ensure that you have installed Crossplane and Vault and that they are running in your cluster.\nInstall Crossplane 1kubectl create namespace crossplane-system 2 3helm repo add crossplane-stable https://charts.crossplane.io/stable 4helm repo update 5 6helm install crossplane --namespace crossplane-system crossplane-stable/crossplane Install Vault Helm Chart 1helm repo add hashicorp https://helm.releases.hashicorp.com 2helm install vault hashicorp/vault Unseal Vault Instance In order for Vault to access encrypted data from physical storage, it must be unsealed.\n1kubectl exec vault-0 -- vault operator init -key-shares=1 -key-threshold=1 -format=json \u0026gt; cluster-keys.json 2VAULT_UNSEAL_KEY=$(cat cluster-keys.json | jq -r \u0026#34;.unseal_keys_b64[]\u0026#34;) 3kubectl exec vault-0 -- vault operator unseal $VAULT_UNSEAL_KEY Enable Kubernetes Authentication Method In order for Vault to be able to authenticate requests based on Kubernetes service accounts, the Kubernetes authentication backend must be enabled. This requires logging in to Vault and configuring it with a service account token, API server address, and certificate. Because we are running Vault in Kubernetes, these values are already available via the container filesystem and environment variables.\n1cat cluster-keys.json | jq -r \u0026#34;.root_token\u0026#34; # get root token 2 3kubectl exec -it vault-0 -- /bin/sh 4vault login # use root token from above 5vault auth enable kubernetes 6 7vault write auth/kubernetes/config \\ 8 token_reviewer_jwt=\u0026#34;$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)\u0026#34; \\ 9 kubernetes_host=\u0026#34;https://$KUBERNETES_PORT_443_TCP_ADDR:443\u0026#34; \\ 10 kubernetes_ca_cert=@/var/run/secrets/kubernetes.io/serviceaccount/ca.crt Exit Vault Container The next steps will be executed in your local environment.\n1exit GCP AWS Create GCP Service Account In order to provision infrastructure on GCP, you will need to create a service account with appropriate permissions. In this guide we will only provision a CloudSQL instance, so the service account will be bound to the cloudsql.admin role. The following steps will setup a GCP service account, give it the necessary permissions for Crossplane to be able to manage CloudSQL instances, and emit the service account credentials in a JSON file.\n1# replace this with your own gcp project id and the name of the service account 2# that will be created. 3PROJECT_ID=my-project 4NEW_SA_NAME=test-service-account-name 5 6# create service account 7SA=\u0026#34;${NEW_SA_NAME}@${PROJECT_ID}.iam.gserviceaccount.com\u0026#34; 8gcloud iam service-accounts create $NEW_SA_NAME --project $PROJECT_ID 9 10# enable cloud API 11SERVICE=\u0026#34;sqladmin.googleapis.com\u0026#34; 12gcloud services enable $SERVICE --project $PROJECT_ID 13 14# grant access to cloud API 15ROLE=\u0026#34;roles/cloudsql.admin\u0026#34; 16gcloud projects add-iam-policy-binding --role=\u0026#34;$ROLE\u0026#34; $PROJECT_ID --member \u0026#34;serviceAccount:$SA\u0026#34; 17 18# create service account keyfile 19gcloud iam service-accounts keys create creds.json --project $PROJECT_ID --iam-account $SA You should now have valid service account credentials in creds.json.\nStore Credentials in Vault After setting up Vault, you will need to store your credentials in the [kv secrets engine].\nNote: the steps below involve copying credentials into the container filesystem before storing them in Vault. You may also choose to use Vault\u0026rsquo;s HTTP API or UI by port-forwarding the container to your local environment (kubectl port-forward vault-0 8200:8200).\nCopy Credentials File into Vault Container Copy your credentials into the container filesystem so that your can store them in Vault.\n1kubectl cp creds.json vault-0:/tmp/creds.json Enable KV Secrets Engine Secrets engines must be enabled before they can be used. Enable the kv-v2 secrets engine at the secret path.\n1kubectl exec -it vault-0 -- /bin/sh 2 3vault secrets enable -path=secret kv-v2 Store GCP Credentials in KV Engine The path of your GCP credentials is how the secret will be referenced when injecting it into the provider-gcp controller Pod.\n1vault kv put secret/provider-creds/gcp-default @tmp/creds.json Clean Up Credentials File You no longer need our GCP credentials file in the container filesystem, so go ahead and clean it up.\n1rm tmp/creds.json Create AWS IAM User In order to provision infrastructure on AWS, you will need to use an existing or create a new IAM user with appropriate permissions. The following steps will create an AWS IAM user and give it the necessary permissions.\nNote: if you have an existing IAM user with appropriate permissions, you can skip this step but you will still need to provide the values for the ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY environment variables.\n1# create a new IAM user 2IAM_USER=test-user 3aws iam create-user --user-name $IAM_USER 4 5# grant the IAM user the necessary permissions 6aws iam attach-user-policy --user-name $IAM_USER --policy-arn arn:aws:iam::aws:policy/AmazonS3FullAccess 7 8# create a new IAM access key for the user 9aws iam create-access-key --user-name $IAM_USER \u0026gt; creds.json 10# assign the access key values to environment variables 11ACCESS_KEY_ID=$(jq -r .AccessKey.AccessKeyId creds.json) 12AWS_SECRET_ACCESS_KEY=$(jq -r .AccessKey.SecretAccessKey creds.json) Store Credentials in Vault After setting up Vault, you will need to store your credentials in the [kv secrets engine].\nEnable KV Secrets Engine Secrets engines must be enabled before they can be used. Enable the kv-v2 secrets engine at the secret path.\n1kubectl exec -it vault-0 -- env \\ 2 ACCESS_KEY_ID=${ACCESS_KEY_ID} \\ 3 AWS_SECRET_ACCESS_KEY=${AWS_SECRET_ACCESS_KEY} \\ 4 /bin/sh 5 6vault secrets enable -path=secret kv-v2 Store AWS Credentials in KV Engine The path of your AWS credentials is how the secret will be referenced when injecting it into the provider-aws controller Pod.\nvault kv put secret/provider-creds/aws-default access_key=\u0026#34;$ACCESS_KEY_ID\u0026#34; secret_key=\u0026#34;$AWS_SECRET_ACCESS_KEY\u0026#34; Create a Vault Policy for Reading Provider Credentials In order for our controllers to have the Vault sidecar inject the credentials into their filesystem, you must associate the Pod with a policy. This policy will allow for reading and listing all secrets on the provider-creds path in the kv-v2 secrets engine.\n1vault policy write provider-creds - \u0026lt;\u0026lt;EOF 2path \u0026#34;secret/data/provider-creds/*\u0026#34; { 3 capabilities = [\u0026#34;read\u0026#34;, \u0026#34;list\u0026#34;] 4} 5EOF Create a Role for Crossplane Provider Pods Create Role The last step is to create a role that is bound to the policy you created and associate it with a group of Kubernetes service accounts. This role can be assumed by any (*) service account in the crossplane-system namespace.\n1vault write auth/kubernetes/role/crossplane-providers \\ 2 bound_service_account_names=\u0026#34;*\u0026#34; \\ 3 bound_service_account_namespaces=crossplane-system \\ 4 policies=provider-creds \\ 5 ttl=24h Exit Vault Container The next steps will be executed in your local environment.\n1exit GCP AWS Install provider-gcp You are now ready to install provider-gcp. Crossplane provides a ControllerConfig type that allows you to customize the deployment of a provider\u0026rsquo;s controller Pod. A ControllerConfig can be created and referenced by any number of Provider objects that wish to use its configuration. In the example below, the Pod annotations indicate to the Vault mutating webhook that we want for the secret stored at secret/provider-creds/gcp-default to be injected into the container filesystem by assuming role crossplane-providers. There is also so template formatting added to make sure the secret data is presented in a form that provider-gcp is expecting.\n{% raw %}\n1echo \u0026#34;apiVersion: pkg.crossplane.io/v1alpha1 2kind: ControllerConfig 3metadata: 4 name: vault-config 5spec: 6 metadata: 7 annotations: 8 vault.hashicorp.com/agent-inject: \\\u0026#34;true\\\u0026#34; 9 vault.hashicorp.com/role: \u0026#34;crossplane-providers\u0026#34; 10 vault.hashicorp.com/agent-inject-secret-creds.txt: \u0026#34;secret/provider-creds/gcp-default\u0026#34; 11 vault.hashicorp.com/agent-inject-template-creds.txt: | 12 {{- with secret \\\u0026#34;secret/provider-creds/gcp-default\\\u0026#34; -}} 13 {{ .Data.data | toJSON }} 14 {{- end -}} 15--- 16apiVersion: pkg.crossplane.io/v1 17kind: Provider 18metadata: 19 name: provider-gcp 20spec: 21 package: xpkg.upbound.io/crossplane-contrib/provider-gcp:v0.22.0 22 controllerConfigRef: 23 name: vault-config\u0026#34; | kubectl apply -f - {% endraw %}\nConfigure provider-gcp One provider-gcp is installed and running, you will want to create a ProviderConfig that specifies the credentials in the filesystem that should be used to provision managed resources that reference this ProviderConfig. Because the name of this ProviderConfig is default it will be used by any managed resources that do not explicitly reference a ProviderConfig.\nNote: make sure that the PROJECT_ID environment variable that was defined earlier is still set correctly.\n1echo \u0026#34;apiVersion: gcp.crossplane.io/v1beta1 2kind: ProviderConfig 3metadata: 4 name: default 5spec: 6 projectID: ${PROJECT_ID} 7 credentials: 8 source: Filesystem 9 fs: 10 path: /vault/secrets/creds.txt\u0026#34; | kubectl apply -f - To verify that the GCP credentials are being injected into the container run the following command:\n1PROVIDER_CONTROLLER_POD=$(kubectl -n crossplane-system get pod -l pkg.crossplane.io/provider=provider-gcp -o name --no-headers=true) 2kubectl -n crossplane-system exec -it $PROVIDER_CONTROLLER_POD -c provider-gcp -- cat /vault/secrets/creds.txt Provision Infrastructure The final step is to actually provision a CloudSQLInstance. Creating the object below will result in the creation of a Cloud SQL Postgres database on GCP.\n1echo \u0026#34;apiVersion: database.gcp.crossplane.io/v1beta1 2kind: CloudSQLInstance 3metadata: 4 name: postgres-vault-demo 5spec: 6 forProvider: 7 databaseVersion: POSTGRES_12 8 region: us-central1 9 settings: 10 tier: db-custom-1-3840 11 dataDiskType: PD_SSD 12 dataDiskSizeGb: 10 13 writeConnectionSecretToRef: 14 namespace: crossplane-system 15 name: cloudsqlpostgresql-conn\u0026#34; | kubectl apply -f - You can monitor the progress of the database provisioning with the following command:\n1kubectl get cloudsqlinstance -w Install provider-aws You are now ready to install provider-aws. Crossplane provides a ControllerConfig type that allows you to customize the deployment of a provider\u0026rsquo;s controller Pod. A ControllerConfig can be created and referenced by any number of Provider objects that wish to use its configuration. In the example below, the Pod annotations indicate to the Vault mutating webhook that we want for the secret stored at secret/provider-creds/aws-default to be injected into the container filesystem by assuming role crossplane-providers. There is also some template formatting added to make sure the secret data is presented in a form that provider-aws is expecting.\n{% raw %}\n1echo \u0026#34;apiVersion: pkg.crossplane.io/v1alpha1 2kind: ControllerConfig 3metadata: 4 name: aws-vault-config 5spec: 6 args: 7 - --debug 8 metadata: 9 annotations: 10 vault.hashicorp.com/agent-inject: \\\u0026#34;true\\\u0026#34; 11 vault.hashicorp.com/role: \\\u0026#34;crossplane-providers\\\u0026#34; 12 vault.hashicorp.com/agent-inject-secret-creds.txt: \\\u0026#34;secret/provider-creds/aws-default\\\u0026#34; 13 vault.hashicorp.com/agent-inject-template-creds.txt: | 14 {{- with secret \\\u0026#34;secret/provider-creds/aws-default\\\u0026#34; -}} 15 [default] 16 aws_access_key_id=\u0026#34;{{ .Data.data.access_key }}\u0026#34; 17 aws_secret_access_key=\u0026#34;{{ .Data.data.secret_key }}\u0026#34; 18 {{- end -}} 19--- 20apiVersion: pkg.crossplane.io/v1 21kind: Provider 22metadata: 23 name: provider-aws 24spec: 25 package: xpkg.upbound.io/crossplane-contrib/provider-aws:v0.33.0 26 controllerConfigRef: 27 name: aws-vault-config\u0026#34; | kubectl apply -f - {% endraw %}\nConfigure provider-aws Once provider-aws is installed and running, you will want to create a ProviderConfig that specifies the credentials in the filesystem that should be used to provision managed resources that reference this ProviderConfig. Because the name of this ProviderConfig is default it will be used by any managed resources that do not explicitly reference a ProviderConfig.\n1echo \u0026#34;apiVersion: aws.crossplane.io/v1beta1 2kind: ProviderConfig 3metadata: 4 name: default 5spec: 6 credentials: 7 source: Filesystem 8 fs: 9 path: /vault/secrets/creds.txt\u0026#34; | kubectl apply -f - To verify that the AWS credentials are being injected into the container run the following command:\n1PROVIDER_CONTROLLER_POD=$(kubectl -n crossplane-system get pod -l pkg.crossplane.io/provider=provider-aws -o name --no-headers=true) 2kubectl -n crossplane-system exec -it $PROVIDER_CONTROLLER_POD -c provider-aws -- cat /vault/secrets/creds.txt Provision Infrastructure The final step is to actually provision a Bucket. Creating the object below will result in the creation of a S3 bucket on AWS.\n1echo \u0026#34;apiVersion: s3.aws.crossplane.io/v1beta1 2kind: Bucket 3metadata: 4 name: s3-vault-demo 5spec: 6 forProvider: 7 acl: private 8 locationConstraint: us-east-1 9 publicAccessBlockConfiguration: 10 blockPublicPolicy: true 11 tagging: 12 tagSet: 13 - key: Name 14 value: s3-vault-demo 15 providerConfigRef: 16 name: default\u0026#34; | kubectl apply -f - You can monitor the progress of the bucket provisioning with the following command:\n1kubectl get bucket -w ","title":"Vault Credential Injection","url":"/knowledge-base/integrations/vault-injection/"},{"content":"This guide describes how to use Crossplane effectively in multi-tenant environments by utilizing Kubernetes primitives and compatible policy enforcement projects in the cloud-native ecosystem.\nTL;DR Infrastructure operators in multi-tenant Crossplane environments typically utilize composition and Kubernetes RBAC to define lightweight, standardized policies that dictate what level of self-service developers are given when requesting infrastructure. This is primarily achieved through exposing abstract resource types at the namespace scope, defining Roles for teams and individuals within that namespace, and patching the spec.providerConfigRef of the underlying managed resources so that they use a specific ProviderConfig and credentials when provisioned from each namespace. Larger organizations, or those with more complex environments, may choose to incorporate third-party policy engines, or scale to multiple Crossplane clusters. The following sections describe each of these scenarios in greater detail.\nTL;DR Background Cluster-Scoped Managed Resources Namespace Scoped Claims Single Cluster Multi-Tenancy Composition as an Isolation Mechanism Namespaces as an Isolation Mechanism Policy Enforcement with Open Policy Agent Multi-Cluster Multi-Tenancy Reproducible Platforms with Configuration Packages Control Plane of Control Planes Background Crossplane is designed to run in multi-tenant environments where many teams are consuming the services and abstractions provided by infrastructure operators in the cluster. This functionality is facilitated by two major design patterns in the Crossplane ecosystem.\nCluster-Scoped Managed Resources Typically, Crossplane providers, which supply granular managed resources that reflect an external API, authenticate by using a ProviderConfig object that points to a credentials source (such as a Kubernetes Secret, the Pod filesystem, or an environment variable). Then, every managed resource references a ProviderConfig that points to credentials with sufficient permissions to manage that resource type.\nFor example, the following ProviderConfig for provider-aws points to a Kubernetes Secret with AWS credentials.\n1apiVersion: aws.crossplane.io/v1beta1 2kind: ProviderConfig 3metadata: 4 name: cool-aws-creds 5spec: 6 credentials: 7 source: Secret 8 secretRef: 9 namespace: crossplane-system 10 name: aws-creds 11 key: creds If a user desired for these credentials to be used to provision an RDSInstance, they would reference the ProviderConfig in the object manifest:\n1apiVersion: database.aws.crossplane.io/v1beta1 2kind: RDSInstance 3metadata: 4 name: rdsmysql 5spec: 6 forProvider: 7 region: us-east-1 8 dbInstanceClass: db.t3.medium 9 masterUsername: masteruser 10 allocatedStorage: 20 11 engine: mysql 12 engineVersion: \u0026#34;5.6.35\u0026#34; 13 skipFinalSnapshotBeforeDeletion: true 14 providerConfigRef: 15 name: cool-aws-creds # name of ProviderConfig above 16 writeConnectionSecretToRef: 17 namespace: crossplane-system 18 name: aws-rdsmysql-conn Since both the ProviderConfig and all managed resources are cluster-scoped, the RDS controller in provider-aws will resolve this reference by fetching the ProviderConfig, obtaining the credentials it points to, and using those credentials to reconcile the RDSInstance. This means that anyone who has been given RBAC to manage RDSInstance objects can use any credentials to do so. In practice, Crossplane assumes that only folks acting as infrastructure administrators or platform builders will interact directly with cluster-scoped resources.\nNamespace Scoped Claims While managed resources exist at the cluster scope, composite resources, which are defined using a CompositeResourceDefinition (XRD) may exist at either the cluster or namespace scope. Platform builders define XRDs and Compositions that specify what granular managed resources should be created in response to the creation of an instance of the XRD. More information about this architecture can be found in the Composition documentation.\nEvery XRD is exposed at the cluster scope, but only those with spec.claimNames defined will have a namespace-scoped variant.\n1apiVersion: apiextensions.crossplane.io/v1 2kind: CompositeResourceDefinition 3metadata: 4 name: xmysqlinstances.example.org 5spec: 6 group: example.org 7 names: 8 kind: XMySQLInstance 9 plural: xmysqlinstances 10 claimNames: 11 kind: MySQLInstance 12 plural: mysqlinstances 13... When the example above is created, Crossplane will produce two CustomResourceDefinitions:\nA cluster-scoped type with kind: XMySQLInstance. This is referred to as a Composite Resource (XR). A namespace-scoped type with kind: MySQLInstance. This is referred to as a Claim (XRC). Platform builders may choose to define an arbitrary number of Compositions that map to these types, meaning that creating a MySQLInstance in a given namespace can result in the creations of any set of managed resources at the cluster scope. For instance, creating a MySQLInstance could result in the creation of the RDSInstance defined above.\nSingle Cluster Multi-Tenancy Depending on the size and scope of an organization, platform teams may choose to run one central Crossplane control plane, or many different ones for each team or business unit. This section will focus on servicing multiple teams within a single cluster, which may or may not be one of many other Crossplane clusters in the organization.\nComposition as an Isolation Mechanism While managed resources always reflect every field that the underlying provider API exposes, XRDs can have any schema that a platform builder chooses. The fields in the XRD schema can then be patched onto fields in the underlying managed resource defined in a Composition, essentially exposing those fields as configurable to the consumer of the XR or XRC.\nThis feature serves as a lightweight policy mechanism by only giving the consumer the ability to customize the underlying resources to the extent the platform builder desires. For instance, in the examples above, a platform builder may choose to define a spec.location field in the schema of the XMySQLInstance that is an enum with options east and west. In the Composition, those fields could map to the RDSInstance spec.region field, making the value either us-east-1 or us-west-1. If no other patches were defined for the RDSInstance, giving a user the ability (using RBAC) to create a XMySQLInstance / MySQLInstance would be akin to giving the ability to create a very specifically configured RDSInstance, where they can only decide the region where it lives and they are restricted to two options.\nThis model is in contrast to many infrastructure as code tools where the end user must have provider credentials to create the underlying resources that are rendered from the abstraction. Crossplane takes a different approach, defining various credentials in the cluster (using the ProviderConfig), then giving only the provider controllers the ability to utilize those credentials and provision infrastructure on the users behalf. This creates a consistent permission model, even when using many providers with differing IAM models, by standardizing on Kubernetes RBAC.\nNamespaces as an Isolation Mechanism While the ability to define abstract schemas and patches to concrete resource types using composition is powerful, the ability to define Claim types at the namespace scope enhances the functionality further by enabling RBAC to be applied with namespace restrictions. Most users in a cluster do not have access to cluster-scoped resources as they are considered only relevant to infrastructure admins by both Kubernetes and Crossplane.\nBuilding on our simple XMySQLInstance / MySQLInstance example, a platform builder may choose to define permissions on MySQLInstance at the namespace scope using a Role. This allows for giving users the ability to create and manage MySQLInstances in their given namespace, but not the ability to see those defined in other namespaces.\nFurthermore, because the metadata.namespace is a field on the XRC, patching can be utilized to configure managed resources based on the namespace in which the corresponding XRC was defined. This is especially useful if a platform builder wants to designate specific credentials or a set of credentials that users in a given namespace can utilize when provisioning infrastructure using an XRC. This can be accomplished today by creating one or more ProviderConfig objects that include the name of the namespace in the ProviderConfig name. For example, if any MySQLInstance created in the team-1 namespace should use specific AWS credentials when the provider controller creates the underlying RDSInstance, the platform builder could:\nDefine a ProviderConfig with name team-1. 1apiVersion: aws.crossplane.io/v1beta1 2kind: ProviderConfig 3metadata: 4 name: team-1 5spec: 6 credentials: 7 source: Secret 8 secretRef: 9 namespace: crossplane-system 10 name: team-1-creds 11 key: creds Define a Composition that patches the namespace of the Claim reference in the XR to the providerConfigRef of the RDSInstance. 1... 2resources: 3- base: 4 apiVersion: database.aws.crossplane.io/v1beta1 5 kind: RDSInstance 6 spec: 7 forProvider: 8 ... 9 patches: 10 - fromFieldPath: spec.claimRef.namespace 11 toFieldPath: spec.providerConfigRef.name 12 policy: 13 fromFieldPath: Required This would result in the RDSInstance using the ProviderConfig of whatever namespace the corresponding MySQLInstance was created in.\nNote that this model currently only allows for a single ProviderConfig per namespace. However, future Crossplane releases should allow for defining a set of ProviderConfig that can be selected from using Multiple Source Field patching.\nPolicy Enforcement with Open Policy Agent In some Crossplane deployment models, only using composition and RBAC to define policy will not be flexible enough. However, because Crossplane brings management of external infrastructure to the Kubernetes API, it is well suited to integrate with other projects in the cloud-native ecosystem. Organizations and individuals that need a more robust policy engine, or just prefer a more general language for defining policy, often turn to Open Policy Agent (OPA). OPA allows platform builders to write custom logic in Rego, a domain-specific language. Writing policy in this manner allows for not only incorporating the information available in the specific resource being evaluated, but also using other state represented in the cluster. Crossplane users typically install OPA\u0026rsquo;s Gatekeeper to make policy management as streamlined as possible.\nA live demo of using OPA with Crossplane can be viewed here.\nMulti-Cluster Multi-Tenancy Organizations that deploy Crossplane across many clusters typically take advantage of two major features that make managing multiple control planes much simpler.\nReproducible Platforms with Configuration Packages Configuration packages allow platform builders to package their XRDs and Compositions into OCI images that can be distributed via any OCI-compliant image registry. These packages can also declare dependencies on providers, meaning that a single package can declare all of the granular managed resources, the controllers that must be deployed to reconcile them, and the abstract types that expose the underlying resources using composition.\nOrganizations with many Crossplane deployments utilize Configuration packages to reproduce their platform in each cluster. This can be as simple as installing Crossplane with the flag to automatically install a Configuration package alongside it.\nhelm install crossplane --namespace crossplane-system crossplane-stable/crossplane --set configuration.packages=\u0026#39;{\u0026#34;registry.upbound.io/xp/getting-started-with-aws:latest\u0026#34;}\u0026#39; Control Plane of Control Planes Taking the multi-cluster multi-tenancy model one step further, some organizations opt to manage their many Crossplane clusters using a single central Crossplane control plane. This requires setting up the central cluster, then using a provider to spin up new clusters (such as an EKS Cluster using provider-aws), then using provider-helm to install Crossplane into the new remote cluster, potentially bundling a common Configuration package into each install using the method described above.\nThis advanced pattern allows for full management of Crossplane clusters using Crossplane itself, and when done properly, is a scalable solution to providing dedicated control planes to many tenants within a single organization.\n","title":"Multi-Tenant Crossplane","url":"/knowledge-base/guides/multi-tenant/"},{"content":"Argo CD and Crossplane are a great combination. Argo CD provides GitOps while Crossplane turns any Kubernetes cluster into a Universal Control Plane for all of your resources. There are configuration details required in order for the two to work together properly. This doc will help you understand these requirements. It is recommended to use\nArgo CD version 2.4.8 or later with Crossplane.\nArgo CD synchronizes Kubernetes resource manifests stored in a Git repository with those running in a Kubernetes cluster (GitOps). There are different ways to configure\nhow Argo CD tracks resources. With Crossplane, you need to configure Argo CD to use Annotation based resource tracking. See the Argo CD docs for additional detail.\nConfiguring Argo CD with Crossplane To configure Argo CD for Annotation resource tracking, edit the argocd-cm\nConfigMap in the argocd Namespace. Add application.resourceTrackingMethod: annotation\nto the data section as below:\n1 2apiVersion: v1 3data: 4 application.resourceTrackingMethod: annotation 5kind: ConfigMap On the next Argo CD sync, Crossplane Claims and Composite Resources will\nbe considered synchronized and will not trigger auto-pruning.\n","title":"Configuring Crossplane with Argo CD","url":"/knowledge-base/integrations/argo-cd-crossplane/"},{"content":" Using self-signed certificates is not advised in production, it is recommended to only use self-signed certificates for testing.\nWhen Crossplane loads Configuration and Provider Packages from private registries, it must be configured to trust the CA and Intermediate certs.\nCrossplane needs to be installed via the Helm chart with the registryCaBundleConfig.name and registryCaBundleConfig.key parameters defined. See Install Crossplane.\nConfigure Create a CA Bundle (A file containing your Root and Intermediate certificates in a specific order). This can be done with any text editor or from the command line, so long as the resulting file contains all required crt files in the proper order. In many cases, this will be either a single self-signed Root CA crt file, or an Intermediate crt and Root crt file. The order of the crt files should be from lowest to highest in signing order. For example, if you have a chain of two certificates below your Root certificate, you place the bottom level Intermediate cert at the beginning of the file, then the Intermediate cert that singed that cert, then the Root cert that signed that cert.\nSave the files as [yourdomain].ca-bundle.\nCreate a Kubernetes ConfigMap in your Crossplane system namespace:\nkubectl -n [Crossplane system namespace] create cm ca-bundle-config \\ --from-file=ca-bundle=./[yourdomain].ca-bundle Set the registryCaBundleConfig.name Helm chart parameter to ca-bundle-config and the registryCaBundleConfig.key parameter to ca-bundle. Providing Helm with parameter values is convered in the Helm docs, Helm install. An example block\nin an override.yaml file would look like this:\nregistryCaBundleConfig: name: ca-bundle-config key: ca-bundle ","title":"Self-Signed CA Certs","url":"/knowledge-base/guides/self-signed-ca-certs/"},{"content":" Warning Resources created by Crossplane aren\u0026rsquo;t deleted if Crossplane isn\u0026rsquo;t uninstalled in order.\nThis can leave cloud resources running, requiring manual deletion.\nOrdered Crossplane uninstall Most Crossplane resources have dependencies on other Crossplane resources.\nFor example, a managed resource is dependent on the provider.\nFailure to delete Crossplane resources in order may prevent Crossplane from deleting provisioned external resources.\nRemoving Crossplane resources should happen in the following order:\nRemove all composite resource definitions Remove all remaining managed resources Remove all providers Deleting the Crossplane pod removes remaining Crossplane components like claims.\nTip Collect an inventory of all external resources with kubectl get managed.\nDepending on the size of the Kubernetes API server and number of resources, this command may take minutes to return.\nAn example kubectl get managed 1kubectl get managed 2NAME READY SYNCED EXTERNAL-NAME AGE 3securitygroup.ec2.aws.upbound.io/my-db-7mc7h-j84h8 True True sg-0da6e9c29113596b6 3m1s 4securitygroup.ec2.aws.upbound.io/my-db-8bhr2-9wsx9 True True sg-02695166f010ec05b 2m26s 5 6NAME READY SYNCED EXTERNAL-NAME AGE 7route.ec2.aws.upbound.io/my-db-7mc7h-vw985 True True r-rtb-05822b8df433e4e2b1080289494 3m1s 8route.ec2.aws.upbound.io/my-db-8bhr2-7m2wq False True 2m26s 9 10NAME READY SYNCED EXTERNAL-NAME AGE 11securitygrouprule.ec2.aws.upbound.io/my-db-7mc7h-mkd9s True True sgrule-778063708 3m1s 12securitygrouprule.ec2.aws.upbound.io/my-db-8bhr2-lzr89 False True 2m26s 13 14NAME READY SYNCED EXTERNAL-NAME AGE 15routetable.ec2.aws.upbound.io/my-db-7mc7h-mnqvm True True rtb-05822b8df433e4e2b 3m1s 16routetable.ec2.aws.upbound.io/my-db-8bhr2-dfhj6 True True rtb-02e875abd25658254 2m26s 17 18NAME READY SYNCED EXTERNAL-NAME AGE 19subnet.ec2.aws.upbound.io/my-db-7mc7h-7m49d True True subnet-0c1ab32c5ec129dd1 3m2s 20subnet.ec2.aws.upbound.io/my-db-7mc7h-9t64t True True subnet-07075c17c7a72f79e 3m2s 21subnet.ec2.aws.upbound.io/my-db-7mc7h-rs8t8 True True subnet-08e88e826a42e55b4 3m2s 22subnet.ec2.aws.upbound.io/my-db-8bhr2-9sjpx True True subnet-05d21c7b52f7ac8ca 2m26s 23subnet.ec2.aws.upbound.io/my-db-8bhr2-dvrxf True True subnet-0432310376b5d09de 2m26s 24subnet.ec2.aws.upbound.io/my-db-8bhr2-t7dpr True True subnet-0080fdcb6e9b70632 2m26s 25 26NAME READY SYNCED EXTERNAL-NAME AGE 27vpc.ec2.aws.upbound.io/my-db-7mc7h-ktbbh True True vpc-08d7dd84e0c12f33e 3m3s 28vpc.ec2.aws.upbound.io/my-db-8bhr2-mrh2x True True vpc-06994bf323fc1daea 2m26s 29 30NAME READY SYNCED EXTERNAL-NAME AGE 31internetgateway.ec2.aws.upbound.io/my-db-7mc7h-s2x4v True True igw-0189c4da07a3142dc 3m1s 32internetgateway.ec2.aws.upbound.io/my-db-8bhr2-q7dzl True True igw-01bf2a1dbbebf6a27 2m26s 33 34NAME READY SYNCED EXTERNAL-NAME AGE 35routetableassociation.ec2.aws.upbound.io/my-db-7mc7h-28qb4 True True rtbassoc-0718d680b5a0e68fe 3m1s 36routetableassociation.ec2.aws.upbound.io/my-db-7mc7h-9hdlr True True rtbassoc-0faaedb88c6e1518c 3m1s 37routetableassociation.ec2.aws.upbound.io/my-db-7mc7h-txhmz True True rtbassoc-0e5010724ca027864 3m1s 38routetableassociation.ec2.aws.upbound.io/my-db-8bhr2-bvgkt False True 2m26s 39routetableassociation.ec2.aws.upbound.io/my-db-8bhr2-d9gbg False True 2m26s 40routetableassociation.ec2.aws.upbound.io/my-db-8bhr2-k6k8m False True 2m26s 41 42NAME READY SYNCED EXTERNAL-NAME AGE 43instance.rds.aws.upbound.io/my-db-7mc7h-5d6w4 False True my-db-7mc7h-5d6w4 3m1s 44instance.rds.aws.upbound.io/my-db-8bhr2-tx9kf False True my-db-8bhr2-tx9kf 2m26s 45 46NAME READY SYNCED EXTERNAL-NAME AGE 47subnetgroup.rds.aws.upbound.io/my-db-7mc7h-8c8n9 True True my-db-7mc7h-8c8n9 3m2s 48subnetgroup.rds.aws.upbound.io/my-db-8bhr2-mc5ps True True my-db-8bhr2-mc5ps 2m27s 49 50NAME READY SYNCED EXTERNAL-NAME AGE 51bucket.s3.aws.upbound.io/crossplane-bucket-867737b10 True True 52crossplane-bucket-867737b10 5m26s Remove composite resource definitions Removing installed composite resource definitions removes any composite resources defined by the composite resource definition and the managed resourced they created.\nView the installed composite resource definitions with kubectl get xrd.\n1kubectl get xrd 2NAME ESTABLISHED OFFERED AGE 3compositepostgresqlinstances.database.example.org True True 40s Delete the composite resource definitions with kubectl delete xrd.\n1kubectl delete xrd compositepostgresqlinstances.database.example.org Remove managed resources Manually delete any managed resources manually created.\nUse kubectl get managed to view remaining managed resources.\n1kubectl get managed 2NAME READY SYNCED EXTERNAL-NAME AGE 3bucket.s3.aws.upbound.io/crossplane-bucket-867737b10 True True crossplane-bucket-867737b10 8h Use kubectl delete to remove the resources.\n1kubectl delete bucket.s3.aws.upbound.io/crossplane-bucket-867737b10 Remove Crossplane providers List the installed providers with kubectl get providers.\n1kubectl get providers 2NAME INSTALLED HEALTHY PACKAGE AGE 3upbound-provider-aws True True xpkg.upbound.io/upbound/provider-aws:v0.27.0 8h Remove the installed providers with kubectl delete provider.\n1kubectl delete provider upbound-provider-aws Uninstall the Crossplane deployment Uninstall Crossplane using Helm with helm uninstall\n1helm uninstall crossplane --namespace crossplane-system Verify Helm removed the Crossplane pods with kubectl get pods\n1kubectl get pods -n crossplane-system 2No resources found in crossplane-system namespace. Delete the Crossplane namespace When Helm installs Crossplane it creates the crossplane-system namespace. Helm doesn\u0026rsquo;t uninstall this namespace with helm uninstall.\nManually delete the Crossplane namespace with kubectl delete namespace.\n1kubectl delete namespace crossplane-system Verify Kubernetes removed the namespace with kubectl get namespaces\n1kubectl get namespace 2NAME STATUS AGE 3default Active 2m45s 4kube-flannel Active 2m42s 5kube-node-lease Active 2m47s 6kube-public Active 2m47s 7kube-system Active 2m47s ","title":"Uninstall Crossplane","url":"/v1.14/software/uninstall/"},{"content":"Requested Resource Not Found If you use the Crossplane CLI to install a Provider or Configuration (e.g. crossplane install provider xpkg.upbound.io/crossplane-contrib/provider-aws:v0.33.0) and get the server could not find the requested resource error, more often than not, that is an indicator that the Crossplane CLI you\u0026rsquo;re using is outdated. In other words some Crossplane API has been graduated from alpha to beta or stable and the old plugin is not aware of this change.\nResource Status and Conditions Most Crossplane resources have a status section that can represent the current state of that particular resource. Running kubectl describe against a Crossplane resource will frequently give insightful information about its condition. For example, to determine the status of a GCP CloudSQLInstance managed resource use kubectl describe for the resource.\n1kubectl describe cloudsqlinstance my-db 2Status: 3 Conditions: 4 Last Transition Time: 2019-09-16T13:46:42Z 5 Reason: Creating 6 Status: False 7 Type: Ready Most Crossplane resources set the Ready condition. Ready represents the availability of the resource - whether it is creating, deleting, available, unavailable, binding, etc.\nResource Events Most Crossplane resources emit events when something interesting happens. You can see the events associated with a resource by running kubectl describe - e.g. kubectl describe cloudsqlinstance my-db. You can also see all events in a particular namespace by running kubectl get events.\n1Events: 2 Type Reason Age From Message 3 ---- ------ ---- ---- ------- 4 Warning CannotConnectToProvider 16s (x4 over 46s) managed/postgresqlserver.database.azure.crossplane.io cannot get referenced ProviderConfig: ProviderConfig.azure.crossplane.io \u0026#34;default\u0026#34; not found Note that events are namespaced, while many Crossplane resources (XRs, etc) are cluster scoped. Crossplane emits events for cluster scoped resources to the \u0026lsquo;default\u0026rsquo; namespace.\nCrossplane Logs The next place to look to get more information or investigate a failure would be in the Crossplane pod logs, which should be running in the crossplane-system namespace. To get the current Crossplane logs, run the following:\n1kubectl -n crossplane-system logs -lapp=crossplane Note that Crossplane emits few logs by default - events are typically the best place to look for information about what Crossplane is doing. You may need to restart Crossplane with the --debug flag if you can\u0026rsquo;t find what you\u0026rsquo;re looking for.\nProvider Logs Remember that much of Crossplane\u0026rsquo;s functionality is provided by providers. You can use kubectl logs to view provider logs too. By convention, they also emit few logs by default.\n1kubectl -n crossplane-system logs \u0026lt;name-of-provider-pod\u0026gt; All providers maintained by the Crossplane community mirror Crossplane\u0026rsquo;s support of the --debug flag. The easiest way to set flags on a provider is to create a ControllerConfig and reference it from the Provider:\n1apiVersion: pkg.crossplane.io/v1alpha1 2kind: ControllerConfig 3metadata: 4 name: debug-config 5spec: 6 args: 7 - --debug 8--- 9apiVersion: pkg.crossplane.io/v1 10kind: Provider 11metadata: 12 name: provider-aws 13spec: 14 package: xpkg.upbound.io/crossplane-contrib/provider-aws:v0.33.0 15 controllerConfigRef: 16 name: debug-config Note that a reference to a ControllerConfig can be added to an already installed Provider and it will update its Deployment accordingly.\nCompositions and composite resource definition General troubleshooting steps Crossplane and its providers log most error messages to resources\u0026rsquo; event fields. Whenever your Composite Resources aren\u0026rsquo;t getting provisioned, follow the following steps:\nGet the events for the root resource using kubectl describe or kubectl get event\nIf there are errors in the events, address them.\nIf there are no errors, follow its sub-resources.\nkubectl get \u0026lt;KIND\u0026gt; \u0026lt;NAME\u0026gt; -o=jsonpath='{.spec.resourceRef}{\u0026quot; \u0026quot;}{.spec.resourceRefs}' | jq\nRepeat this process for each resource returned.\nNote The rest of this section show you how to debug issues related to compositions without using external tooling. If you are using ArgoCD or FluxCD with UI, you can visualize object relationships in the UI. You can also use the kube-lineage plugin to visualize object relationships in your terminal. Examples Composition You deployed an example application using a claim. Kind = ExampleApp. Name = example-application.\nThe example application never reaches available state as shown below.\nView the claim.\n1kubectl describe exampleapp example-application 2 3Status: 4Conditions: 5 Last Transition Time: 2022-03-01T22:57:38Z 6 Reason: Composite resource claim is waiting for composite resource to become Ready 7 Status: False 8 Type: Ready 9Events: \u0026lt;none\u0026gt; If the claim doesn\u0026rsquo;t have errors, inspect the .spec.resourceRef field of the claim.\n1kubectl get exampleapp example-application -o=jsonpath=\u0026#39;{.spec.resourceRef}{\u0026#34; \u0026#34;}{.spec.resourceRefs}\u0026#39; | jq 2 3{ 4 \u0026#34;apiVersion\u0026#34;: \u0026#34;awsblueprints.io/v1alpha1\u0026#34;, 5 \u0026#34;kind\u0026#34;: \u0026#34;XExampleApp\u0026#34;, 6 \u0026#34;name\u0026#34;: \u0026#34;example-application-xqlsz\u0026#34; 7} In the preceding output, you see the cluster scoped resource for this claim. Kind = XExampleApp name = example-application-xqlsz\nView the cluster scoped resource\u0026rsquo;s events.\n1kubectl describe xexampleapp example-application-xqlsz 2 3Events: 4Type Reason Age From Message 5---- ------ ---- ---- ------- 6Normal PublishConnectionSecret 9s (x2 over 10s) defined/compositeresourcedefinition.apiextensions.crossplane.io Successfully published connection details 7Normal SelectComposition 6s (x6 over 11s) defined/compositeresourcedefinition.apiextensions.crossplane.io Successfully selected composition 8Warning ComposeResources 6s (x6 over 10s) defined/compositeresourcedefinition.apiextensions.crossplane.io can\u0026#39;t render composed resource from resource template at index 3: can\u0026#39;t use dry-run create to name composed resource: an empty namespace may not be set during creation 9Normal ComposeResources 6s (x6 over 10s) defined/compositeresourcedefinition.apiextensions.crossplane.io Successfully composed resources You see errors in the events. it\u0026rsquo;s complaining about not specifying namespace in its compositions. For this particular kind of error, you can get its sub-resources and check which one isn\u0026rsquo;t created.\n1kubectl get xexampleapp example-application-xqlsz -o=jsonpath=\u0026#39;{.spec.resourceRef}{\u0026#34; \u0026#34;}{.spec.resourceRefs}\u0026#39; | jq 2 3[ 4 { 5 \u0026#34;apiVersion\u0026#34;: \u0026#34;awsblueprints.io/v1alpha1\u0026#34;, 6 \u0026#34;kind\u0026#34;: \u0026#34;XDynamoDBTable\u0026#34;, 7 \u0026#34;name\u0026#34;: \u0026#34;example-application-xqlsz-6j9nm\u0026#34; 8 }, 9 { 10 \u0026#34;apiVersion\u0026#34;: \u0026#34;awsblueprints.io/v1alpha1\u0026#34;, 11 \u0026#34;kind\u0026#34;: \u0026#34;XIAMPolicy\u0026#34;, 12 \u0026#34;name\u0026#34;: \u0026#34;example-application-xqlsz-lp9wt\u0026#34; 13 }, 14 { 15 \u0026#34;apiVersion\u0026#34;: \u0026#34;awsblueprints.io/v1alpha1\u0026#34;, 16 \u0026#34;kind\u0026#34;: \u0026#34;XIAMPolicy\u0026#34;, 17 \u0026#34;name\u0026#34;: \u0026#34;example-application-xqlsz-btwkn\u0026#34; 18 }, 19 { 20 \u0026#34;apiVersion\u0026#34;: \u0026#34;awsblueprints.io/v1alpha1\u0026#34;, 21 \u0026#34;kind\u0026#34;: \u0026#34;IRSA\u0026#34; 22 } 23] Notice the last element in the array doesn\u0026rsquo;t have a name. When a resource in composition fails validation, the resource object isn\u0026rsquo;t created and doesn\u0026rsquo;t have a name. For this particular issue, you must specify the namespace for the IRSA resource.\nComposite resource definition Debugging Composite Resource Definition (XRD) is like debugging Compositions.\nGet the XRD\n1kubectl get xrd testing.awsblueprints.io 2 3NAME ESTABLISHED OFFERED AGE 4testing.awsblueprints.io 66s Notice its status it not established. You describe this XRD to get its events.\n1kubectl describe xrd testing.awsblueprints.io 2 3Events: 4Type Reason Age From Message 5---- ------ ---- ---- ------- 6Normal ApplyClusterRoles 3m19s (x3 over 3m19s) rbac/compositeresourcedefinition.apiextensions.crossplane.io Applied RBAC ClusterRoles 7Normal RenderCRD 18s (x9 over 3m19s) defined/compositeresourcedefinition.apiextensions.crossplane.io Rendered composite resource CustomResourceDefinition 8Warning EstablishComposite 18s (x9 over 3m19s) defined/compositeresourcedefinition.apiextensions.crossplane.io can\u0026#39;t apply rendered composite resource CustomResourceDefinition: can\u0026#39;t create object: CustomResourceDefinition.apiextensions.k8s.io \u0026#34;testing.awsblueprints.io\u0026#34; is invalid: metadata.name: Invalid value: \u0026#34;testing.awsblueprints.io\u0026#34;: must be spec.names.plural+\u0026#34;.\u0026#34;+spec.group You see in the events that Crossplane can\u0026rsquo;t generate corresponding CRDs for this XRD. In this case, ensure the name is spec.names.plural+\u0026quot;.\u0026quot;+spec.group\nProviders You can use install providers in two ways: configuration.pkg.crossplane.io and provider.pkg.crossplane.io. You can use either one to install providers with no functional differences to providers themselves. If you define a configuration.pkg.crossplane.io object, Crossplane creates a provider.pkg.crossplane.io object and manages it. Refer to the Packages documentation for more information about Crossplane Packages.\nIf you are experiencing provider issues, steps below are a good starting point.\nCheck the status of provider object.\n1kubectl describe provider.pkg.crossplane.io provider-aws 2 3Status: 4 Conditions: 5 Last Transition Time: 2022-08-04T16:19:44Z 6 Reason: HealthyPackageRevision 7 Status: True 8 Type: Healthy 9 Last Transition Time: 2022-08-04T16:14:29Z 10 Reason: ActivePackageRevision 11 Status: True 12 Type: Installed 13 Current Identifier: crossplane/provider-aws:v0.29.0 14 Current Revision: provider-aws-a2e16ca2fc1a 15Events: 16 Type Reason Age From Message 17 ---- ------ ---- ---- ------- 18 Normal InstallPackageRevision 9m49s (x237 over 4d17h) packages/provider.pkg.crossplane.io Successfully installed package revision In the output above you see that this provider is healthy. To get more information about this provider, you can dig deeper. The Current Revision field let you know of your next object to look at.\nWhen you create a provider object, Crossplane creates a ProviderRevision object based on the contents of the OCI image. In this example, you\u0026rsquo;re specifying the OCI image to be crossplane/provider-aws:v0.29.0. This image contains a YAML file which defines Kubernetes objects such as Deployment, ServiceAccount, and CRDs. The ProviderRevision object creates resources necessary for a provider to function based on the contents of the YAML file. To inspect what\u0026rsquo;s deployed as part of the provider package, you inspect the ProviderRevision object. The Current Revision field above indicates which ProviderRevision object this provider uses.\n1kubectl get providerrevision provider-aws-a2e16ca2fc1a 2 3NAME HEALTHY REVISION IMAGE STATE DEP-FOUND DEP-INSTALLED AGE 4provider-aws-a2e16ca2fc1a True 1 crossplane/provider-aws:v0.29.0 Active 19d When you describe the object, you find all CRDs managed by this object.\n1kubectl describe providerrevision provider-aws-a2e16ca2fc1a 2 3Status: 4 Controller Ref: 5 Name: provider-aws-a2e16ca2fc1a 6 Object Refs: 7 API Version: apiextensions.k8s.io/v1 8 Kind: CustomResourceDefinition 9 Name: natgateways.ec2.aws.crossplane.io 10 UID: 5c36d1bc-61b8-44f8-bca0-47e368af87a9 11 .... 12Events: 13 Type Reason Age From Message 14 ---- ------ ---- ---- ------- 15 Normal SyncPackage 22m (x369 over 4d18h) packages/providerrevision.pkg.crossplane.io Successfully configured package revision 16 Normal BindClusterRole 15m (x348 over 4d18h) rbac/providerrevision.pkg.crossplane.io Bound system ClusterRole to provider ServiceAccount 17 Normal ApplyClusterRoles 15m (x364 over 4d18h) rbac/providerrevision.pkg.crossplane.io Applied RBAC ClusterRoles The event field also indicates any issues that may have occurred during this process.\nIf you don\u0026rsquo;t see any errors in the event field above, you should check if Crossplane provisioned deployments and their status.\n1kubectl get deployment -n crossplane-system 2 3NAME READY UP-TO-DATE AVAILABLE AGE 4crossplane 1/1 1 1 105d 5crossplane-rbac-manager 1/1 1 1 105d 6provider-aws-a2e16ca2fc1a 1/1 1 1 19d 7 8kubectl get pods -n crossplane-system 9 10NAME READY STATUS RESTARTS AGE 11crossplane-54db688c8d-qng6b 2/2 Running 0 4d19h 12crossplane-rbac-manager-5776c9fbf4-wn5rj 1/1 Running 0 4d19h 13provider-aws-a2e16ca2fc1a-776769ccbd-4dqml 1/1 Running 0 4d23h If there are any pods failing, check its logs and remedy the problem.\nPausing Crossplane Sometimes, for example when you encounter a bug, it can be useful to pause Crossplane if you want to stop it from actively attempting to manage your resources. To pause Crossplane without deleting all of its resources, run the following command to simply scale down its deployment:\n1kubectl -n crossplane-system scale --replicas=0 deployment/crossplane Once you have been able to rectify the problem or smooth things out, you can unpause Crossplane simply by scaling its deployment back up:\n1kubectl -n crossplane-system scale --replicas=1 deployment/crossplane Pausing Providers Providers can also be paused when troubleshooting an issue or orchestrating a complex migration of resources. Creating and referencing a ControllerConfig is the easiest way to scale down a provider, and the ControllerConfig can be modified or the reference can be removed to scale it back up:\n1apiVersion: pkg.crossplane.io/v1alpha1 2kind: ControllerConfig 3metadata: 4 name: scale-config 5spec: 6 replicas: 0 7--- 8apiVersion: pkg.crossplane.io/v1 9kind: Provider 10metadata: 11 name: provider-aws 12spec: 13 package: xpkg.upbound.io/crossplane-contrib/provider-aws:v0.33.0 14 controllerConfigRef: 15 name: scale-config Note that a reference to a ControllerConfig can be added to an already installed Provider and it will update its Deployment accordingly.\nDeleting When a Resource Hangs The resources that Crossplane manages will automatically be cleaned up so as not to leave anything running behind. This is accomplished by using finalizers, but in certain scenarios the finalizer can prevent the Kubernetes object from getting deleted.\nTo deal with this, we essentially want to patch the object to remove its finalizer, which will then allow it to be deleted completely. Note that this won\u0026rsquo;t necessarily delete the external resource that Crossplane was managing, so you will want to go to your cloud provider\u0026rsquo;s console and look there for any lingering resources to clean up.\nIn general, a finalizer can be removed from an object with this command:\n1kubectl patch \u0026lt;resource-type\u0026gt; \u0026lt;resource-name\u0026gt; -p \u0026#39;{\u0026#34;metadata\u0026#34;:{\u0026#34;finalizers\u0026#34;: []}}\u0026#39; --type=merge For example, for a CloudSQLInstance managed resource (database.gcp.crossplane.io) named my-db, you can remove its finalizer with:\n1kubectl patch cloudsqlinstance my-db -p \u0026#39;{\u0026#34;metadata\u0026#34;:{\u0026#34;finalizers\u0026#34;: []}}\u0026#39; --type=merge Tips, Tricks, and Troubleshooting In this section we\u0026rsquo;ll cover some common tips, tricks, and troubleshooting steps for working with Composite Resources. If you\u0026rsquo;re trying to track down why your Composite Resources aren\u0026rsquo;t working the [Troubleshooting][trouble-ref] page also has some useful information.\nTroubleshooting Claims and XRs Crossplane relies heavily on status conditions and events for troubleshooting. You can see both using kubectl describe - for example:\n1# Describe the PostgreSQLInstance claim named my-db 2kubectl describe postgresqlinstance.database.example.org my-db Per Kubernetes convention, Crossplane keeps errors close to the place they happen. This means that if your claim is not becoming ready due to an issue with your Composition or with a composed resource you\u0026rsquo;ll need to \u0026ldquo;follow the references\u0026rdquo; to find out why. Your claim will only tell you that the XR is not yet ready.\nTo follow the references:\nFind your XR by running kubectl describe on your claim and looking for its \u0026ldquo;Resource Ref\u0026rdquo; (aka spec.resourceRef). Run kubectl describe on your XR. This is where you\u0026rsquo;ll find out about issues with the Composition you\u0026rsquo;re using, if any. If there are no issues but your XR doesn\u0026rsquo;t seem to be becoming ready, take a look for the \u0026ldquo;Resource Refs\u0026rdquo; (or spec.resourceRefs) to find your composed resources. Run kubectl describe on each referenced composed resource to determine whether it is ready and what issues, if any, it is encountering. ","title":"Troubleshoot","url":"/knowledge-base/guides/troubleshoot/"},{"content":"If you have any questions, please drop us a note on Crossplane Slack or contact us!\nLearn more about using Crossplane\nLatest Design Docs Roadmap Crossplane Architecture GitLab deploys into multiple clouds from kubectl using Crossplane CNCF Talks \u0026amp; Community Presentations Software Engineering Daily - Intro Podcast Writing Kubernetes controllers to extend Crossplane\nKeep the Space Shuttle Flying: Writing Robust Operators Best practices for building Kubernetes Operators Programming Kubernetes Book Contributor Guide Join the growing Crossplane community and get involved!\nJoin our Community Slack! Submit an issue on GitHub Attend our bi-weekly Community Meeting Join our bi-weekly live stream: The Binding Status Subscribe to our YouTube Channel Drop us a note on Twitter: @crossplane_io Email us: info@crossplane.io ","title":"Learn More","url":"/knowledge-base/guides/learn-more/"},{"content":"Starting with the v1.10.0 release, Crossplane is released on a quarterly (13 week) cadence. A cycle is comprised of three general stages:\nWeeks 1—11: Active Development Week 12: Feature Freeze Week 13: Code Freeze This results in four releases per year, with the most recent three releases being maintained at any given time. When a new release is cut, the fourth most recent release reaches end of life (EOL). Users can expect any given release to be maintained for nine months.\nDefinition of maintenance The Crossplane community defines maintenance in that relevant bug fixes that are merged to the main development branch will be eligible to be back-ported to the release branch of any currently maintained version, and patch releases will be cut appropriately. It\u0026rsquo;s also possible that a fix may be merged directly to the release branch if no longer applicable on the main development branch. Maintenance doesn\u0026rsquo;t indicate any SLA on response time for user support in the form of Slack messages or issues, but problems will be addressed on a best effort basis by maintainers and contributors for currently maintained releases.\nPatch releases This policy is subject to change in the future.\nPatch releases are cut for currently maintained minor versions on an as-needed basis. Any critical back-ported fixes will be included in a patch release as soon as possible after merge.\nPre-releases This policy is subject to change in the future.\nAlpha, Beta, and RC releases are cut for an upcoming release on an as-needed basis. As a policy, at least one pre-release will be cut prior to any minor release. Pre-releases won\u0026rsquo;t be made on release branches.\nProvider releases The Crossplane release cycle isn\u0026rsquo;t required to be adhered to by any other Crossplane projects, but a similar cadence is encouraged. Maintainers listed in each repository\u0026rsquo;s OWNERS.md file are responsible for determining and publishing the release cycle for their project.\nRelease stages The following stages are the main milestones in a Crossplane release.\nActive development During active development, any code that meets the requisite criteria (i.e. passing appropriate tests, approved by a maintainer, etc.) will be merged into the main development branch. At present, there is no requirement to formally submit an enhancement proposal prior to the start of the release cycle, but contributors are encouraged to open an issue and gather feedback before starting work on a major implementation (see CONTRIBUTING.md for more information).\nFeature freeze During feature freeze, no new functionality should be merged into the main development branch. Bug fixes, documentation changes, and non-critical changes may be made. In the case that a new feature is deemed absolutely necessary for a release, the Crossplane maintainers will weigh the impact of the change and make a decision on whether it should be included.\nCode freeze During code freeze, there should be no changes merged to the main development branch with the following exceptions:\nFixes to a failing test that\u0026rsquo;s deemed to be incorrectly testing functionality. Documentation only changes. It\u0026rsquo;s possible that a documentation freeze will be implemented in the future, but it\u0026rsquo;s not currently enforced. Fixes to a critical bug that wasn\u0026rsquo;t previously identified. Merging a bug fix during code freeze requires application for and approval of an exception by Crossplane maintainers. This process is currently informal, but may be formalized in the future. Release dates Crossplane releases once a quarter (every 13 weeks). Typically, the release happens on the Tuesday of the last week of the quarter, as shown on the community calendar. Keep in mind that the specific date is approximate. A lot of factors can alter the date slightly, such as code reviews, testing, and bug fixing to ensure a quality release.\n","title":"Release Cycle","url":"/knowledge-base/guides/release-cycle/"},{"content":"Feature Lifecycle Crossplane follows a similar feature lifecycle to upstream Kubernetes. All major new features must be added in alpha. Alpha features are expected to eventually graduate to beta, and then to general availability (GA). Features that languish at alpha or beta may be subject to deprecation.\nAlpha Features Alpha are off by default, and must be enabled by a feature flag, for example --enable-composition-revisions. API types pertaining to alpha features use a vNalphaN style API version, like v1alpha. Alpha features are subject to removal or breaking changes without notice, and generally not considered ready for use in production.\nIn some cases alpha features require fields be added to existing beta or GA API types. In these cases fields must clearly be marked (i.e in their OpenAPI schema) as alpha and subject to alpha API constraints (or lack thereof).\nAll alpha features should have an issue tracking their graduation to beta.\nBeta Features Beta features are on by default, but may be disabled by a feature flag. API types pertaining to beta features use a vNbetaN style API version, like v1beta1. Beta features are considered to be well tested, and will not be removed completely without being marked deprecated for at least two releases.\nThe schema and/or semantics of objects may change in incompatible ways in a subsequent beta or stable release. When this happens, we will provide instructions for migrating to the next version. This may require deleting, editing, and re-creating API objects. The editing process may require some thought. This may require downtime for applications that rely on the feature.\nIn some cases beta features require fields be added to existing GA API types. In these cases fields must clearly be marked (i.e in their OpenAPI schema) as beta and subject to beta API constraints (or lack thereof).\nAll beta features should have an issue tracking their graduation to GA.\nGA Features GA features are always enabled - they cannot be disabled. API types pertaining to GA features use vN style API versions, like v1. GA features are widely used and thoroughly tested. They guarantee API stability - only backward compatible changes are allowed.\n","title":"Feature Lifecycle","url":"/knowledge-base/guides/feature-lifecycle/"},{"content":"Changes and notable docs updates.\nNovember 1, 2023 New content 🎉 Created the v1.14 release documentation. New CLI documentation. New release notes section. Usages Crossplane type. Updated content 🏗️ Rewritten packages section focused on Crossplane configuration packages. Expanded providers content related to using Provider packages. Major updates to Composition Functions, moving them to v1beta1. Removed content 🗑️ Removed end of support v1.11 documentation. Content archived on GitHub. ","title":"Docs Changelog","url":"/v1.14/release-notes/docs/"},{"content":"Install Crossplane Crossplane installs into an existing Kubernetes cluster.\nTip If you don\u0026rsquo;t have a Kubernetes cluster create one locally with Kind. Install the Crossplane Helm chart Helm enables Crossplane to install all its Kubernetes components through a Helm Chart.\nEnable the Crossplane Helm Chart repository:\n1helm repo add \\ 2crossplane-stable https://charts.crossplane.io/stable 3helm repo update Run the Helm dry-run to see all the Crossplane components Helm installs.\n1helm install crossplane \\ 2crossplane-stable/crossplane \\ 3--dry-run --debug \\ 4--namespace crossplane-system \\ 5--create-namespace View the Helm dry-run 1helm install crossplane \\ 2crossplane-stable/crossplane \\ 3--dry-run --debug \\ 4--namespace crossplane-system \\ 5--create-namespace 6install.go:200: [debug] Original chart version: \u0026#34;\u0026#34; 7install.go:217: [debug] CHART PATH: /home/vagrant/.cache/helm/repository/crossplane-1.13.0.tgz 8 9NAME: crossplane 10LAST DEPLOYED: Fri Jul 28 13:57:41 2023 11NAMESPACE: crossplane-system 12STATUS: pending-install 13REVISION: 1 14TEST SUITE: None 15USER-SUPPLIED VALUES: 16{} 17 18COMPUTED VALUES: 19affinity: {} 20args: [] 21configuration: 22 packages: [] 23customAnnotations: {} 24customLabels: {} 25deploymentStrategy: RollingUpdate 26extraEnvVarsCrossplane: {} 27extraEnvVarsRBACManager: {} 28extraVolumeMountsCrossplane: {} 29extraVolumesCrossplane: {} 30hostNetwork: false 31image: 32 pullPolicy: IfNotPresent 33 repository: crossplane/crossplane 34 tag: \u0026#34;\u0026#34; 35imagePullSecrets: {} 36leaderElection: true 37metrics: 38 enabled: false 39nodeSelector: {} 40packageCache: 41 configMap: \u0026#34;\u0026#34; 42 medium: \u0026#34;\u0026#34; 43 pvc: \u0026#34;\u0026#34; 44 sizeLimit: 20Mi 45podSecurityContextCrossplane: {} 46podSecurityContextRBACManager: {} 47priorityClassName: \u0026#34;\u0026#34; 48provider: 49 packages: [] 50rbacManager: 51 affinity: {} 52 args: [] 53 deploy: true 54 leaderElection: true 55 managementPolicy: Basic 56 nodeSelector: {} 57 replicas: 1 58 skipAggregatedClusterRoles: false 59 tolerations: [] 60registryCaBundleConfig: 61 key: \u0026#34;\u0026#34; 62 name: \u0026#34;\u0026#34; 63replicas: 1 64resourcesCrossplane: 65 limits: 66 cpu: 100m 67 memory: 512Mi 68 requests: 69 cpu: 100m 70 memory: 256Mi 71resourcesRBACManager: 72 limits: 73 cpu: 100m 74 memory: 512Mi 75 requests: 76 cpu: 100m 77 memory: 256Mi 78securityContextCrossplane: 79 allowPrivilegeEscalation: false 80 readOnlyRootFilesystem: true 81 runAsGroup: 65532 82 runAsUser: 65532 83securityContextRBACManager: 84 allowPrivilegeEscalation: false 85 readOnlyRootFilesystem: true 86 runAsGroup: 65532 87 runAsUser: 65532 88serviceAccount: 89 customAnnotations: {} 90tolerations: [] 91webhooks: 92 enabled: true 93xfn: 94 args: [] 95 cache: 96 configMap: \u0026#34;\u0026#34; 97 medium: \u0026#34;\u0026#34; 98 pvc: \u0026#34;\u0026#34; 99 sizeLimit: 1Gi 100 enabled: false 101 extraEnvVars: {} 102 image: 103 pullPolicy: IfNotPresent 104 repository: crossplane/xfn 105 tag: \u0026#34;\u0026#34; 106 resources: 107 limits: 108 cpu: 2000m 109 memory: 2Gi 110 requests: 111 cpu: 1000m 112 memory: 1Gi 113 securityContext: 114 allowPrivilegeEscalation: false 115 capabilities: 116 add: 117 - SETUID 118 - SETGID 119 readOnlyRootFilesystem: true 120 runAsGroup: 65532 121 runAsUser: 65532 122 seccompProfile: 123 type: Unconfined 124 125HOOKS: 126MANIFEST: 127--- 128# Source: crossplane/templates/rbac-manager-serviceaccount.yaml 129apiVersion: v1 130kind: ServiceAccount 131metadata: 132 name: rbac-manager 133 namespace: crossplane-system 134 labels: 135 app: crossplane 136 helm.sh/chart: crossplane-1.13.0 137 app.kubernetes.io/managed-by: Helm 138 app.kubernetes.io/component: cloud-infrastructure-controller 139 app.kubernetes.io/part-of: crossplane 140 app.kubernetes.io/name: crossplane 141 app.kubernetes.io/instance: crossplane 142 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 143--- 144# Source: crossplane/templates/serviceaccount.yaml 145apiVersion: v1 146kind: ServiceAccount 147metadata: 148 name: crossplane 149 namespace: crossplane-system 150 labels: 151 app: crossplane 152 helm.sh/chart: crossplane-1.13.0 153 app.kubernetes.io/managed-by: Helm 154 app.kubernetes.io/component: cloud-infrastructure-controller 155 app.kubernetes.io/part-of: crossplane 156 app.kubernetes.io/name: crossplane 157 app.kubernetes.io/instance: crossplane 158 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 159--- 160# Source: crossplane/templates/secret.yaml 161# The reason this is created empty and filled by the init container is that it\u0026#39;s 162# mounted by the actual container, so if it wasn\u0026#39;t created by Helm, then the 163# deployment wouldn\u0026#39;t be deployed at all with secret to mount not found error. 164# In addition, Helm would delete this secret after uninstallation so the new 165# installation of Crossplane would use its own certificate. 166apiVersion: v1 167kind: Secret 168metadata: 169 name: webhook-tls-secret 170 namespace: crossplane-system 171type: Opaque 172--- 173# Source: crossplane/templates/clusterrole.yaml 174apiVersion: rbac.authorization.k8s.io/v1 175kind: ClusterRole 176metadata: 177 name: crossplane 178 labels: 179 app: crossplane 180 helm.sh/chart: crossplane-1.13.0 181 app.kubernetes.io/managed-by: Helm 182 app.kubernetes.io/component: cloud-infrastructure-controller 183 app.kubernetes.io/part-of: crossplane 184 app.kubernetes.io/name: crossplane 185 app.kubernetes.io/instance: crossplane 186 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 187aggregationRule: 188 clusterRoleSelectors: 189 - matchLabels: 190 rbac.crossplane.io/aggregate-to-crossplane: \u0026#34;true\u0026#34; 191--- 192# Source: crossplane/templates/clusterrole.yaml 193apiVersion: rbac.authorization.k8s.io/v1 194kind: ClusterRole 195metadata: 196 name: crossplane:system:aggregate-to-crossplane 197 labels: 198 app: crossplane 199 helm.sh/chart: crossplane-1.13.0 200 app.kubernetes.io/managed-by: Helm 201 app.kubernetes.io/component: cloud-infrastructure-controller 202 app.kubernetes.io/part-of: crossplane 203 app.kubernetes.io/name: crossplane 204 app.kubernetes.io/instance: crossplane 205 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 206 crossplane.io/scope: \u0026#34;system\u0026#34; 207 rbac.crossplane.io/aggregate-to-crossplane: \u0026#34;true\u0026#34; 208rules: 209- apiGroups: 210 - \u0026#34;\u0026#34; 211 resources: 212 - events 213 verbs: 214 - create 215 - update 216 - patch 217 - delete 218- apiGroups: 219 - apiextensions.k8s.io 220 resources: 221 - customresourcedefinitions 222 verbs: 223 - \u0026#34;*\u0026#34; 224- apiGroups: 225 - \u0026#34;\u0026#34; 226 resources: 227 - secrets 228 verbs: 229 - get 230 - list 231 - watch 232 - create 233 - update 234 - patch 235 - delete 236- apiGroups: 237 - \u0026#34;\u0026#34; 238 resources: 239 - serviceaccounts 240 - services 241 verbs: 242 - \u0026#34;*\u0026#34; 243- apiGroups: 244 - apiextensions.crossplane.io 245 - pkg.crossplane.io 246 - secrets.crossplane.io 247 resources: 248 - \u0026#34;*\u0026#34; 249 verbs: 250 - \u0026#34;*\u0026#34; 251- apiGroups: 252 - extensions 253 - apps 254 resources: 255 - deployments 256 verbs: 257 - get 258 - list 259 - create 260 - update 261 - patch 262 - delete 263 - watch 264- apiGroups: 265 - \u0026#34;\u0026#34; 266 - coordination.k8s.io 267 resources: 268 - configmaps 269 - leases 270 verbs: 271 - get 272 - list 273 - create 274 - update 275 - patch 276 - watch 277 - delete 278- apiGroups: 279 - admissionregistration.k8s.io 280 resources: 281 - validatingwebhookconfigurations 282 - mutatingwebhookconfigurations 283 verbs: 284 - get 285 - list 286 - create 287 - update 288 - patch 289 - watch 290 - delete 291--- 292# Source: crossplane/templates/rbac-manager-allowed-provider-permissions.yaml 293apiVersion: rbac.authorization.k8s.io/v1 294kind: ClusterRole 295metadata: 296 name: crossplane:allowed-provider-permissions 297 labels: 298 app: crossplane 299 helm.sh/chart: crossplane-1.13.0 300 app.kubernetes.io/managed-by: Helm 301 app.kubernetes.io/component: cloud-infrastructure-controller 302 app.kubernetes.io/part-of: crossplane 303 app.kubernetes.io/name: crossplane 304 app.kubernetes.io/instance: crossplane 305 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 306aggregationRule: 307 clusterRoleSelectors: 308 - matchLabels: 309 rbac.crossplane.io/aggregate-to-allowed-provider-permissions: \u0026#34;true\u0026#34; 310--- 311# Source: crossplane/templates/rbac-manager-clusterrole.yaml 312apiVersion: rbac.authorization.k8s.io/v1 313kind: ClusterRole 314metadata: 315 name: crossplane-rbac-manager 316 labels: 317 app: crossplane 318 helm.sh/chart: crossplane-1.13.0 319 app.kubernetes.io/managed-by: Helm 320 app.kubernetes.io/component: cloud-infrastructure-controller 321 app.kubernetes.io/part-of: crossplane 322 app.kubernetes.io/name: crossplane 323 app.kubernetes.io/instance: crossplane 324 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 325rules: 326- apiGroups: 327 - \u0026#34;\u0026#34; 328 resources: 329 - events 330 verbs: 331 - create 332 - update 333 - patch 334 - delete 335- apiGroups: 336 - \u0026#34;\u0026#34; 337 resources: 338 - namespaces 339 - serviceaccounts 340 verbs: 341 - get 342 - list 343 - watch 344# The RBAC manager creates a series of RBAC roles for each namespace it sees. 345# These RBAC roles are controlled (in the owner reference sense) by the namespace. 346# The RBAC manager needs permission to set finalizers on Namespaces in order to 347# create resources that block their deletion when the 348# OwnerReferencesPermissionEnforcement admission controller is enabled. 349# See https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#ownerreferencespermissionenforcement 350- apiGroups: 351 - \u0026#34;\u0026#34; 352 resources: 353 - namespaces/finalizers 354 verbs: 355 - update 356- apiGroups: 357 - apiextensions.crossplane.io 358 resources: 359 - compositeresourcedefinitions 360 verbs: 361 - get 362 - list 363 - watch 364# The RBAC manager creates a series of RBAC cluster roles for each XRD it sees. 365# These cluster roles are controlled (in the owner reference sense) by the XRD. 366# The RBAC manager needs permission to set finalizers on XRDs in order to 367# create resources that block their deletion when the 368# OwnerReferencesPermissionEnforcement admission controller is enabled. 369# See https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#ownerreferencespermissionenforcement 370- apiGroups: 371 - apiextensions.crossplane.io 372 resources: 373 - compositeresourcedefinitions/finalizers 374 verbs: 375 - update 376- apiGroups: 377 - pkg.crossplane.io 378 resources: 379 - providerrevisions 380 verbs: 381 - get 382 - list 383 - watch 384# The RBAC manager creates a series of RBAC cluster roles for each ProviderRevision 385# it sees. These cluster roles are controlled (in the owner reference sense) by the 386# ProviderRevision. The RBAC manager needs permission to set finalizers on 387# ProviderRevisions in order to create resources that block their deletion when the 388# OwnerReferencesPermissionEnforcement admission controller is enabled. 389# See https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#ownerreferencespermissionenforcement 390- apiGroups: 391 - pkg.crossplane.io 392 resources: 393 - providerrevisions/finalizers 394 verbs: 395 - update 396- apiGroups: 397 - apiextensions.k8s.io 398 resources: 399 - customresourcedefinitions 400 verbs: 401 - get 402 - list 403 - watch 404- apiGroups: 405 - rbac.authorization.k8s.io 406 resources: 407 - clusterroles 408 - roles 409 verbs: 410 - get 411 - list 412 - watch 413 - create 414 - update 415 - patch 416 # The RBAC manager may grant access it does not have. 417 - escalate 418- apiGroups: 419 - rbac.authorization.k8s.io 420 resources: 421 - clusterroles 422 verbs: 423 - bind 424- apiGroups: 425 - rbac.authorization.k8s.io 426 resources: 427 - clusterrolebindings 428 verbs: 429 - \u0026#34;*\u0026#34; 430- apiGroups: 431 - \u0026#34;\u0026#34; 432 - coordination.k8s.io 433 resources: 434 - configmaps 435 - leases 436 verbs: 437 - get 438 - list 439 - create 440 - update 441 - patch 442 - watch 443 - delete 444--- 445# Source: crossplane/templates/rbac-manager-managed-clusterroles.yaml 446apiVersion: rbac.authorization.k8s.io/v1 447kind: ClusterRole 448metadata: 449 name: crossplane-admin 450 labels: 451 app: crossplane 452 helm.sh/chart: crossplane-1.13.0 453 app.kubernetes.io/managed-by: Helm 454 app.kubernetes.io/component: cloud-infrastructure-controller 455 app.kubernetes.io/part-of: crossplane 456 app.kubernetes.io/name: crossplane 457 app.kubernetes.io/instance: crossplane 458 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 459aggregationRule: 460 clusterRoleSelectors: 461 - matchLabels: 462 rbac.crossplane.io/aggregate-to-admin: \u0026#34;true\u0026#34; 463--- 464# Source: crossplane/templates/rbac-manager-managed-clusterroles.yaml 465apiVersion: rbac.authorization.k8s.io/v1 466kind: ClusterRole 467metadata: 468 name: crossplane-edit 469 labels: 470 app: crossplane 471 helm.sh/chart: crossplane-1.13.0 472 app.kubernetes.io/managed-by: Helm 473 app.kubernetes.io/component: cloud-infrastructure-controller 474 app.kubernetes.io/part-of: crossplane 475 app.kubernetes.io/name: crossplane 476 app.kubernetes.io/instance: crossplane 477 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 478aggregationRule: 479 clusterRoleSelectors: 480 - matchLabels: 481 rbac.crossplane.io/aggregate-to-edit: \u0026#34;true\u0026#34; 482--- 483# Source: crossplane/templates/rbac-manager-managed-clusterroles.yaml 484apiVersion: rbac.authorization.k8s.io/v1 485kind: ClusterRole 486metadata: 487 name: crossplane-view 488 labels: 489 app: crossplane 490 helm.sh/chart: crossplane-1.13.0 491 app.kubernetes.io/managed-by: Helm 492 app.kubernetes.io/component: cloud-infrastructure-controller 493 app.kubernetes.io/part-of: crossplane 494 app.kubernetes.io/name: crossplane 495 app.kubernetes.io/instance: crossplane 496 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 497aggregationRule: 498 clusterRoleSelectors: 499 - matchLabels: 500 rbac.crossplane.io/aggregate-to-view: \u0026#34;true\u0026#34; 501--- 502# Source: crossplane/templates/rbac-manager-managed-clusterroles.yaml 503apiVersion: rbac.authorization.k8s.io/v1 504kind: ClusterRole 505metadata: 506 name: crossplane-browse 507 labels: 508 app: crossplane 509 helm.sh/chart: crossplane-1.13.0 510 app.kubernetes.io/managed-by: Helm 511 app.kubernetes.io/component: cloud-infrastructure-controller 512 app.kubernetes.io/part-of: crossplane 513 app.kubernetes.io/name: crossplane 514 app.kubernetes.io/instance: crossplane 515 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 516aggregationRule: 517 clusterRoleSelectors: 518 - matchLabels: 519 rbac.crossplane.io/aggregate-to-browse: \u0026#34;true\u0026#34; 520--- 521# Source: crossplane/templates/rbac-manager-managed-clusterroles.yaml 522apiVersion: rbac.authorization.k8s.io/v1 523kind: ClusterRole 524metadata: 525 name: crossplane:aggregate-to-admin 526 labels: 527 rbac.crossplane.io/aggregate-to-admin: \u0026#34;true\u0026#34; 528 app: crossplane 529 helm.sh/chart: crossplane-1.13.0 530 app.kubernetes.io/managed-by: Helm 531 app.kubernetes.io/component: cloud-infrastructure-controller 532 app.kubernetes.io/part-of: crossplane 533 app.kubernetes.io/name: crossplane 534 app.kubernetes.io/instance: crossplane 535 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 536rules: 537# Crossplane administrators have access to view events. 538- apiGroups: [\u0026#34;\u0026#34;] 539 resources: [events] 540 verbs: [get, list, watch] 541# Crossplane administrators must create provider credential secrets, and may 542# need to read or otherwise interact with connection secrets. They may also need 543# to create or annotate namespaces. 544- apiGroups: [\u0026#34;\u0026#34;] 545 resources: [secrets, namespaces] 546 verbs: [\u0026#34;*\u0026#34;] 547# Crossplane administrators have access to view the roles that they may be able 548# to grant to other subjects. 549- apiGroups: [rbac.authorization.k8s.io] 550 resources: [clusterroles, roles] 551 verbs: [get, list, watch] 552# Crossplane administrators have access to grant the access they have to other 553# subjects. 554- apiGroups: [rbac.authorization.k8s.io] 555 resources: [clusterrolebindings, rolebindings] 556 verbs: [\u0026#34;*\u0026#34;] 557# Crossplane administrators have full access to built in Crossplane types. 558- apiGroups: 559 - apiextensions.crossplane.io 560 resources: [\u0026#34;*\u0026#34;] 561 verbs: [\u0026#34;*\u0026#34;] 562- apiGroups: 563 - pkg.crossplane.io 564 resources: [locks, providers, configurations, providerrevisions, configurationrevisions] 565 verbs: [\u0026#34;*\u0026#34;] 566# Crossplane administrators have access to view CRDs in order to debug XRDs. 567- apiGroups: [apiextensions.k8s.io] 568 resources: [customresourcedefinitions] 569 verbs: [get, list, watch] 570--- 571# Source: crossplane/templates/rbac-manager-managed-clusterroles.yaml 572apiVersion: rbac.authorization.k8s.io/v1 573kind: ClusterRole 574metadata: 575 name: crossplane:aggregate-to-edit 576 labels: 577 rbac.crossplane.io/aggregate-to-edit: \u0026#34;true\u0026#34; 578 app: crossplane 579 helm.sh/chart: crossplane-1.13.0 580 app.kubernetes.io/managed-by: Helm 581 app.kubernetes.io/component: cloud-infrastructure-controller 582 app.kubernetes.io/part-of: crossplane 583 app.kubernetes.io/name: crossplane 584 app.kubernetes.io/instance: crossplane 585 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 586rules: 587# Crossplane editors have access to view events. 588- apiGroups: [\u0026#34;\u0026#34;] 589 resources: [events] 590 verbs: [get, list, watch] 591# Crossplane editors must create provider credential secrets, and may need to 592# read or otherwise interact with connection secrets. 593- apiGroups: [\u0026#34;\u0026#34;] 594 resources: [secrets] 595 verbs: [\u0026#34;*\u0026#34;] 596# Crossplane editors may see which namespaces exist, but not edit them. 597- apiGroups: [\u0026#34;\u0026#34;] 598 resources: [namespaces] 599 verbs: [get, list, watch] 600# Crossplane editors have full access to built in Crossplane types. 601- apiGroups: 602 - apiextensions.crossplane.io 603 resources: [\u0026#34;*\u0026#34;] 604 verbs: [\u0026#34;*\u0026#34;] 605- apiGroups: 606 - pkg.crossplane.io 607 resources: [locks, providers, configurations, providerrevisions, configurationrevisions] 608 verbs: [\u0026#34;*\u0026#34;] 609--- 610# Source: crossplane/templates/rbac-manager-managed-clusterroles.yaml 611apiVersion: rbac.authorization.k8s.io/v1 612kind: ClusterRole 613metadata: 614 name: crossplane:aggregate-to-view 615 labels: 616 rbac.crossplane.io/aggregate-to-view: \u0026#34;true\u0026#34; 617 app: crossplane 618 helm.sh/chart: crossplane-1.13.0 619 app.kubernetes.io/managed-by: Helm 620 app.kubernetes.io/component: cloud-infrastructure-controller 621 app.kubernetes.io/part-of: crossplane 622 app.kubernetes.io/name: crossplane 623 app.kubernetes.io/instance: crossplane 624 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 625rules: 626# Crossplane viewers have access to view events. 627- apiGroups: [\u0026#34;\u0026#34;] 628 resources: [events] 629 verbs: [get, list, watch] 630# Crossplane viewers may see which namespaces exist. 631- apiGroups: [\u0026#34;\u0026#34;] 632 resources: [namespaces] 633 verbs: [get, list, watch] 634# Crossplane viewers have read-only access to built in Crossplane types. 635- apiGroups: 636 - apiextensions.crossplane.io 637 resources: [\u0026#34;*\u0026#34;] 638 verbs: [get, list, watch] 639- apiGroups: 640 - pkg.crossplane.io 641 resources: [locks, providers, configurations, providerrevisions, configurationrevisions] 642 verbs: [get, list, watch] 643--- 644# Source: crossplane/templates/rbac-manager-managed-clusterroles.yaml 645apiVersion: rbac.authorization.k8s.io/v1 646kind: ClusterRole 647metadata: 648 name: crossplane:aggregate-to-browse 649 labels: 650 rbac.crossplane.io/aggregate-to-browse: \u0026#34;true\u0026#34; 651 app: crossplane 652 helm.sh/chart: crossplane-1.13.0 653 app.kubernetes.io/managed-by: Helm 654 app.kubernetes.io/component: cloud-infrastructure-controller 655 app.kubernetes.io/part-of: crossplane 656 app.kubernetes.io/name: crossplane 657 app.kubernetes.io/instance: crossplane 658 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 659rules: 660# Crossplane browsers have access to view events. 661- apiGroups: [\u0026#34;\u0026#34;] 662 resources: [events] 663 verbs: [get, list, watch] 664# Crossplane browsers have read-only access to compositions and XRDs. This 665# allows them to discover and select an appropriate composition when creating a 666# resource claim. 667- apiGroups: 668 - apiextensions.crossplane.io 669 resources: [\u0026#34;*\u0026#34;] 670 verbs: [get, list, watch] 671--- 672# Source: crossplane/templates/rbac-manager-managed-clusterroles.yaml 673# The below ClusterRoles are aggregated to the namespaced RBAC roles created by 674# the Crossplane RBAC manager when it is running in --manage=All mode. 675apiVersion: rbac.authorization.k8s.io/v1 676kind: ClusterRole 677metadata: 678 name: crossplane:aggregate-to-ns-admin 679 labels: 680 rbac.crossplane.io/aggregate-to-ns-admin: \u0026#34;true\u0026#34; 681 rbac.crossplane.io/base-of-ns-admin: \u0026#34;true\u0026#34; 682 app: crossplane 683 helm.sh/chart: crossplane-1.13.0 684 app.kubernetes.io/managed-by: Helm 685 app.kubernetes.io/component: cloud-infrastructure-controller 686 app.kubernetes.io/part-of: crossplane 687 app.kubernetes.io/name: crossplane 688 app.kubernetes.io/instance: crossplane 689 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 690rules: 691# Crossplane namespace admins have access to view events. 692- apiGroups: [\u0026#34;\u0026#34;] 693 resources: [events] 694 verbs: [get, list, watch] 695# Crossplane namespace admins may need to read or otherwise interact with 696# resource claim connection secrets. 697- apiGroups: [\u0026#34;\u0026#34;] 698 resources: [secrets] 699 verbs: [\u0026#34;*\u0026#34;] 700# Crossplane namespace admins have access to view the roles that they may be 701# able to grant to other subjects. 702- apiGroups: [rbac.authorization.k8s.io] 703 resources: [roles] 704 verbs: [get, list, watch] 705# Crossplane namespace admins have access to grant the access they have to other 706# subjects. 707- apiGroups: [rbac.authorization.k8s.io] 708 resources: [rolebindings] 709 verbs: [\u0026#34;*\u0026#34;] 710--- 711# Source: crossplane/templates/rbac-manager-managed-clusterroles.yaml 712apiVersion: rbac.authorization.k8s.io/v1 713kind: ClusterRole 714metadata: 715 name: crossplane:aggregate-to-ns-edit 716 labels: 717 rbac.crossplane.io/aggregate-to-ns-edit: \u0026#34;true\u0026#34; 718 rbac.crossplane.io/base-of-ns-edit: \u0026#34;true\u0026#34; 719 app: crossplane 720 helm.sh/chart: crossplane-1.13.0 721 app.kubernetes.io/managed-by: Helm 722 app.kubernetes.io/component: cloud-infrastructure-controller 723 app.kubernetes.io/part-of: crossplane 724 app.kubernetes.io/name: crossplane 725 app.kubernetes.io/instance: crossplane 726 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 727rules: 728# Crossplane namespace editors have access to view events. 729- apiGroups: [\u0026#34;\u0026#34;] 730 resources: [events] 731 verbs: [get, list, watch] 732# Crossplane namespace editors may need to read or otherwise interact with 733# resource claim connection secrets. 734- apiGroups: [\u0026#34;\u0026#34;] 735 resources: [secrets] 736 verbs: [\u0026#34;*\u0026#34;] 737--- 738# Source: crossplane/templates/rbac-manager-managed-clusterroles.yaml 739apiVersion: rbac.authorization.k8s.io/v1 740kind: ClusterRole 741metadata: 742 name: crossplane:aggregate-to-ns-view 743 labels: 744 rbac.crossplane.io/aggregate-to-ns-view: \u0026#34;true\u0026#34; 745 rbac.crossplane.io/base-of-ns-view: \u0026#34;true\u0026#34; 746 app: crossplane 747 helm.sh/chart: crossplane-1.13.0 748 app.kubernetes.io/managed-by: Helm 749 app.kubernetes.io/component: cloud-infrastructure-controller 750 app.kubernetes.io/part-of: crossplane 751 app.kubernetes.io/name: crossplane 752 app.kubernetes.io/instance: crossplane 753 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 754rules: 755# Crossplane namespace viewers have access to view events. 756- apiGroups: [\u0026#34;\u0026#34;] 757 resources: [events] 758 verbs: [get, list, watch] 759--- 760# Source: crossplane/templates/clusterrolebinding.yaml 761apiVersion: rbac.authorization.k8s.io/v1 762kind: ClusterRoleBinding 763metadata: 764 name: crossplane 765 labels: 766 app: crossplane 767 helm.sh/chart: crossplane-1.13.0 768 app.kubernetes.io/managed-by: Helm 769 app.kubernetes.io/component: cloud-infrastructure-controller 770 app.kubernetes.io/part-of: crossplane 771 app.kubernetes.io/name: crossplane 772 app.kubernetes.io/instance: crossplane 773 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 774roleRef: 775 apiGroup: rbac.authorization.k8s.io 776 kind: ClusterRole 777 name: crossplane 778subjects: 779- kind: ServiceAccount 780 name: crossplane 781 namespace: crossplane-system 782--- 783# Source: crossplane/templates/rbac-manager-clusterrolebinding.yaml 784apiVersion: rbac.authorization.k8s.io/v1 785kind: ClusterRoleBinding 786metadata: 787 name: crossplane-rbac-manager 788 labels: 789 app: crossplane 790 helm.sh/chart: crossplane-1.13.0 791 app.kubernetes.io/managed-by: Helm 792 app.kubernetes.io/component: cloud-infrastructure-controller 793 app.kubernetes.io/part-of: crossplane 794 app.kubernetes.io/name: crossplane 795 app.kubernetes.io/instance: crossplane 796 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 797roleRef: 798 apiGroup: rbac.authorization.k8s.io 799 kind: ClusterRole 800 name: crossplane-rbac-manager 801subjects: 802- kind: ServiceAccount 803 name: rbac-manager 804 namespace: crossplane-system 805--- 806# Source: crossplane/templates/rbac-manager-managed-clusterroles.yaml 807apiVersion: rbac.authorization.k8s.io/v1 808kind: ClusterRoleBinding 809metadata: 810 name: crossplane-admin 811 labels: 812 app: crossplane 813 helm.sh/chart: crossplane-1.13.0 814 app.kubernetes.io/managed-by: Helm 815 app.kubernetes.io/component: cloud-infrastructure-controller 816 app.kubernetes.io/part-of: crossplane 817 app.kubernetes.io/name: crossplane 818 app.kubernetes.io/instance: crossplane 819 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 820roleRef: 821 apiGroup: rbac.authorization.k8s.io 822 kind: ClusterRole 823 name: crossplane-admin 824subjects: 825- apiGroup: rbac.authorization.k8s.io 826 kind: Group 827 name: crossplane:masters 828--- 829# Source: crossplane/templates/service.yaml 830apiVersion: v1 831kind: Service 832metadata: 833 name: crossplane-webhooks 834 namespace: crossplane-system 835 labels: 836 app: crossplane 837 release: crossplane 838 helm.sh/chart: crossplane-1.13.0 839 app.kubernetes.io/managed-by: Helm 840 app.kubernetes.io/component: cloud-infrastructure-controller 841 app.kubernetes.io/part-of: crossplane 842 app.kubernetes.io/name: crossplane 843 app.kubernetes.io/instance: crossplane 844 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 845spec: 846 selector: 847 app: crossplane 848 release: crossplane 849 ports: 850 - protocol: TCP 851 port: 9443 852 targetPort: 9443 853--- 854# Source: crossplane/templates/deployment.yaml 855apiVersion: apps/v1 856kind: Deployment 857metadata: 858 name: crossplane 859 namespace: crossplane-system 860 labels: 861 app: crossplane 862 release: crossplane 863 helm.sh/chart: crossplane-1.13.0 864 app.kubernetes.io/managed-by: Helm 865 app.kubernetes.io/component: cloud-infrastructure-controller 866 app.kubernetes.io/part-of: crossplane 867 app.kubernetes.io/name: crossplane 868 app.kubernetes.io/instance: crossplane 869 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 870spec: 871 replicas: 1 872 selector: 873 matchLabels: 874 app: crossplane 875 release: crossplane 876 strategy: 877 type: RollingUpdate 878 template: 879 metadata: 880 labels: 881 app: crossplane 882 release: crossplane 883 helm.sh/chart: crossplane-1.13.0 884 app.kubernetes.io/managed-by: Helm 885 app.kubernetes.io/component: cloud-infrastructure-controller 886 app.kubernetes.io/part-of: crossplane 887 app.kubernetes.io/name: crossplane 888 app.kubernetes.io/instance: crossplane 889 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 890 spec: 891 securityContext: 892 {} 893 serviceAccountName: crossplane 894 hostNetwork: false 895 initContainers: 896 - image: \u0026#34;crossplane/crossplane:v1.13.0\u0026#34; 897 args: 898 - core 899 - init 900 imagePullPolicy: IfNotPresent 901 name: crossplane-init 902 resources: 903 limits: 904 cpu: 100m 905 memory: 512Mi 906 requests: 907 cpu: 100m 908 memory: 256Mi 909 securityContext: 910 allowPrivilegeEscalation: false 911 readOnlyRootFilesystem: true 912 runAsGroup: 65532 913 runAsUser: 65532 914 env: 915 - name: GOMAXPROCS 916 valueFrom: 917 resourceFieldRef: 918 containerName: crossplane-init 919 resource: limits.cpu 920 - name: GOMEMLIMIT 921 valueFrom: 922 resourceFieldRef: 923 containerName: crossplane-init 924 resource: limits.memory 925 - name: POD_NAMESPACE 926 valueFrom: 927 fieldRef: 928 fieldPath: metadata.namespace 929 - name: POD_SERVICE_ACCOUNT 930 valueFrom: 931 fieldRef: 932 fieldPath: spec.serviceAccountName 933 - name: \u0026#34;WEBHOOK_TLS_SECRET_NAME\u0026#34; 934 value: webhook-tls-secret 935 - name: \u0026#34;WEBHOOK_SERVICE_NAME\u0026#34; 936 value: crossplane-webhooks 937 - name: \u0026#34;WEBHOOK_SERVICE_NAMESPACE\u0026#34; 938 valueFrom: 939 fieldRef: 940 fieldPath: metadata.namespace 941 - name: \u0026#34;WEBHOOK_SERVICE_PORT\u0026#34; 942 value: \u0026#34;9443\u0026#34; 943 containers: 944 - image: \u0026#34;crossplane/crossplane:v1.13.0\u0026#34; 945 args: 946 - core 947 - start 948 imagePullPolicy: IfNotPresent 949 name: crossplane 950 resources: 951 limits: 952 cpu: 100m 953 memory: 512Mi 954 requests: 955 cpu: 100m 956 memory: 256Mi 957 ports: 958 - name: webhooks 959 containerPort: 9443 960 securityContext: 961 allowPrivilegeEscalation: false 962 readOnlyRootFilesystem: true 963 runAsGroup: 65532 964 runAsUser: 65532 965 env: 966 - name: GOMAXPROCS 967 valueFrom: 968 resourceFieldRef: 969 containerName: crossplane 970 resource: limits.cpu 971 - name: GOMEMLIMIT 972 valueFrom: 973 resourceFieldRef: 974 containerName: crossplane 975 resource: limits.memory 976 - name: POD_NAMESPACE 977 valueFrom: 978 fieldRef: 979 fieldPath: metadata.namespace 980 - name: POD_SERVICE_ACCOUNT 981 valueFrom: 982 fieldRef: 983 fieldPath: spec.serviceAccountName 984 - name: LEADER_ELECTION 985 value: \u0026#34;true\u0026#34; 986 - name: \u0026#34;WEBHOOK_TLS_SECRET_NAME\u0026#34; 987 value: webhook-tls-secret 988 - name: \u0026#34;WEBHOOK_TLS_CERT_DIR\u0026#34; 989 value: /webhook/tls 990 volumeMounts: 991 - mountPath: /cache 992 name: package-cache 993 - mountPath: /webhook/tls 994 name: webhook-tls-secret 995 volumes: 996 - name: package-cache 997 emptyDir: 998 medium: 999 sizeLimit: 20Mi 1000 - name: webhook-tls-secret 1001 secret: 1002 # NOTE(muvaf): The tls.crt is used both by the server (requires it to 1003 # be a single cert) and the caBundle fields of webhook configs and CRDs 1004 # which can accept a whole bundle of certificates. In order to meet 1005 # the requirements of both, we require a single certificate instead of 1006 # a bundle. 1007 # It\u0026#39;s assumed that initializer generates this anyway, so it should be 1008 # fine. 1009 secretName: webhook-tls-secret 1010--- 1011# Source: crossplane/templates/rbac-manager-deployment.yaml 1012apiVersion: apps/v1 1013kind: Deployment 1014metadata: 1015 name: crossplane-rbac-manager 1016 namespace: crossplane-system 1017 labels: 1018 app: crossplane-rbac-manager 1019 release: crossplane 1020 helm.sh/chart: crossplane-1.13.0 1021 app.kubernetes.io/managed-by: Helm 1022 app.kubernetes.io/component: cloud-infrastructure-controller 1023 app.kubernetes.io/part-of: crossplane 1024 app.kubernetes.io/name: crossplane 1025 app.kubernetes.io/instance: crossplane 1026 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 1027spec: 1028 replicas: 1 1029 selector: 1030 matchLabels: 1031 app: crossplane-rbac-manager 1032 release: crossplane 1033 strategy: 1034 type: RollingUpdate 1035 template: 1036 metadata: 1037 labels: 1038 app: crossplane-rbac-manager 1039 release: crossplane 1040 helm.sh/chart: crossplane-1.13.0 1041 app.kubernetes.io/managed-by: Helm 1042 app.kubernetes.io/component: cloud-infrastructure-controller 1043 app.kubernetes.io/part-of: crossplane 1044 app.kubernetes.io/name: crossplane 1045 app.kubernetes.io/instance: crossplane 1046 app.kubernetes.io/version: \u0026#34;1.13.0\u0026#34; 1047 spec: 1048 securityContext: 1049 {} 1050 serviceAccountName: rbac-manager 1051 initContainers: 1052 - image: \u0026#34;crossplane/crossplane:v1.13.0\u0026#34; 1053 args: 1054 - rbac 1055 - init 1056 imagePullPolicy: IfNotPresent 1057 name: crossplane-init 1058 resources: 1059 limits: 1060 cpu: 100m 1061 memory: 512Mi 1062 requests: 1063 cpu: 100m 1064 memory: 256Mi 1065 securityContext: 1066 allowPrivilegeEscalation: false 1067 readOnlyRootFilesystem: true 1068 runAsGroup: 65532 1069 runAsUser: 65532 1070 env: 1071 - name: GOMAXPROCS 1072 valueFrom: 1073 resourceFieldRef: 1074 containerName: crossplane-init 1075 resource: limits.cpu 1076 - name: GOMEMLIMIT 1077 valueFrom: 1078 resourceFieldRef: 1079 containerName: crossplane-init 1080 resource: limits.memory 1081 containers: 1082 - image: \u0026#34;crossplane/crossplane:v1.13.0\u0026#34; 1083 args: 1084 - rbac 1085 - start 1086 - --manage=Basic 1087 - --provider-clusterrole=crossplane:allowed-provider-permissions 1088 imagePullPolicy: IfNotPresent 1089 name: crossplane 1090 resources: 1091 limits: 1092 cpu: 100m 1093 memory: 512Mi 1094 requests: 1095 cpu: 100m 1096 memory: 256Mi 1097 securityContext: 1098 allowPrivilegeEscalation: false 1099 readOnlyRootFilesystem: true 1100 runAsGroup: 65532 1101 runAsUser: 65532 1102 env: 1103 - name: GOMAXPROCS 1104 valueFrom: 1105 resourceFieldRef: 1106 containerName: crossplane 1107 resource: limits.cpu 1108 - name: GOMEMLIMIT 1109 valueFrom: 1110 resourceFieldRef: 1111 containerName: crossplane 1112 resource: limits.memory 1113 - name: LEADER_ELECTION 1114 value: \u0026#34;true\u0026#34; 1115 1116NOTES: 1117Release: crossplane 1118 1119Chart Name: crossplane 1120Chart Description: Crossplane is an open source Kubernetes add-on that enables platform teams to assemble infrastructure from multiple vendors, and expose higher level self-service APIs for application teams to consume. 1121Chart Version: 1.13.0 1122Chart Application Version: 1.13.0 1123 1124Kube Version: v1.27.4 Install the Crossplane components using helm install.\n1helm install crossplane \\ 2crossplane-stable/crossplane \\ 3--namespace crossplane-system \\ 4--create-namespace Verify Crossplane installed with kubectl get pods.\n1kubectl get pods -n crossplane-system 2NAME READY STATUS RESTARTS AGE 3crossplane-d4cd8d784-ldcgb 1/1 Running 0 54s 4crossplane-rbac-manager-84769b574-6mw6f 1/1 Running 0 54s Installing Crossplane creates new Kubernetes API end-points.\nLook at the new API end-points with kubectl api-resources | grep crossplane.\n1kubectl api-resources | grep crossplane 2compositeresourcedefinitions xrd,xrds apiextensions.crossplane.io/v1 false CompositeResourceDefinition 3compositionrevisions comprev apiextensions.crossplane.io/v1 false CompositionRevision 4compositions comp apiextensions.crossplane.io/v1 false Composition 5environmentconfigs envcfg apiextensions.crossplane.io/v1alpha1 false EnvironmentConfig 6configurationrevisions pkg.crossplane.io/v1 false ConfigurationRevision 7configurations pkg.crossplane.io/v1 false Configuration 8controllerconfigs pkg.crossplane.io/v1alpha1 false ControllerConfig 9locks pkg.crossplane.io/v1beta1 false Lock 10providerrevisions pkg.crossplane.io/v1 false ProviderRevision 11providers pkg.crossplane.io/v1 false Provider 12storeconfigs secrets.crossplane.io/v1alpha1 false StoreConfig ","title":"","url":"/v1.14/getting-started/install-crossplane-include/"},{"content":"This tutorial discusses how CompositionRevisions work and how they manage Composite Resource (XR) updates. This starts with a Composition and CompositeResourceDefinition (XRD) that defines a MyVPC resource and continues with creating multiple XRs to observe different upgrade paths. Crossplane will assign different CompositionRevisions to the created composite resources each time the composition is updated.\nPreparation Install Crossplane Install Crossplane v1.11.0 or later and wait until the Crossplane pods are running.\n1kubectl create namespace crossplane-system 2helm repo add crossplane-master https://charts.crossplane.io/master/ 3helm repo update 4helm install crossplane --namespace crossplane-system crossplane-master/crossplane --devel --version 1.11.0-rc.0.108.g0521c32e 5kubectl get pods -n crossplane-system Expected Output:\n1NAME READY STATUS RESTARTS AGE 2crossplane-7f75ddcc46-f4d2z 1/1 Running 0 9s 3crossplane-rbac-manager-78bd597746-sdv6w 1/1 Running 0 9s Deploy Composition and XRD Examples Apply the example Composition.\n1apiVersion: apiextensions.crossplane.io/v1 2kind: Composition 3metadata: 4 labels: 5 channel: dev 6 name: myvpcs.aws.example.upbound.io 7spec: 8 writeConnectionSecretsToNamespace: crossplane-system 9 compositeTypeRef: 10 apiVersion: aws.example.upbound.io/v1alpha1 11 kind: MyVPC 12 resources: 13 - base: 14 apiVersion: ec2.aws.upbound.io/v1beta1 15 kind: VPC 16 spec: 17 forProvider: 18 region: us-west-1 19 cidrBlock: 192.168.0.0/16 20 enableDnsSupport: true 21 enableDnsHostnames: true 22 name: my-vcp Apply the example XRD.\n1apiVersion: apiextensions.crossplane.io/v1 2kind: CompositeResourceDefinition 3metadata: 4 name: myvpcs.aws.example.upbound.io 5spec: 6 group: aws.example.upbound.io 7 names: 8 kind: MyVPC 9 plural: myvpcs 10 versions: 11 - name: v1alpha1 12 served: true 13 referenceable: true 14 schema: 15 openAPIV3Schema: 16 type: object 17 properties: 18 spec: 19 type: object 20 properties: 21 id: 22 type: string 23 description: ID of this VPC that other objects will use to refer to it. 24 required: 25 - id Verify that Crossplane created the Composition revision\n1kubectl get compositionrevisions -o=\u0026#34;custom-columns=NAME:.metadata.name,REVISION:.spec.revision,CHANNEL:.metadata.labels.channel\u0026#34; Expected Output:\n1NAME REVISION CHANNEL 2myvpcs.aws.example.upbound.io-ad265bc 1 dev Note The label dev is automatically created from the Composition. Create Composite Resources This tutorial has four composite resources to cover different update policies and composition selection options. The default behavior is updating XRs to the latest revision of the Composition. However, this can be changed by setting compositionUpdatePolicy: Manual in the XR. It is also possible to select the latest revision with a specific label with compositionRevisionSelector.matchLabels together with compositionUpdatePolicy: Automatic.\nDefault update policy Create an XR without a compositionUpdatePolicy defined. The update policy is Automatic by default:\n1apiVersion: aws.example.upbound.io/v1alpha1 2kind: MyVPC 3metadata: 4 name: vpc-auto 5spec: 6 id: vpc-auto Expected Output:\n1myvpc.aws.example.upbound.io/vpc-auto created Manual update policy Create a Composite Resource with compositionUpdatePolicy: Manual and compositionRevisionRef.\n1apiVersion: aws.example.upbound.io/v1alpha1 2kind: MyVPC 3metadata: 4 name: vpc-man 5spec: 6 id: vpc-man 7 compositionUpdatePolicy: Manual 8 compositionRevisionRef: 9 name: myvpcs.aws.example.upbound.io-ad265bc Expected Output:\n1myvpc.aws.example.upbound.io/vpc-man created Using a selector Create an XR with a compositionRevisionSelector of channel: dev:\n1apiVersion: aws.example.upbound.io/v1alpha1 2kind: MyVPC 3metadata: 4 name: vpc-dev 5spec: 6 id: vpc-dev 7 compositionRevisionSelector: 8 matchLabels: 9 channel: dev Expected Output:\n1myvpc.aws.example.upbound.io/vpc-dev created Create an XR with a compositionRevisionSelector of channel: staging:\n1apiVersion: aws.example.upbound.io/v1alpha1 2kind: MyVPC 3metadata: 4 name: vpc-staging 5spec: 6 id: vpc-staging 7 compositionRevisionSelector: 8 matchLabels: 9 channel: staging Expected Output:\n1myvpc.aws.example.upbound.io/vpc-staging created Verify the Composite Resource with the label channel: staging doesn\u0026rsquo;t have a REVISION.\nAll other XRs have a REVISION matching the created Composition Revision.\n1kubectl get composite -o=\u0026#34;custom-columns=NAME:.metadata.name,SYNCED:.status.conditions[0].status,REVISION:.spec.compositionRevisionRef.name,POLICY:.spec.compositionUpdatePolicy,MATCHLABEL:.spec.compositionRevisionSelector.matchLabels\u0026#34; Expected Output:\n1NAME SYNCED REVISION POLICY MATCHLABEL 2vpc-auto True myvpcs.aws.example.upbound.io-ad265bc Automatic \u0026lt;none\u0026gt; 3vpc-dev True myvpcs.aws.example.upbound.io-ad265bc Automatic map[channel:dev] 4vpc-man True myvpcs.aws.example.upbound.io-ad265bc Manual \u0026lt;none\u0026gt; 5vpc-staging False \u0026lt;none\u0026gt; Automatic map[channel:staging] Note The vpc-staging XR label doesn\u0026rsquo;t match any existing Composition Revisions. Create new Composition revisions Crossplane creates a new CompositionRevision when a Composition is created or updated. Label and annotation changes will also trigger a new CompositionRevision.\nUpdate the Composition label Update the Composition label to channel: staging:\n1kubectl label composition myvpcs.aws.example.upbound.io channel=staging --overwrite Expected Output:\n1composition.apiextensions.crossplane.io/myvpcs.aws.example.upbound.io labeled Verify that Crossplane creates a new Composition revision:\n1kubectl get compositionrevisions -o=\u0026#34;custom-columns=NAME:.metadata.name,REVISION:.spec.revision,CHANNEL:.metadata.labels.channel\u0026#34; Expected Output:\n1NAME REVISION CHANNEL 2myvpcs.aws.example.upbound.io-727b3c8 2 staging 3myvpcs.aws.example.upbound.io-ad265bc 1 dev Verify that Crossplane assigns the Composite Resources vpc-auto and vpc-staging to Composite revision:2.\nXRs vpc-man and vpc-dev are still assigned to the original revision:1:\n1kubectl get composite -o=\u0026#34;custom-columns=NAME:.metadata.name,SYNCED:.status.conditions[0].status,REVISION:.spec.compositionRevisionRef.name,POLICY:.spec.compositionUpdatePolicy,MATCHLABEL:.spec.compositionRevisionSelector.matchLabels\u0026#34; Expected Output:\n1NAME SYNCED REVISION POLICY MATCHLABEL 2vpc-auto True myvpcs.aws.example.upbound.io-727b3c8 Automatic \u0026lt;none\u0026gt; 3vpc-dev True myvpcs.aws.example.upbound.io-ad265bc Automatic map[channel:dev] 4vpc-man True myvpcs.aws.example.upbound.io-ad265bc Manual \u0026lt;none\u0026gt; 5vpc-staging True myvpcs.aws.example.upbound.io-727b3c8 Automatic map[channel:staging] Note vpc-auto always use the latest Revision.\nvpc-staging now matches the label applied to Revision revision:2. Update Composition Spec and Label Update the Composition to disable DNS support in the VPC and change the label from staging back to dev.\nApply the following changes to update the Composition spec and label:\n1apiVersion: apiextensions.crossplane.io/v1 2kind: Composition 3metadata: 4 labels: 5 channel: dev 6 name: myvpcs.aws.example.upbound.io 7spec: 8 writeConnectionSecretsToNamespace: crossplane-system 9 compositeTypeRef: 10 apiVersion: aws.example.upbound.io/v1alpha1 11 kind: MyVPC 12 resources: 13 - base: 14 apiVersion: ec2.aws.upbound.io/v1beta1 15 kind: VPC 16 spec: 17 forProvider: 18 region: us-west-1 19 cidrBlock: 192.168.0.0/16 20 enableDnsSupport: false 21 enableDnsHostnames: true 22 name: my-vcp Expected Output:\n1composition.apiextensions.crossplane.io/myvpcs.aws.example.upbound.io configured Verify that Crossplane creates a new Composition revision:\n1kubectl get compositionrevisions -o=\u0026#34;custom-columns=NAME:.metadata.name,REVISION:.spec.revision,CHANNEL:.metadata.labels.channel\u0026#34; Expected Output:\n1NAME REVISION CHANNEL 2myvpcs.aws.example.upbound.io-727b3c8 2 staging 3myvpcs.aws.example.upbound.io-ad265bc 1 dev 4myvpcs.aws.example.upbound.io-f81c553 3 dev Note Changing the label and the spec values simultaneously is critical for deploying new changes to the dev channel. Verify Crossplane assigns the Composite Resources vpc-auto and vpc-dev to Composite revision:3.\nvpc-staging is assigned to revision:2, and vpc-man is still assigned to the original revision:1:\n1kubectl get composite -o=\u0026#34;custom-columns=NAME:.metadata.name,SYNCED:.status.conditions[0].status,REVISION:.spec.compositionRevisionRef.name,POLICY:.spec.compositionUpdatePolicy,MATCHLABEL:.spec.compositionRevisionSelector.matchLabels\u0026#34; Expected Output:\n1NAME SYNCED REVISION POLICY MATCHLABEL 2vpc-auto True myvpcs.aws.example.upbound.io-f81c553 Automatic \u0026lt;none\u0026gt; 3vpc-dev True myvpcs.aws.example.upbound.io-f81c553 Automatic map[channel:dev] 4vpc-man True myvpcs.aws.example.upbound.io-ad265bc Manual \u0026lt;none\u0026gt; 5vpc-staging True myvpcs.aws.example.upbound.io-727b3c8 Automatic map[channel:staging] Note vpc-dev matches the updated label applied to Revision revision:3. vpc-staging matches the label applied to Revision revision:2. ","title":"Composition Revision Example","url":"/knowledge-base/guides/composition-revisions-example/"},{"content":"This guide discusses the use of \u0026ldquo;Composition Revisions\u0026rdquo; to safely make and roll back changes to a Crossplane Composition. It assumes familiarity with Crossplane, and particularly with Compositions.\nA Composition configures how Crossplane should reconcile a Composite Resource (XR). Put otherwise, when you create an XR the selected Composition determines what managed resources Crossplane will create in response. Let\u0026rsquo;s say for example that you define a PlatformDB XR, which represents your organisation\u0026rsquo;s common database configuration of an Azure MySQL Server and a few firewall rules. The Composition contains the \u0026lsquo;base\u0026rsquo; configuration for the MySQL server and the firewall rules that is extended by the configuration for the PlatformDB.\nThere is a one-to-many relationship between a Composition and the XRs that use it. You might define a Composition named big-platform-db that is used by ten different PlatformDB XRs. Usually, in the interest of self-service, the Composition is managed by a different team from the actual PlatformDB XRs. For example the Composition may be written and maintained by a platform team member, while individual application teams create PlatformDB XRs that use said Composition.\nEach Composition is mutable - you can update it as your organisation\u0026rsquo;s needs change. However, without Composition Revisions updating a Composition can be a risky process. Crossplane constantly uses the Composition to ensure that your actual infrastructure - your MySQL Servers and firewall rules - match your desired state. If you have 10 PlatformDB XRs all using the big-platform-db Composition, all 10 of those XRs will be instantly updated in accordance with any updates you make to the big-platform-db Composition.\nComposition Revisions allow XRs to opt out of automatic updates. Instead you can update your XRs to leverage the latest Composition settings at your own pace. This enables you to canary changes to your infrastructure, or to roll back some XRs to previous Composition settings without rolling back all XRs.\nUsing Composition Revisions When you enable Composition Revisions three things happen:\nCrossplane creates a CompositionRevision for each Composition update. Composite Resources gain a spec.compositionRevisionRef field that specifies which CompositionRevision they use. Composite Resources gain a spec.compositionUpdatePolicy field that specifies how they should be updated to new Composition Revisions. Each time you edit a Composition Crossplane will automatically create a CompositionRevision that represents that \u0026lsquo;revision\u0026rsquo; of the Composition - that unique state. Each revision is allocated an increasing revision number. This gives CompositionRevision consumers an idea about which revision is \u0026rsquo;newest\u0026rsquo;.\nCrossplane distinguishes between the \u0026rsquo;newest\u0026rsquo; and the \u0026lsquo;current\u0026rsquo; revision of a Composition. That is, if you revert a Composition to a previous state that corresponds to an existing CompositionRevision that revision will become \u0026lsquo;current\u0026rsquo; even if it is not the \u0026rsquo;newest\u0026rsquo; revision (i.e. the most latest unique Composition configuration).\nYou can discover which revisions exist using kubectl:\n1# Find all revisions of the Composition named \u0026#39;example\u0026#39; 2kubectl get compositionrevision -l crossplane.io/composition-name=example This should produce output something like:\n1NAME REVISION CURRENT AGE 2example-18pdg 1 False 4m36s 3example-2bgdr 2 True 73s 4example-xjrdm 3 False 61s A Composition is a mutable resource that you can update as your needs change over time. Each CompositionRevision is an immutable snapshot of those needs at a particular point in time.\nCrossplane behaves the same way by default whether Composition Revisions are enabled or not. This is because when you enable Composition Revisions all XRs default to the Automatic compositionUpdatePolicy. XRs support two update policies:\nAutomatic: Automatically use the current CompositionRevision. (Default) Manual: Require manual intervention to change CompositionRevision. The below XR uses the Manual policy. When this policy is used the XR will select the current CompositionRevision when it is first created, but must manually be updated when you wish it to use another CompositionRevision.\n1apiVersion: example.org/v1alpha1 2kind: PlatformDB 3metadata: 4 name: example 5spec: 6 parameters: 7 storageGB: 20 8 # The Manual policy specifies that you do not want this XR to update to the 9 # current CompositionRevision automatically. 10 compositionUpdatePolicy: Manual 11 compositionRef: 12 name: example 13 writeConnectionSecretToRef: 14 name: db-conn Crossplane sets an XR\u0026rsquo;s compositionRevisionRef automatically at creation time regardless of your chosen compositionUpdatePolicy. If you choose the Manual policy you must edit the compositionRevisionRef field when you want your XR to use a different CompositionRevision.\n1apiVersion: example.org/v1alpha1 2kind: PlatformDB 3metadata: 4 name: example 5spec: 6 parameters: 7 storageGB: 20 8 compositionUpdatePolicy: Manual 9 compositionRef: 10 name: example 11 # Update the referenced CompositionRevision if and when you are ready. 12 compositionRevisionRef: 13 name: example-18pdg 14 writeConnectionSecretToRef: 15 name: db-conn ","title":"Composition Revisions","url":"/knowledge-base/guides/composition-revisions/"}]